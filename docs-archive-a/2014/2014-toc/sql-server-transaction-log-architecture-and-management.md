---
title: SQL Server 2014 事务日志体系结构和管理 |Microsoft Docs
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: 4d1a4f97-3fe4-44af-9d4f-f884a6eaa457
author: rothja
ms.author: jroth
ms.openlocfilehash: 8d32950d94bff22d6549c468e8fe8db3f30fd09a
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87578548"
---
# <a name="sql-server-2014-transaction-log-architecture-and-management"></a><span data-ttu-id="c4f25-102">SQL Server 2014 事务日志体系结构和管理</span><span class="sxs-lookup"><span data-stu-id="c4f25-102">SQL Server 2014 Transaction Log Architecture and Management</span></span>

<span data-ttu-id="c4f25-103">**适用于：** 从2008开始 SQL Server () </span><span class="sxs-lookup"><span data-stu-id="c4f25-103">**Applies to:** SQL Server (starting with 2008)</span></span>

  <span data-ttu-id="c4f25-104">每个 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 数据库都具有事务日志，用于记录所有事务以及每个事务对数据库所做的修改。</span><span class="sxs-lookup"><span data-stu-id="c4f25-104">Every [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] database has a transaction log that records all transactions and the database modifications that are made by each transaction.</span></span> <span data-ttu-id="c4f25-105">事务日志是数据库的重要组件，如果系统出现故障，则可能需要使用事务日志将数据库恢复到一致状态。</span><span class="sxs-lookup"><span data-stu-id="c4f25-105">The transaction log is a critical component of the database and, if there is a system failure, the transaction log might be required to bring your database back to a consistent state.</span></span> <span data-ttu-id="c4f25-106">本指南提供有关事务日志的物理和逻辑体系结构的信息。</span><span class="sxs-lookup"><span data-stu-id="c4f25-106">This guide provides information about the physical and logical architecture of the transaction log.</span></span> <span data-ttu-id="c4f25-107">了解该体系结构可以提高您在管理事务日志时的效率。</span><span class="sxs-lookup"><span data-stu-id="c4f25-107">Understanding the architecture can improve your effectiveness in managing transaction logs.</span></span>  

  
##  <a name="transaction-log-logical-architecture"></a><a name="Logical_Arch"></a> <span data-ttu-id="c4f25-108">事务日志逻辑体系结构</span><span class="sxs-lookup"><span data-stu-id="c4f25-108">Transaction Log Logical Architecture</span></span>  

 <span data-ttu-id="c4f25-109">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 事务日志按逻辑运行，就好像事务日志是一串日志记录一样。</span><span class="sxs-lookup"><span data-stu-id="c4f25-109">The [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] transaction log operates logically as if the transaction log is a string of log records.</span></span> <span data-ttu-id="c4f25-110">每条日志记录由一个日志序列号 (LSN) 标识。</span><span class="sxs-lookup"><span data-stu-id="c4f25-110">Each log record is identified by a log sequence number (LSN).</span></span> <span data-ttu-id="c4f25-111">每条新日志记录均写入日志的逻辑结尾处，并使用一个比前面记录的 LSN 更高的 LSN。</span><span class="sxs-lookup"><span data-stu-id="c4f25-111">Each new log record is written to the logical end of the log with an LSN that is higher than the LSN of the record before it.</span></span> <span data-ttu-id="c4f25-112">日志记录按创建时的串行序列存储。</span><span class="sxs-lookup"><span data-stu-id="c4f25-112">Log records are stored in a serial sequence as they are created.</span></span> <span data-ttu-id="c4f25-113">每条日志记录都包含其所属事务的 ID。</span><span class="sxs-lookup"><span data-stu-id="c4f25-113">Each log record contains the ID of the transaction that it belongs to.</span></span> <span data-ttu-id="c4f25-114">对于每个事务，与事务相关联的所有日志记录通过使用可提高事务回滚速度的向后指针挨个链接在一个链中。</span><span class="sxs-lookup"><span data-stu-id="c4f25-114">For each transaction, all log records associated with the transaction are individually linked in a chain using backward pointers that speed the rollback of the transaction.</span></span>  
  
 <span data-ttu-id="c4f25-115">数据修改的日志记录或者记录所执行的逻辑操作，或者记录已修改数据的前像和后像。</span><span class="sxs-lookup"><span data-stu-id="c4f25-115">Log records for data modifications record either the logical operation performed or they record the before and after images of the modified data.</span></span> <span data-ttu-id="c4f25-116">前像是执行操作前的数据副本；后像是执行操作后的数据副本。</span><span class="sxs-lookup"><span data-stu-id="c4f25-116">The before image is a copy of the data before the operation is performed; the after image is a copy of the data after the operation has been performed.</span></span>  
  
 <span data-ttu-id="c4f25-117">操作的恢复步骤取决于日志记录的类型：</span><span class="sxs-lookup"><span data-stu-id="c4f25-117">The steps to recover an operation depend on the type of log record:</span></span>  
  
-   <span data-ttu-id="c4f25-118">记录逻辑操作</span><span class="sxs-lookup"><span data-stu-id="c4f25-118">Logical operation logged</span></span>  
  
    -   <span data-ttu-id="c4f25-119">若要前滚逻辑操作，请再次执行该操作。</span><span class="sxs-lookup"><span data-stu-id="c4f25-119">To roll the logical operation forward, the operation is performed again.</span></span>  
  
    -   <span data-ttu-id="c4f25-120">若要回滚逻辑操作，请执行相反的逻辑操作。</span><span class="sxs-lookup"><span data-stu-id="c4f25-120">To roll the logical operation back, the reverse logical operation is performed.</span></span>  
  
-   <span data-ttu-id="c4f25-121">记录前像和后像</span><span class="sxs-lookup"><span data-stu-id="c4f25-121">Before and after image logged</span></span>  
  
    -   <span data-ttu-id="c4f25-122">若要前滚操作，请应用后像。</span><span class="sxs-lookup"><span data-stu-id="c4f25-122">To roll the operation forward, the after image is applied.</span></span>  
  
    -   <span data-ttu-id="c4f25-123">若要回滚操作，请应用前像。</span><span class="sxs-lookup"><span data-stu-id="c4f25-123">To roll the operation back, the before image is applied.</span></span>  
  
 <span data-ttu-id="c4f25-124">许多类型的操作都记录在事务日志中。</span><span class="sxs-lookup"><span data-stu-id="c4f25-124">Many types of operations are recorded in the transaction log.</span></span> <span data-ttu-id="c4f25-125">这些操作包括：</span><span class="sxs-lookup"><span data-stu-id="c4f25-125">These operations include:</span></span>  
  
-   <span data-ttu-id="c4f25-126">每个事务的开始和结束。</span><span class="sxs-lookup"><span data-stu-id="c4f25-126">The start and end of each transaction.</span></span>  
  
-   <span data-ttu-id="c4f25-127">每次数据修改（插入、更新或删除）。</span><span class="sxs-lookup"><span data-stu-id="c4f25-127">Every data modification (insert, update, or delete).</span></span> <span data-ttu-id="c4f25-128">这包括系统存储过程或数据定义语言 (DDL) 语句对包括系统表在内的任何表所做的更改。</span><span class="sxs-lookup"><span data-stu-id="c4f25-128">This includes changes by system stored procedures or data definition language (DDL) statements to any table, including system tables.</span></span>  
  
-   <span data-ttu-id="c4f25-129">每次分配或释放区和页。</span><span class="sxs-lookup"><span data-stu-id="c4f25-129">Every extent and page allocation or deallocation.</span></span>  
  
-   <span data-ttu-id="c4f25-130">创建或删除表或索引。</span><span class="sxs-lookup"><span data-stu-id="c4f25-130">Creating or dropping a table or index.</span></span>  
  
 <span data-ttu-id="c4f25-131">回滚操作也记录在日志中。</span><span class="sxs-lookup"><span data-stu-id="c4f25-131">Rollback operations are also logged.</span></span> <span data-ttu-id="c4f25-132">每个事务都在事务日志中保留空间，以确保存在足够的日志空间来支持由显式回滚语句或遇到错误引起的回滚。</span><span class="sxs-lookup"><span data-stu-id="c4f25-132">Each transaction reserves space on the transaction log to make sure that enough log space exists to support a rollback that is caused by either an explicit rollback statement or if an error is encountered.</span></span> <span data-ttu-id="c4f25-133">保留的空间量取决于在事务中执行的操作，但通常等于用于记录每个操作的空间量。</span><span class="sxs-lookup"><span data-stu-id="c4f25-133">The amount of space reserved depends on the operations performed in the transaction, but generally it is equal to the amount of space used to log each operation.</span></span> <span data-ttu-id="c4f25-134">事务完成后将释放此保留空间。</span><span class="sxs-lookup"><span data-stu-id="c4f25-134">This reserved space is freed when the transaction is completed.</span></span>  
  
 <span data-ttu-id="c4f25-135"> 日志文件中从必须存在以确保数据库范围内成功回滚的第一条日志记录到最后写入的日志记录之间的部分称为日志的活动部分，即“活动日志\”\**。</span><span class="sxs-lookup"><span data-stu-id="c4f25-135">The section of the log file from the first log record that must be present for a successful database-wide rollback to the last-written log record is called the active part of the log, or the *active log*.</span></span> <span data-ttu-id="c4f25-136">这是进行数据库完整恢复所需的日志部分。</span><span class="sxs-lookup"><span data-stu-id="c4f25-136">This is the section of the log required to a full recovery of the database.</span></span> <span data-ttu-id="c4f25-137">永远不能截断活动日志的任何部分。</span><span class="sxs-lookup"><span data-stu-id="c4f25-137">No part of the active log can ever be truncated.</span></span> <span data-ttu-id="c4f25-138">此第一条日志记录的日志序列号 (LSN) 称为最小恢复 LSN (*MinLSN*) 。</span><span class="sxs-lookup"><span data-stu-id="c4f25-138">The log sequence number (LSN) of this first log record is known as the minimum recovery LSN (*MinLSN*).</span></span>  
  
##  <a name="transaction-log-physical-architecture"></a><a name="physical_arch"></a> <span data-ttu-id="c4f25-139">事务日志物理体系结构</span><span class="sxs-lookup"><span data-stu-id="c4f25-139">Transaction Log Physical Architecture</span></span>  

 <span data-ttu-id="c4f25-140">数据库中的事务日志映射在一个或多个物理文件上。</span><span class="sxs-lookup"><span data-stu-id="c4f25-140">The transaction log in a database maps over one or more physical files.</span></span> <span data-ttu-id="c4f25-141">从概念上讲，日志文件是一系列日志记录。</span><span class="sxs-lookup"><span data-stu-id="c4f25-141">Conceptually, the log file is a string of log records.</span></span> <span data-ttu-id="c4f25-142">从物理上讲，日志记录序列被有效地存储在实现事务日志的物理文件集中。</span><span class="sxs-lookup"><span data-stu-id="c4f25-142">Physically, the sequence of log records is stored efficiently in the set of physical files that implement the transaction log.</span></span> <span data-ttu-id="c4f25-143">每个数据库必须至少有一个日志文件。</span><span class="sxs-lookup"><span data-stu-id="c4f25-143">There must be at least one log file for each database.</span></span>  
  
 <span data-ttu-id="c4f25-144">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 在内部将每一物理日志文件分成多个虚拟日志文件。</span><span class="sxs-lookup"><span data-stu-id="c4f25-144">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] divides each physical log file internally into a number of virtual log files.</span></span> <span data-ttu-id="c4f25-145">虚拟日志文件没有固定大小，且物理日志文件所包含的虚拟日志文件数不固定。</span><span class="sxs-lookup"><span data-stu-id="c4f25-145">Virtual log files have no fixed size, and there is no fixed number of virtual log files for a physical log file.</span></span> <span data-ttu-id="c4f25-146">[!INCLUDE[ssDE](../includes/ssde-md.md)] 在创建或扩展日志文件时动态选择虚拟日志文件的大小。</span><span class="sxs-lookup"><span data-stu-id="c4f25-146">The [!INCLUDE[ssDE](../includes/ssde-md.md)] chooses the size of the virtual log files dynamically while it is creating or extending log files.</span></span> <span data-ttu-id="c4f25-147">[!INCLUDE[ssDE](../includes/ssde-md.md)] 尝试维护少量的虚拟文件。</span><span class="sxs-lookup"><span data-stu-id="c4f25-147">The [!INCLUDE[ssDE](../includes/ssde-md.md)] tries to maintain a small number of virtual files.</span></span> <span data-ttu-id="c4f25-148">在扩展日志文件后，虚拟文件的大小是现有日志大小和新文件增量大小之和。</span><span class="sxs-lookup"><span data-stu-id="c4f25-148">The size of the virtual files after a log file has been extended is the sum of the size of the existing log and the size of the new file increment.</span></span> <span data-ttu-id="c4f25-149">管理员不能配置或设置虚拟日志文件的大小或数量。</span><span class="sxs-lookup"><span data-stu-id="c4f25-149">The size or number of virtual log files cannot be configured or set by administrators.</span></span>  
  
 <span data-ttu-id="c4f25-150">只有当物理日志文件使用较小的 size\*\* 和 growth_increment\*\* 值定义时，虚拟日志文件才会影响系统性能。</span><span class="sxs-lookup"><span data-stu-id="c4f25-150">The only time virtual log files affect system performance is if the physical log files are defined by small *size* and *growth_increment* values.</span></span> <span data-ttu-id="c4f25-151">size\*\* 值为日志文件的初始大小，growth_increment\*\* 值则为每次需要新空间时为文件增加的空间大小。</span><span class="sxs-lookup"><span data-stu-id="c4f25-151">The *size* value is the initial size for the log file and the *growth_increment* value is the amount of space added to the file every time new space is required.</span></span> <span data-ttu-id="c4f25-152">如果这些日志文件由于许多微小增量而增长到很大，则它们将具有很多虚拟日志文件。</span><span class="sxs-lookup"><span data-stu-id="c4f25-152">If the log files grow to a large size because of many small increments, they will have many virtual log files.</span></span> <span data-ttu-id="c4f25-153">这会降低数据库启动以及日志备份和还原操作的速度。</span><span class="sxs-lookup"><span data-stu-id="c4f25-153">This can slow down database startup and also log backup and restore operations.</span></span> <span data-ttu-id="c4f25-154">建议你为日志文件分配一个接近于最终所需大小的 size\*\* 值，并且还要分配一个相对较大的 growth_increment\*\* 值。</span><span class="sxs-lookup"><span data-stu-id="c4f25-154">We recommend that you assign log files a *size* value close to the final size required, and also have a relatively large *growth_increment* value.</span></span> <span data-ttu-id="c4f25-155">有关这些参数的详细信息，请参阅 [ALTER DATABASE 文件和文件组选项 (Transact-SQL)](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options)。</span><span class="sxs-lookup"><span data-stu-id="c4f25-155">For more information about these parameters, see [ALTER DATABASE File and Filegroup Options &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options).</span></span>  
  
 <span data-ttu-id="c4f25-156">事务日志是一种回绕的文件。</span><span class="sxs-lookup"><span data-stu-id="c4f25-156">The transaction log is a wrap-around file.</span></span> <span data-ttu-id="c4f25-157">例如，假设有一个数据库，它包含一个分成四个虚拟日志文件的物理日志文件。</span><span class="sxs-lookup"><span data-stu-id="c4f25-157">For example, consider a database with one physical log file divided into four virtual log files.</span></span> <span data-ttu-id="c4f25-158">当创建数据库时，逻辑日志文件从物理日志文件的始端开始。</span><span class="sxs-lookup"><span data-stu-id="c4f25-158">When the database is created, the logical log file begins at the start of the physical log file.</span></span> <span data-ttu-id="c4f25-159">新日志记录被添加到逻辑日志的末端，然后向物理日志的末端扩张。</span><span class="sxs-lookup"><span data-stu-id="c4f25-159">New log records are added at the end of the logical log and expand toward the end of the physical log.</span></span> <span data-ttu-id="c4f25-160">日志截断将释放记录全部在最小恢复日志序列号 (MinLSN) 之前出现的所有虚拟日志。</span><span class="sxs-lookup"><span data-stu-id="c4f25-160">Log truncation frees any virtual logs whose records all appear in front of the minimum recovery log sequence number (MinLSN).</span></span> <span data-ttu-id="c4f25-161">MinLSN\*\* 是成功进行数据库范围内回滚所需的最早日志记录的日志序列号。</span><span class="sxs-lookup"><span data-stu-id="c4f25-161">The *MinLSN* is the log sequence number of the oldest log record that is required for a successful database-wide rollback.</span></span> <span data-ttu-id="c4f25-162">示例数据库中的事务日志的外观与下图所示相似。</span><span class="sxs-lookup"><span data-stu-id="c4f25-162">The transaction log in the example database would look similar to the one in the following illustration.</span></span>  
  
 <span data-ttu-id="c4f25-163">![分为四个虚拟日志文件的日志文件](media/tranlog3.gif "分为四个虚拟日志文件的日志文件")</span><span class="sxs-lookup"><span data-stu-id="c4f25-163">![Log file divided into four virtual log files](media/tranlog3.gif "Log file divided into four virtual log files")</span></span>  
  
 <span data-ttu-id="c4f25-164">当逻辑日志的末端到达物理日志文件的末端时，新的日志记录将回绕到物理日志文件的始端。</span><span class="sxs-lookup"><span data-stu-id="c4f25-164">When the end of the logical log reaches the end of the physical log file, the new log records wrap around to the start of the physical log file.</span></span>  
  
 <span data-ttu-id="c4f25-165">![日志记录回绕到日志文件的开头](media/tranlog4.gif "日志记录回绕到日志文件的开头")</span><span class="sxs-lookup"><span data-stu-id="c4f25-165">![Log records wrap around to start of log file](media/tranlog4.gif "Log records wrap around to start of log file")</span></span>  
  
 <span data-ttu-id="c4f25-166">这个循环不断重复，只要逻辑日志的末端不到达逻辑日志的始端。</span><span class="sxs-lookup"><span data-stu-id="c4f25-166">This cycle repeats endlessly, as long as the end of the logical log never reaches the beginning of the logical log.</span></span> <span data-ttu-id="c4f25-167">如果经常截断旧的日志记录，始终为到下一个检查点前创建的所有新日志记录保留足够的空间，则日志永远不会填满。</span><span class="sxs-lookup"><span data-stu-id="c4f25-167">If the old log records are truncated frequently enough to always leave sufficient room for all the new log records created through the next checkpoint, the log never fills.</span></span> <span data-ttu-id="c4f25-168">但是，如果逻辑日志的末端真的到达了逻辑日志的始端，将发生以下两种情况之一：</span><span class="sxs-lookup"><span data-stu-id="c4f25-168">However, if the end of the logical log does reach the start of the logical log, one of two things occurs:</span></span>  
  
-   <span data-ttu-id="c4f25-169">如果对日志启用了 FILEGROWTH 设置且磁盘上有可用空间，则文件就按 growth_increment\*\* 参数指定的数量增大，并且新的日志记录将添加到增大的空间中。</span><span class="sxs-lookup"><span data-stu-id="c4f25-169">If the FILEGROWTH setting is enabled for the log and space is available on the disk, the file is extended by the amount specified in the *growth_increment* parameter and the new log records are added to the extension.</span></span> <span data-ttu-id="c4f25-170">有关 FILEGROWTH 设置的详细信息，请参阅 [ALTER DATABASE 文件和文件组选项 (Transact-SQL)](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options)。</span><span class="sxs-lookup"><span data-stu-id="c4f25-170">For more information about the FILEGROWTH setting, see [ALTER DATABASE File and Filegroup Options &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options).</span></span>  
  
-   <span data-ttu-id="c4f25-171">如果未启用 FILEGROWTH 设置，或保存日志文件的磁盘的可用空间比 growth_increment\*\* 中指定的数量少，则会出现 9002 错误。</span><span class="sxs-lookup"><span data-stu-id="c4f25-171">If the FILEGROWTH setting is not enabled, or the disk that is holding the log file has less free space than the amount specified in *growth_increment*, an 9002 error is generated.</span></span>  
  
 <span data-ttu-id="c4f25-172">如果日志包含多个物理日志文件，则逻辑日志在回绕到首个物理日志文件始端之前，将沿着所有物理日志文件移动。</span><span class="sxs-lookup"><span data-stu-id="c4f25-172">If the log contains multiple physical log files, the logical log will move through all the physical log files before it wraps back to the start of the first physical log file.</span></span>  
  
### <a name="log-truncation"></a><span data-ttu-id="c4f25-173">日志截断</span><span class="sxs-lookup"><span data-stu-id="c4f25-173">Log Truncation</span></span>  

 <span data-ttu-id="c4f25-174">日志截断主要用于阻止日志填充。</span><span class="sxs-lookup"><span data-stu-id="c4f25-174">Log truncation is essential to keep the log from filling.</span></span> <span data-ttu-id="c4f25-175">日志截断从 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 数据库的逻辑事务日志中删除不活动的虚拟日志文件，释放逻辑日志中的空间以便物理事务日志重用这些空间。</span><span class="sxs-lookup"><span data-stu-id="c4f25-175">Log truncation deletes inactive virtual log files from the logical transaction log of a [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] database, freeing space in the logical log for reuse by the physical transaction log.</span></span> <span data-ttu-id="c4f25-176">如果事务日志从不截断，它最终将填满分配给物理日志文件的所有磁盘空间。</span><span class="sxs-lookup"><span data-stu-id="c4f25-176">If a transaction log were never truncated, it would eventually fill all the disk space that is allocated to its physical log files.</span></span> <span data-ttu-id="c4f25-177">但是，在截断日志前，必须执行检查点操作。</span><span class="sxs-lookup"><span data-stu-id="c4f25-177">However, before the log can be truncated, a checkpoint operation must occur.</span></span> <span data-ttu-id="c4f25-178">检查点将当前内存中已修改的页（称为“脏页”）和事务日志信息从内存写入磁盘。</span><span class="sxs-lookup"><span data-stu-id="c4f25-178">A checkpoint writes the current in-memory modified pages (known as dirty pages) and transaction log information from memory to disk.</span></span> <span data-ttu-id="c4f25-179">执行检查点时，事务日志的不活动部分将标记为可重用。</span><span class="sxs-lookup"><span data-stu-id="c4f25-179">When the checkpoint is performed, the inactive portion of the transaction log is marked as reusable.</span></span> <span data-ttu-id="c4f25-180">此后，日志截断可以释放不活动的部分。</span><span class="sxs-lookup"><span data-stu-id="c4f25-180">Thereafter, the inactive portion can be freed by log truncation.</span></span> <span data-ttu-id="c4f25-181">有关检查点的详细信息，请参阅[数据库检查点 (SQL Server)](../relational-databases/logs/database-checkpoints-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="c4f25-181">For more information about checkpoints, see [Database Checkpoints &#40;SQL Server&#41;](../relational-databases/logs/database-checkpoints-sql-server.md).</span></span>  
  
 <span data-ttu-id="c4f25-182">下列各图显示了截断前后的事务日志。</span><span class="sxs-lookup"><span data-stu-id="c4f25-182">The following illustrations show a transaction log before and after truncation.</span></span> <span data-ttu-id="c4f25-183">第一个图显示了从未截断的事务日志。</span><span class="sxs-lookup"><span data-stu-id="c4f25-183">The first illustration shows a transaction log that has never been truncated.</span></span> <span data-ttu-id="c4f25-184">当前，逻辑日志使用四个虚拟日志文件。</span><span class="sxs-lookup"><span data-stu-id="c4f25-184">Currently, four virtual log files are in use by the logical log.</span></span> <span data-ttu-id="c4f25-185">逻辑日志开始于第一个逻辑日志文件的前面，并结束于虚拟日志 4。</span><span class="sxs-lookup"><span data-stu-id="c4f25-185">The logical log starts at the front of the first virtual log file and ends at virtual log 4.</span></span> <span data-ttu-id="c4f25-186">MinLSN 记录位于虚拟日志 3 中。</span><span class="sxs-lookup"><span data-stu-id="c4f25-186">The MinLSN record is in virtual log 3.</span></span> <span data-ttu-id="c4f25-187">虚拟日志 1 和虚拟日志 2 仅包含不活动的日志记录。</span><span class="sxs-lookup"><span data-stu-id="c4f25-187">Virtual log 1 and virtual log 2 contain only inactive log records.</span></span> <span data-ttu-id="c4f25-188">这些记录可以截断。</span><span class="sxs-lookup"><span data-stu-id="c4f25-188">These records can be truncated.</span></span> <span data-ttu-id="c4f25-189">虚拟日志 5 仍未使用，不属于当前逻辑日志。</span><span class="sxs-lookup"><span data-stu-id="c4f25-189">Virtual log 5 is still unused and is not part of the current logical log.</span></span>  
  
 <span data-ttu-id="c4f25-190">![具有四个虚拟日志的事务日志](media/tranlog2.gif "具有四个虚拟日志的事务日志")</span><span class="sxs-lookup"><span data-stu-id="c4f25-190">![Transaction log with four virtual logs](media/tranlog2.gif "Transaction log with four virtual logs")</span></span>  
  
 <span data-ttu-id="c4f25-191">第二个图显示了日志截断后的情形。</span><span class="sxs-lookup"><span data-stu-id="c4f25-191">The second illustration shows how the log appears after being truncated.</span></span> <span data-ttu-id="c4f25-192">已释放虚拟日志 1 和虚拟日志 2 以供重新使用。</span><span class="sxs-lookup"><span data-stu-id="c4f25-192">Virtual log 1 and virtual log 2 have been freed for reuse.</span></span> <span data-ttu-id="c4f25-193">现在，逻辑日志开始于虚拟日志 3 的开头。</span><span class="sxs-lookup"><span data-stu-id="c4f25-193">The logical log now starts at the beginning of virtual log 3.</span></span> <span data-ttu-id="c4f25-194">虚拟日志 5 仍未使用，它不属于当前逻辑日志。</span><span class="sxs-lookup"><span data-stu-id="c4f25-194">Virtual log 5 is still unused, and it is not part of the current logical log.</span></span>  
  
 <span data-ttu-id="c4f25-195">![分为四个虚拟日志文件的日志文件](media/tranlog3.gif "分为四个虚拟日志文件的日志文件")</span><span class="sxs-lookup"><span data-stu-id="c4f25-195">![Log file divided into four virtual log files](media/tranlog3.gif "Log file divided into four virtual log files")</span></span>  
  
 <span data-ttu-id="c4f25-196">除非由于某些原因导致延迟，否则将在以下事件后自动发生日志截断：</span><span class="sxs-lookup"><span data-stu-id="c4f25-196">Log truncation occurs automatically after the following events, except when delayed for some reason:</span></span>  
  
-   <span data-ttu-id="c4f25-197">简单恢复模式下，在检查点之后发生。</span><span class="sxs-lookup"><span data-stu-id="c4f25-197">Under the simple recovery model, after a checkpoint.</span></span>  
  
-   <span data-ttu-id="c4f25-198">完整恢复模式或大容量日志恢复模式下，在日志备份之后发生（如果自上次备份后出现检查点）。</span><span class="sxs-lookup"><span data-stu-id="c4f25-198">Under the full recovery model or bulk-logged recovery model, after a log backup, if a checkpoint has occurred since the previous backup.</span></span>  
  
 <span data-ttu-id="c4f25-199">日志截断会由于多种因素发生延迟。</span><span class="sxs-lookup"><span data-stu-id="c4f25-199">Log truncation can be delayed by a variety of factors.</span></span> <span data-ttu-id="c4f25-200">如果日志截断延迟的时间较长，则事务日志可能会填满磁盘空间。</span><span class="sxs-lookup"><span data-stu-id="c4f25-200">In the event of a long delay in log truncation, the transaction log can fill up.</span></span> <span data-ttu-id="c4f25-201">有关信息，请参阅[可能延迟日志截断的因素](../relational-databases/logs/the-transaction-log-sql-server.md#FactorsThatDelayTruncation)和[解决事务日志完全 &#40;SQL Server 错误 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md)的因素。</span><span class="sxs-lookup"><span data-stu-id="c4f25-201">For information, see [Factors That Can Delay Log Truncation](../relational-databases/logs/the-transaction-log-sql-server.md#FactorsThatDelayTruncation) and [Troubleshoot a Full Transaction Log &#40;SQL Server Error 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md).</span></span>  
  
##  <a name="write-ahead-transaction-log"></a><a name="WAL"></a> <span data-ttu-id="c4f25-202">预写事务日志</span><span class="sxs-lookup"><span data-stu-id="c4f25-202">Write-Ahead Transaction Log</span></span>  

 <span data-ttu-id="c4f25-203">本节说明预写事务日志在将数据修改记录到磁盘的过程中所起的作用。</span><span class="sxs-lookup"><span data-stu-id="c4f25-203">This section describes the role of the write-ahead transaction log in recording data modifications to disk.</span></span> [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="c4f25-204">使用预写日志 (WAL)，此日志确保在将关联的日志记录写入磁盘后再将数据修改写入磁盘。</span><span class="sxs-lookup"><span data-stu-id="c4f25-204">uses a write-ahead log (WAL), which guarantees that no data modifications are written to disk before the associated log record is written to disk.</span></span> <span data-ttu-id="c4f25-205">这维护了事务的 ACID 属性。</span><span class="sxs-lookup"><span data-stu-id="c4f25-205">This maintains the ACID properties for a transaction.</span></span>  
  
 <span data-ttu-id="c4f25-206">要了解预写日志的工作方式，了解如何将修改的数据写入磁盘很重要。</span><span class="sxs-lookup"><span data-stu-id="c4f25-206">To understand how the write-ahead log works, it is important for you to know how modified data is written to disk.</span></span> [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="c4f25-207">维护一个缓冲区缓存，在必须检索数据时从其中读取数据页。</span><span class="sxs-lookup"><span data-stu-id="c4f25-207">maintains a buffer cache into which it reads data pages when data must be retrieved.</span></span> <span data-ttu-id="c4f25-208">当在缓冲区缓存中修改某个页面时，它不会立即写回磁盘;相反，该页标记为已*更新*。</span><span class="sxs-lookup"><span data-stu-id="c4f25-208">When a page is modified in the buffer cache, it is not immediately written back to disk; instead, the page is marked as *dirty*.</span></span> <span data-ttu-id="c4f25-209">在将数据页物理写入磁盘之前，可以将其逻辑写入多次。</span><span class="sxs-lookup"><span data-stu-id="c4f25-209">A data page can have more than one logical write made before it is physically written to disk.</span></span> <span data-ttu-id="c4f25-210">对于每次逻辑写入，都会在记录修改的日志缓存中插入一条事务日志记录。</span><span class="sxs-lookup"><span data-stu-id="c4f25-210">For each logical write, a transaction log record is inserted in the log cache that records the modification.</span></span> <span data-ttu-id="c4f25-211">在将关联的脏页从缓冲区缓存中删除并写入磁盘之前，必须将这条些日志记录写入磁盘。</span><span class="sxs-lookup"><span data-stu-id="c4f25-211">The log records must be written to disk before the associated dirty page is removed from the buffer cache and written to disk.</span></span> <span data-ttu-id="c4f25-212">检查点进程定期在缓冲区高速缓存中扫描包含来自指定数据库的页的缓冲区，然后将所有脏页写入磁盘。</span><span class="sxs-lookup"><span data-stu-id="c4f25-212">The checkpoint process periodically scans the buffer cache for buffers with pages from a specified database and writes all dirty pages to disk.</span></span> <span data-ttu-id="c4f25-213">CHECKPOINT 可创建一个检查点，在该点保证全部脏页都已写入磁盘，从而在以后的恢复过程中节省时间。</span><span class="sxs-lookup"><span data-stu-id="c4f25-213">Checkpoints save time during a later recovery by creating a point at which all dirty pages are guaranteed to have been written to disk.</span></span>  
  
 <span data-ttu-id="c4f25-214">将修改后的数据页从高速缓冲存储器写入磁盘的操作称为刷新页。</span><span class="sxs-lookup"><span data-stu-id="c4f25-214">Writing a modified data page from the buffer cache to disk is called flushing the page.</span></span> [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="c4f25-215">具有一个逻辑，它可以在写入关联的日志记录前防止刷新脏页。</span><span class="sxs-lookup"><span data-stu-id="c4f25-215">has logic that prevents a dirty page from being flushed before the associated log record is written.</span></span> <span data-ttu-id="c4f25-216">日志记录将在提交事务时写入磁盘。</span><span class="sxs-lookup"><span data-stu-id="c4f25-216">Log records are written to disk when the transactions are committed.</span></span>  
  
##  <a name="transaction-log-backups"></a><a name="Backups"></a><span data-ttu-id="c4f25-217">事务日志备份</span><span class="sxs-lookup"><span data-stu-id="c4f25-217">Transaction Log Backups</span></span>  

 <span data-ttu-id="c4f25-218">本节介绍了有关如何备份和还原（应用）事务日志的概念。</span><span class="sxs-lookup"><span data-stu-id="c4f25-218">This section presents concepts about how to back up and restore (apply) transaction logs.</span></span> <span data-ttu-id="c4f25-219">在完整恢复模式和批量日志恢复模式下，执行例行事务日志备份（“日志备份”\*\*）对于恢复数据十分必要。</span><span class="sxs-lookup"><span data-stu-id="c4f25-219">Under the full and bulk-logged recovery models, taking routine backups of transaction logs (*log backups*) is necessary for recovering data.</span></span> <span data-ttu-id="c4f25-220">可以在任何完整备份运行的时候备份日志。</span><span class="sxs-lookup"><span data-stu-id="c4f25-220">You can back up the log while any full backup is running.</span></span> <span data-ttu-id="c4f25-221">有关恢复模型的详细信息，请参阅 [SQL Server 数据库的备份和还原](../relational-databases/backup-restore/back-up-and-restore-of-sql-server-databases.md)。</span><span class="sxs-lookup"><span data-stu-id="c4f25-221">For more information about recovery models, see [Back Up and Restore of SQL Server Databases](../relational-databases/backup-restore/back-up-and-restore-of-sql-server-databases.md).</span></span>  
  
 <span data-ttu-id="c4f25-222">在创建第一个日志备份之前，必须先创建完整备份（如数据库备份或一组文件备份中的第一个备份）。</span><span class="sxs-lookup"><span data-stu-id="c4f25-222">Before you can create the first log backup, you must create a full backup, such as a database backup or the first in a set of file backups.</span></span> <span data-ttu-id="c4f25-223">仅使用文件备份还原数据库会较复杂。</span><span class="sxs-lookup"><span data-stu-id="c4f25-223">Restoring a database by using only file backups can become complex.</span></span> <span data-ttu-id="c4f25-224">因此，建议您尽可能从完整数据库备份开始。</span><span class="sxs-lookup"><span data-stu-id="c4f25-224">Therefore, we recommend that you start with a full database backup when you can.</span></span> <span data-ttu-id="c4f25-225">此后，必须定期备份事务日志。</span><span class="sxs-lookup"><span data-stu-id="c4f25-225">Thereafter, backing up the transaction log regularly is necessary.</span></span> <span data-ttu-id="c4f25-226">这不仅能最小化工作丢失风险，还有助于事务日志的截断。</span><span class="sxs-lookup"><span data-stu-id="c4f25-226">This not only minimizes work-loss exposure but also enables truncation of the transaction log.</span></span> <span data-ttu-id="c4f25-227">通常，事务日志在每次常规日志备份之后截断。</span><span class="sxs-lookup"><span data-stu-id="c4f25-227">Typically, the transaction log is truncated after every conventional log backup.</span></span>  
  
 <span data-ttu-id="c4f25-228">建议经常进行日志备份，其频率应足够支持您的业务需求，尤其是您对损坏的日志驱动器可能导致的数据丢失的容忍程度。</span><span class="sxs-lookup"><span data-stu-id="c4f25-228">We recommend taking frequent enough log backups to support your business requirements, specifically your tolerance for work loss such as might be caused by a damaged log drive.</span></span> <span data-ttu-id="c4f25-229">适当的日志备份频率取决于您对工作丢失风险的容忍程度与所能存储、管理和潜在还原的日志备份数量之间的平衡。</span><span class="sxs-lookup"><span data-stu-id="c4f25-229">The appropriate frequency for taking log backups depends on your tolerance for work-loss exposure balanced by how many log backups you can store, manage, and, potentially, restore.</span></span> <span data-ttu-id="c4f25-230">每 15 到 30 分钟进行一次日志备份可能就已足够。</span><span class="sxs-lookup"><span data-stu-id="c4f25-230">Taking a log backup every 15 to 30 minutes might be enough.</span></span> <span data-ttu-id="c4f25-231">但是如果您的业务要求将工作丢失的风险最小化，请考虑进行更频繁的日志备份。</span><span class="sxs-lookup"><span data-stu-id="c4f25-231">If your business requires that you minimize work-loss exposure, consider taking log backups more frequently.</span></span> <span data-ttu-id="c4f25-232">频繁的日志备份还有增加日志截断频率的优点，其结果是日志文件较小。</span><span class="sxs-lookup"><span data-stu-id="c4f25-232">More frequent log backups have the added advantage of increasing the frequency of log truncation, resulting in smaller log files.</span></span>  
  
 <span data-ttu-id="c4f25-233">若要限制需要还原的日志备份的数量，必须定期备份数据。</span><span class="sxs-lookup"><span data-stu-id="c4f25-233">To limit the number of log backups that you need to restore, it is essential to routinely back up your data.</span></span> <span data-ttu-id="c4f25-234">例如，可以制定这样一个计划：每周进行一次完整数据库备份，每天进行若干次差异数据库备份。</span><span class="sxs-lookup"><span data-stu-id="c4f25-234">For example, you might schedule a weekly full database backup and daily differential database backups.</span></span>  
  
### <a name="the-log-chain"></a><span data-ttu-id="c4f25-235">日志链</span><span class="sxs-lookup"><span data-stu-id="c4f25-235">The Log Chain</span></span>  

 <span data-ttu-id="c4f25-236">日志备份的连续序列称为“日志链”\*\*。</span><span class="sxs-lookup"><span data-stu-id="c4f25-236">A continuous sequence of log backups is called a *log chain*.</span></span> <span data-ttu-id="c4f25-237">日志链从数据库的完整备份开始。</span><span class="sxs-lookup"><span data-stu-id="c4f25-237">A log chain starts with a full backup of the database.</span></span> <span data-ttu-id="c4f25-238">通常，仅当第一次备份数据库时，或者将恢复模式从简单恢复模式切换到完整恢复模式或大容量日志恢复模式之后，才会开始一个新的日志链。</span><span class="sxs-lookup"><span data-stu-id="c4f25-238">Usually, a new log chain is only started when the database is backed up for the first time or after the recovery model is switched from simple recovery to full or bulk-logged recovery.</span></span> <span data-ttu-id="c4f25-239">除非在创建完整数据库备份时选择覆盖现有备份集，否则现有的日志链将保持不变。</span><span class="sxs-lookup"><span data-stu-id="c4f25-239">Unless you choose to overwrite existing backup sets when creating a full database backup, the existing log chain remains intact.</span></span> <span data-ttu-id="c4f25-240">在该日志链保持不变的情况下，便可从介质集中的任何完整数据库备份还原数据库，然后再还原相应恢复点之前的所有后续日志备份。</span><span class="sxs-lookup"><span data-stu-id="c4f25-240">With the log chain intact, you can restore your database from any full database backup in the media set, followed by all subsequent log backups up through your recovery point.</span></span> <span data-ttu-id="c4f25-241">恢复点可以是上次日志备份的结尾，也可以是任何日志备份中的特定恢复点。</span><span class="sxs-lookup"><span data-stu-id="c4f25-241">The recovery point could be the end of the last log backup or a specific recovery point in any of the log backups.</span></span> <span data-ttu-id="c4f25-242">有关详细信息，请参阅[事务日志备份 (SQL Server)](../relational-databases/backup-restore/transaction-log-backups-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="c4f25-242">For more information, see [Transaction Log Backups &#40;SQL Server&#41;](../relational-databases/backup-restore/transaction-log-backups-sql-server.md).</span></span>  
  
 <span data-ttu-id="c4f25-243">若要将数据库还原到故障点，必须保证日志链是完整的。</span><span class="sxs-lookup"><span data-stu-id="c4f25-243">To restore a database up to the point of failure, the log chain must be intact.</span></span> <span data-ttu-id="c4f25-244">也就是说，事务日志备份的连续序列必须能够延续到故障点。</span><span class="sxs-lookup"><span data-stu-id="c4f25-244">That is, an unbroken sequence of transaction log backups must extend up to the point of failure.</span></span> <span data-ttu-id="c4f25-245">此日志序列的开始位置取决于您所还原的数据备份类型：数据库备份、部分备份或文件备份。</span><span class="sxs-lookup"><span data-stu-id="c4f25-245">Where this sequence of log must start depends on the type of data backups you are restoring: database, partial, or file.</span></span> <span data-ttu-id="c4f25-246">对于数据库备份或部分备份，日志备份序列必须从数据库备份或部分备份的结尾处开始延续。</span><span class="sxs-lookup"><span data-stu-id="c4f25-246">For a database or partial backup, the sequence of log backups must extend from the end of a database or partial backup.</span></span> <span data-ttu-id="c4f25-247">对于一组文件备份，日志备份序列必须从整组文件备份的开头开始延续。</span><span class="sxs-lookup"><span data-stu-id="c4f25-247">For a set of file backups, the sequence of log backups must extend from the start of a full set of file backups.</span></span> <span data-ttu-id="c4f25-248">有关详细信息，请参阅[应用事务日志备份 (SQL Server)](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="c4f25-248">For more information, see [Apply Transaction Log Backups &#40;SQL Server&#41;](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md).</span></span>  
  
### <a name="restore-log-backups"></a><span data-ttu-id="c4f25-249">还原日志备份</span><span class="sxs-lookup"><span data-stu-id="c4f25-249">Restore Log Backups</span></span>  

 <span data-ttu-id="c4f25-250">还原日志备份将前滚事务日志中记录的更改，使数据库恢复到开始执行日志备份操作时的状态。</span><span class="sxs-lookup"><span data-stu-id="c4f25-250">Restoring a log backup rolls forward the changes that were recorded in the transaction log to re-create the exact state of the database at the time the log backup operation started.</span></span> <span data-ttu-id="c4f25-251">还原数据库时，必须还原在所还原完整数据库备份之后创建的日志备份，或者从您还原的第一个文件备份的开始处进行还原。</span><span class="sxs-lookup"><span data-stu-id="c4f25-251">When you restore a database, you will have to restore the log backups that were created after the full database backup that you restore, or from the start of the first file backup that you restore.</span></span> <span data-ttu-id="c4f25-252">通常情况下，在还原最新数据或差异备份后，必须还原一系列日志备份直到到达恢复点。</span><span class="sxs-lookup"><span data-stu-id="c4f25-252">Typically, after you restore the most recent data or differential backup, you must restore a series of log backups until you reach your recovery point.</span></span> <span data-ttu-id="c4f25-253">然后恢复数据库。</span><span class="sxs-lookup"><span data-stu-id="c4f25-253">Then, you recover the database.</span></span> <span data-ttu-id="c4f25-254">这将回滚所有在恢复开始时未完成的事务并使数据库联机。</span><span class="sxs-lookup"><span data-stu-id="c4f25-254">This rolls back all transactions that were incomplete when the recovery started and brings the database online.</span></span> <span data-ttu-id="c4f25-255">恢复数据库后，不得再还原任何备份。</span><span class="sxs-lookup"><span data-stu-id="c4f25-255">After the database has been recovered, you cannot restore any more backups.</span></span> <span data-ttu-id="c4f25-256">有关详细信息，请参阅[应用事务日志备份 (SQL Server)](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="c4f25-256">For more information, see [Apply Transaction Log Backups &#40;SQL Server&#41;](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md).</span></span>  
  
## <a name="additional-reading"></a><span data-ttu-id="c4f25-257">附加阅读材料</span><span class="sxs-lookup"><span data-stu-id="c4f25-257">Additional Reading</span></span>  

 <span data-ttu-id="c4f25-258">有关事务日志的其他信息，我们建议阅读以下文章和书籍。</span><span class="sxs-lookup"><span data-stu-id="c4f25-258">We recommend the following articles and books for additional information about the transaction log.</span></span>  
  
 [<span data-ttu-id="c4f25-259">了解 SQL Server 中的日志记录和恢复（作者：Paul Randall）</span><span class="sxs-lookup"><span data-stu-id="c4f25-259">Understanding Logging and Recovery in SQL Server by Paul Randall</span></span>](https://technet.microsoft.com/magazine/2009.02.logging.aspx)  
  
 [<span data-ttu-id="c4f25-260">SQL Server 事务日志管理（作者：Tony Davis 和 Gail Shaw）</span><span class="sxs-lookup"><span data-stu-id="c4f25-260">SQL Server Transaction Log Management by Tony Davis and Gail Shaw</span></span>](http://www.simple-talk.com/books/sql-books/sql-server-transaction-log-management-by-tony-davis-and-gail-shaw/)  
  
  
