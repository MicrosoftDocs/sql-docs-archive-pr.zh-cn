---
title: 表格模型中的字符串存储和排序规则 |Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
ms.assetid: 8516f0ad-32ee-4688-a304-e705143642ca
author: minewiskan
ms.author: owend
ms.openlocfilehash: 3aad4cf16c39897bc0796f4fb161eaf39abdb5fd
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87692552"
---
# <a name="string-storage-and-collation-in-tabular-models"></a>表格模型中的字符串存储和排序规则
  字符串（文本值）以高度压缩的格式存储于表格模型中；由于这一压缩，您在检索整个或部分字符串时可能会得到意外结果。 此外，因为字符串区域设置和排序规则在层次结构上继承自最接近的父对象，所以，如果未显式定义字符串语言，父对象的区域设置和排序规则可能会影响存储各字符串的方式以及字符串是唯一的还是与父排序规则定义的相似字符串合并。  
  
 本主题介绍压缩和存储字符串的机制，并且提供一些示例，阐释排序规则和语言是如何影响表格模型中文本公式的结果的。  
  
## <a name="storage"></a>存储  
 在表格模型中，所有数据都是高度压缩的，以便更好地容纳于内存中。 因此，可认为在词法上等效的所有字符串仅存储一次。 该字符串的第一个实例用作规范表示形式，此后的每个等效字符串都作为与第一个匹配项相同的压缩值进行索引。  
  
 关键问题是：何谓词法等效的字符串？ 如果两个字符串可被视为相同的单词，则认为它们在词法上是等效的。 例如，在英语中，当您在字典中搜索 **violin** 一词时，根据字典的编辑策略，可能会找到词条 **Violin** 或 **violin**；但通常您会认为这两个词条是等效的，并且忽略大小写中的差异。 在表格模型中，确定两个字符串在词法上是否等效的因素不是编辑策略或用户偏好，而是分配给列的区域设置和排序规则顺序。  
  
 因此，将大写和小写字母是作为相同字母还是不同字母处理的决定依赖于排序规则和区域设置。 因此，对于该区域设置内的任何特定单词，在某一特定列内找到的该单词的第一个匹配项将作为该单词的规范表示形式，并且该字符串以未压缩的格式存储。  所有其他字符串都将针对第一个匹配项进行测试，并且如果它们符合等效性测试，则向它们赋予第一个等效项的压缩值。 以后，在检索这些压缩值时，使用字符串的第一个匹配项的未压缩值表示这些压缩值。  
  
 我们将借助于一个示例来澄清此工作方式。 下面的列“Classification - English”是从一个表提取的，该表包含有关植物和树木的信息。 对于每种植物（植物的名称在此处不出现），分类列显示植物的一般类别。  
  
|Classification - English|  
|-------------------------------|  
|trEE|  
|PlAnT|  
|trEE|  
|PlAnT|  
|PlAnT|  
|树|  
|PlAnT|  
|trEE|  
|tree|  
|PlAnT|  
|trEE|  
  
 数据可能来自许多不同的源，因此，大小写和重音的使用是不一致的，并且关系数据库按原样存储了这些差异。 但通常而言，这些值依然是 **Plant** 或 **Tree**，只是大小写有差异。  
  
 在将这些值加载到使用默认排序规则和排序顺序 (的表格模型中时，美国) ，大小写并不重要，因此，对于整个列只存储两个值：  
  
|Classification - English|  
|-------------------------------|  
|trEE|  
|PlAnT|  
  
 如果在模型中使用 "**分类-英语**" 列，无论在何处显示植物分类，都将看到原始值，而不是使用其大小写的各种用法，只是第一个实例。 其原因在于， **tree** 的所有大小写变体在此排序规则和区域设置中都被视为等效的；因此，只保存了一个字符串，并且系统遇到的该字符串的第一个实例就是保存的字符串。  
  
> [!WARNING]  
>  您可以决定根据自己的判断，决定要定义哪一字符串将作为第一个存储的字符串，但可能很难这样做。 因为没有简单的方法可以事先确定引擎应该首先处理哪一行，所以假定所有值都被视为相同的。 如果您需要设置标准值，则应在加载模型前清除您的所有字符串。  
  
## <a name="locale-and-collation-order"></a>区域设置和排序规则顺序  
 在比较字符串（文本值）时，定义等效性的内容通常是有关如何解释此类字符串的区域性方面。 在某些区域性中，某个字符的重音或大小写可能会完全改变该字符串的含义；因此，在为任何特定语言或区域确定等效性时，通常会考虑此类差异。  
  
 通常，在使用您的计算机时，该计算机已配置为符合您自己的区域性期望和语言行为，并且文本值排序和比较之类的字符串运算在行为上符合预期。 控制特定于语言的行为的设置通过 Windows 中的“区域设置和区域”**** 设置定义。 应用程序将读取这些设置，并相应地更改其行为。 在某些情况下，应用程序具有的功能可以允许您更改应用程序的区域性行为或比较字符串的方式。  
  
 在您创建一个表格模型数据库时，默认情况下该数据库将以语言标识符和排序规则的形式继承这些区域性和语言设置。  
  
-   语言标识符定义您要根据区域性用于您的字符串的字符集。  
  
-   排序规则定义字符的顺序及其等效性。  
  
 特别要注意的是，语言标识符不仅标识语言，还标识使用该语言的国家或地区。 每个语言标识符还具有默认的排序规则规范。 有关语言标识符的详细信息，请参阅 [Microsoft 分配的区域设置 ID](https://msdn.microsoft.com/goglobal/bb964664.aspx)。 您可以使用 LCID Dec 列在手动插入值时获取正确的 ID。 有关排序规则的 SQL 概念的详细信息，请参阅 [COLLATE (Transact-SQL)](/sql/t-sql/statements/collations)。 有关针对 Windows 排序规则名称的排序规则指示符和比较样式的信息，请参阅 [Windows 排序规则名称 (Transact-SQL)](/sql/t-sql/statements/windows-collation-name-transact-sql)。 [SQL Server 排序规则名称 (Transact-SQL)](/sql/t-sql/statements/sql-server-collation-name-transact-sql) 主题介绍了如何将 Windows 排序规则名称映射到用于 SQL 的名称。  
  
 一旦创建了您的表格模型数据库后，该模型中的所有新对象都将从数据库属性继承语言和排序规则属性。 所有对象都是这样的。 继承路径将从该对象开始，查看父级中是否存在要继承的任何语言和排序规则属性，如果找不到，则继续向上查找到顶部，在数据库级别查找语言和排序规则属性。 换言之，如果您没有为某一对象指定语言和排序规则属性，则默认情况下，对象将继承其最接近的父级的属性。  
  
 对于列，将根据以下规则在创建时继承语言和排序规则属性：  
  
1.  搜索父维度对象以找到语言和排序规则属性。 如果这两个值存在，则将它们复制到列属性中；如果仅存在一个值，则从现有值推断另一个值并且分配这两个值；如果两个值都不存在，则转到下一步。  
  
2.  使用与针对维度的步骤 1 中所述相同的过程搜索数据库对象；如果找不到任何属性，则转到下一步。  
  
3.  使用与针对维度的步骤 1 中所述相同的过程搜索服务器对象；如果找不到任何属性，则该列将使用 Windows 语言标识符并且从该值推断排序规则属性。  
  
 特别要注意的是，源数据库中的语言标识符和排序规则顺序通常对在表格模型列中对值进行排序的方式的影响很小，甚至没有影响。 在源数据库转换或筛选请求的值时是例外情况。  
  
  
