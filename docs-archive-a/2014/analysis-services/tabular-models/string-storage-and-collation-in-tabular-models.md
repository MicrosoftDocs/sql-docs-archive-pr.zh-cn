---
title: 表格模型中的字符串存储和排序规则 |Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
ms.assetid: 8516f0ad-32ee-4688-a304-e705143642ca
author: minewiskan
ms.author: owend
ms.openlocfilehash: 3aad4cf16c39897bc0796f4fb161eaf39abdb5fd
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87692552"
---
# <a name="string-storage-and-collation-in-tabular-models"></a><span data-ttu-id="b218b-102">表格模型中的字符串存储和排序规则</span><span class="sxs-lookup"><span data-stu-id="b218b-102">String Storage and Collation in Tabular Models</span></span>
  <span data-ttu-id="b218b-103">字符串（文本值）以高度压缩的格式存储于表格模型中；由于这一压缩，您在检索整个或部分字符串时可能会得到意外结果。</span><span class="sxs-lookup"><span data-stu-id="b218b-103">Strings (text values) are stored in a highly compressed format in tabular models; because of this compression, you can get unexpected results when you retrieve entire or partial strings.</span></span> <span data-ttu-id="b218b-104">此外，因为字符串区域设置和排序规则在层次结构上继承自最接近的父对象，所以，如果未显式定义字符串语言，父对象的区域设置和排序规则可能会影响存储各字符串的方式以及字符串是唯一的还是与父排序规则定义的相似字符串合并。</span><span class="sxs-lookup"><span data-stu-id="b218b-104">Also, because string locale and collations are inherited hierarchically from the closest parent object, if the string language is not explicitly defined, the locale and collation of the parent can affect how each string is stored and whether the string is unique or conflated with similar strings as defined by the parent collation.</span></span>  
  
 <span data-ttu-id="b218b-105">本主题介绍压缩和存储字符串的机制，并且提供一些示例，阐释排序规则和语言是如何影响表格模型中文本公式的结果的。</span><span class="sxs-lookup"><span data-stu-id="b218b-105">This topic describes the mechanism by which strings are compressed and stored, and provides examples of how collation and language affect the results of text formulas in tabular models.</span></span>  
  
## <a name="storage"></a><span data-ttu-id="b218b-106">存储</span><span class="sxs-lookup"><span data-stu-id="b218b-106">Storage</span></span>  
 <span data-ttu-id="b218b-107">在表格模型中，所有数据都是高度压缩的，以便更好地容纳于内存中。</span><span class="sxs-lookup"><span data-stu-id="b218b-107">In tabular models all data is highly compressed to better fit in memory.</span></span> <span data-ttu-id="b218b-108">因此，可认为在词法上等效的所有字符串仅存储一次。</span><span class="sxs-lookup"><span data-stu-id="b218b-108">As a consequence, all strings that can be considered lexically equivalent are stored only once.</span></span> <span data-ttu-id="b218b-109">该字符串的第一个实例用作规范表示形式，此后的每个等效字符串都作为与第一个匹配项相同的压缩值进行索引。</span><span class="sxs-lookup"><span data-stu-id="b218b-109">The first instance of the string is used as the canonical representation and thereafter each equivalent string is indexed to the same compressed value as the first occurrence.</span></span>  
  
 <span data-ttu-id="b218b-110">关键问题是：何谓词法等效的字符串？</span><span class="sxs-lookup"><span data-stu-id="b218b-110">The key question is: what constitutes a lexically equivalent string?</span></span> <span data-ttu-id="b218b-111">如果两个字符串可被视为相同的单词，则认为它们在词法上是等效的。</span><span class="sxs-lookup"><span data-stu-id="b218b-111">Two strings are considered lexically equivalent if they can be considered as the same word.</span></span> <span data-ttu-id="b218b-112">例如，在英语中，当您在字典中搜索 **violin** 一词时，根据字典的编辑策略，可能会找到词条 **Violin** 或 **violin**；但通常您会认为这两个词条是等效的，并且忽略大小写中的差异。</span><span class="sxs-lookup"><span data-stu-id="b218b-112">For example, in English when you search for the word **violin** in a dictionary, you might find the entry **Violin** or **violin**, depending on the editorial policy of the dictionary, but generally you consider both words equivalent, and disregard the difference in capitalization.</span></span> <span data-ttu-id="b218b-113">在表格模型中，确定两个字符串在词法上是否等效的因素不是编辑策略或用户偏好，而是分配给列的区域设置和排序规则顺序。</span><span class="sxs-lookup"><span data-stu-id="b218b-113">In a tabular model, the factor that determines whether two strings are lexically equivalent is not editorial policy or even user preference, but the locale and collation order assigned to the column.</span></span>  
  
 <span data-ttu-id="b218b-114">因此，将大写和小写字母是作为相同字母还是不同字母处理的决定依赖于排序规则和区域设置。</span><span class="sxs-lookup"><span data-stu-id="b218b-114">Therefore, the decision of whether uppercase and lowercase letters should be handled as the same or different depends on the collation and locale.</span></span> <span data-ttu-id="b218b-115">因此，对于该区域设置内的任何特定单词，在某一特定列内找到的该单词的第一个匹配项将作为该单词的规范表示形式，并且该字符串以未压缩的格式存储。</span><span class="sxs-lookup"><span data-stu-id="b218b-115">For any particular word within that locale, the first occurrence of the word that is found within a particular column therefore serves as the canonical representation of that word and that string is stored in uncompressed format.</span></span>  <span data-ttu-id="b218b-116">所有其他字符串都将针对第一个匹配项进行测试，并且如果它们符合等效性测试，则向它们赋予第一个等效项的压缩值。</span><span class="sxs-lookup"><span data-stu-id="b218b-116">All other strings are tested against the first occurrence, and if they match the equivalence test, they are assigned to the compressed value of the first occurrence.</span></span> <span data-ttu-id="b218b-117">以后，在检索这些压缩值时，使用字符串的第一个匹配项的未压缩值表示这些压缩值。</span><span class="sxs-lookup"><span data-stu-id="b218b-117">Later, when the compressed values are retrieved they are represented using the uncompressed value of the first occurrence of the string.</span></span>  
  
 <span data-ttu-id="b218b-118">我们将借助于一个示例来澄清此工作方式。</span><span class="sxs-lookup"><span data-stu-id="b218b-118">An example will help to clarify how this works.</span></span> <span data-ttu-id="b218b-119">下面的列“Classification - English”是从一个表提取的，该表包含有关植物和树木的信息。</span><span class="sxs-lookup"><span data-stu-id="b218b-119">The following column "Classification - English" was extracted from a table that contains information about plants and trees.</span></span> <span data-ttu-id="b218b-120">对于每种植物（植物的名称在此处不出现），分类列显示植物的一般类别。</span><span class="sxs-lookup"><span data-stu-id="b218b-120">For each plant (the names of the plants are not shown here) the classification column shows the general category of plant.</span></span>  
  
|<span data-ttu-id="b218b-121">Classification - English</span><span class="sxs-lookup"><span data-stu-id="b218b-121">Classification - English</span></span>|  
|-------------------------------|  
|<span data-ttu-id="b218b-122">trEE</span><span class="sxs-lookup"><span data-stu-id="b218b-122">trEE</span></span>|  
|<span data-ttu-id="b218b-123">PlAnT</span><span class="sxs-lookup"><span data-stu-id="b218b-123">PlAnT</span></span>|  
|<span data-ttu-id="b218b-124">trEE</span><span class="sxs-lookup"><span data-stu-id="b218b-124">TREE</span></span>|  
|<span data-ttu-id="b218b-125">PlAnT</span><span class="sxs-lookup"><span data-stu-id="b218b-125">PLANT</span></span>|  
|<span data-ttu-id="b218b-126">PlAnT</span><span class="sxs-lookup"><span data-stu-id="b218b-126">Plant</span></span>|  
|<span data-ttu-id="b218b-127">树</span><span class="sxs-lookup"><span data-stu-id="b218b-127">Tree</span></span>|  
|<span data-ttu-id="b218b-128">PlAnT</span><span class="sxs-lookup"><span data-stu-id="b218b-128">plant</span></span>|  
|<span data-ttu-id="b218b-129">trEE</span><span class="sxs-lookup"><span data-stu-id="b218b-129">tReE</span></span>|  
|<span data-ttu-id="b218b-130">tree</span><span class="sxs-lookup"><span data-stu-id="b218b-130">tree</span></span>|  
|<span data-ttu-id="b218b-131">PlAnT</span><span class="sxs-lookup"><span data-stu-id="b218b-131">pLaNt</span></span>|  
|<span data-ttu-id="b218b-132">trEE</span><span class="sxs-lookup"><span data-stu-id="b218b-132">tREE</span></span>|  
  
 <span data-ttu-id="b218b-133">数据可能来自许多不同的源，因此，大小写和重音的使用是不一致的，并且关系数据库按原样存储了这些差异。</span><span class="sxs-lookup"><span data-stu-id="b218b-133">Perhaps the data came from many different sources, and so the casing and use of accents was inconsistent, and the relational database stored those differences as is.</span></span> <span data-ttu-id="b218b-134">但通常而言，这些值依然是 **Plant** 或 **Tree**，只是大小写有差异。</span><span class="sxs-lookup"><span data-stu-id="b218b-134">But in general the values are either **Plant** or **Tree**, just with different casing.</span></span>  
  
 <span data-ttu-id="b218b-135">在将这些值加载到使用默认排序规则和排序顺序 (的表格模型中时，美国) ，大小写并不重要，因此，对于整个列只存储两个值：</span><span class="sxs-lookup"><span data-stu-id="b218b-135">When these values are loaded into a tabular model that uses the default collation and sorting order for English (United States), case is not important, so only two values would be stored for the entire column:</span></span>  
  
|<span data-ttu-id="b218b-136">Classification - English</span><span class="sxs-lookup"><span data-stu-id="b218b-136">Classification - English</span></span>|  
|-------------------------------|  
|<span data-ttu-id="b218b-137">trEE</span><span class="sxs-lookup"><span data-stu-id="b218b-137">trEE</span></span>|  
|<span data-ttu-id="b218b-138">PlAnT</span><span class="sxs-lookup"><span data-stu-id="b218b-138">PlAnT</span></span>|  
  
 <span data-ttu-id="b218b-139">如果在模型中使用 "**分类-英语**" 列，无论在何处显示植物分类，都将看到原始值，而不是使用其大小写的各种用法，只是第一个实例。</span><span class="sxs-lookup"><span data-stu-id="b218b-139">If you use the column, **Classification - English**, in your model, wherever you display plant classification you will see not the original values, with their various uses of upper and lower case, but only the first instance.</span></span> <span data-ttu-id="b218b-140">其原因在于， **tree** 的所有大小写变体在此排序规则和区域设置中都被视为等效的；因此，只保存了一个字符串，并且系统遇到的该字符串的第一个实例就是保存的字符串。</span><span class="sxs-lookup"><span data-stu-id="b218b-140">The reason is that all the uppercase and lowercase variants of **tree** are considered equivalent in this collation and locale; therefore, only one string was preserved and the first instance of that string that is encountered by the system is the one that is saved.</span></span>  
  
> [!WARNING]  
>  <span data-ttu-id="b218b-141">您可以决定根据自己的判断，决定要定义哪一字符串将作为第一个存储的字符串，但可能很难这样做。</span><span class="sxs-lookup"><span data-stu-id="b218b-141">You might decide that you want to define which string will be the first to store, according to what you consider correct, but this could be very hard to so.</span></span> <span data-ttu-id="b218b-142">因为没有简单的方法可以事先确定引擎应该首先处理哪一行，所以假定所有值都被视为相同的。</span><span class="sxs-lookup"><span data-stu-id="b218b-142">There is no simple way to determine in advance which row should be processed first by the engine, given that all values are considered to be the same.</span></span> <span data-ttu-id="b218b-143">如果您需要设置标准值，则应在加载模型前清除您的所有字符串。</span><span class="sxs-lookup"><span data-stu-id="b218b-143">Instead, if you need to set the standard value, you should cleanse all your strings before loading the model.</span></span>  
  
## <a name="locale-and-collation-order"></a><span data-ttu-id="b218b-144">区域设置和排序规则顺序</span><span class="sxs-lookup"><span data-stu-id="b218b-144">Locale and Collation Order</span></span>  
 <span data-ttu-id="b218b-145">在比较字符串（文本值）时，定义等效性的内容通常是有关如何解释此类字符串的区域性方面。</span><span class="sxs-lookup"><span data-stu-id="b218b-145">When comparing strings (text values), what defines equivalence is normally the cultural aspect of how such strings are interpreted.</span></span> <span data-ttu-id="b218b-146">在某些区域性中，某个字符的重音或大小写可能会完全改变该字符串的含义；因此，在为任何特定语言或区域确定等效性时，通常会考虑此类差异。</span><span class="sxs-lookup"><span data-stu-id="b218b-146">In some cultures an accent or the capitalization of a character can completely change the meaning of the string; therefore, typically such differences are considered when determining equivalency for any particular language or region.</span></span>  
  
 <span data-ttu-id="b218b-147">通常，在使用您的计算机时，该计算机已配置为符合您自己的区域性期望和语言行为，并且文本值排序和比较之类的字符串运算在行为上符合预期。</span><span class="sxs-lookup"><span data-stu-id="b218b-147">Usually, when you use your computer it is already configured to match your own cultural expectations and linguistic behavior, and string operations such as sorting and comparing text values behaves as you would expect.</span></span> <span data-ttu-id="b218b-148">控制特定于语言的行为的设置通过 Windows 中的“区域设置和区域”\*\*\*\* 设置定义。</span><span class="sxs-lookup"><span data-stu-id="b218b-148">The settings that control language-specific behavior are defined through the **Locale and Regional** settings in Windows.</span></span> <span data-ttu-id="b218b-149">应用程序将读取这些设置，并相应地更改其行为。</span><span class="sxs-lookup"><span data-stu-id="b218b-149">Applications read those settings and change their behavior accordingly.</span></span> <span data-ttu-id="b218b-150">在某些情况下，应用程序具有的功能可以允许您更改应用程序的区域性行为或比较字符串的方式。</span><span class="sxs-lookup"><span data-stu-id="b218b-150">In some cases, an application might have a feature that allows you to change the cultural behavior of the application or the way in which strings are compared.</span></span>  
  
 <span data-ttu-id="b218b-151">在您创建一个表格模型数据库时，默认情况下该数据库将以语言标识符和排序规则的形式继承这些区域性和语言设置。</span><span class="sxs-lookup"><span data-stu-id="b218b-151">When you are creating a tabular model database, by default the database inherits these cultural and linguistic settings in the form of a language identifier and collation.</span></span>  
  
-   <span data-ttu-id="b218b-152">语言标识符定义您要根据区域性用于您的字符串的字符集。</span><span class="sxs-lookup"><span data-stu-id="b218b-152">The language identifier defines the character set you want to use for your strings according to your culture.</span></span>  
  
-   <span data-ttu-id="b218b-153">排序规则定义字符的顺序及其等效性。</span><span class="sxs-lookup"><span data-stu-id="b218b-153">The collation defines the ordering of the characters and their equivalence.</span></span>  
  
 <span data-ttu-id="b218b-154">特别要注意的是，语言标识符不仅标识语言，还标识使用该语言的国家或地区。</span><span class="sxs-lookup"><span data-stu-id="b218b-154">It is important to note that a language identifier not only identifies a language but, also the country or region where the language is used.</span></span> <span data-ttu-id="b218b-155">每个语言标识符还具有默认的排序规则规范。</span><span class="sxs-lookup"><span data-stu-id="b218b-155">Each language identifier also has a default collation specification.</span></span> <span data-ttu-id="b218b-156">有关语言标识符的详细信息，请参阅 [Microsoft 分配的区域设置 ID](https://msdn.microsoft.com/goglobal/bb964664.aspx)。</span><span class="sxs-lookup"><span data-stu-id="b218b-156">For more information about language identifiers, see [Locale IDs Assigned by Microsoft](https://msdn.microsoft.com/goglobal/bb964664.aspx).</span></span> <span data-ttu-id="b218b-157">您可以使用 LCID Dec 列在手动插入值时获取正确的 ID。</span><span class="sxs-lookup"><span data-stu-id="b218b-157">You can use the LCID Dec column to get the correct ID when manually inserting a value.</span></span> <span data-ttu-id="b218b-158">有关排序规则的 SQL 概念的详细信息，请参阅 [COLLATE (Transact-SQL)](/sql/t-sql/statements/collations)。</span><span class="sxs-lookup"><span data-stu-id="b218b-158">For more information about the SQL concept of collations, see [COLLATE &#40;Transact-SQL&#41;](/sql/t-sql/statements/collations).</span></span> <span data-ttu-id="b218b-159">有关针对 Windows 排序规则名称的排序规则指示符和比较样式的信息，请参阅 [Windows 排序规则名称 (Transact-SQL)](/sql/t-sql/statements/windows-collation-name-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="b218b-159">For information about the collation designators and the comparison styles for Windows collation names, see [Windows Collation Name &#40;Transact-SQL&#41;](/sql/t-sql/statements/windows-collation-name-transact-sql).</span></span> <span data-ttu-id="b218b-160">[SQL Server 排序规则名称 (Transact-SQL)](/sql/t-sql/statements/sql-server-collation-name-transact-sql) 主题介绍了如何将 Windows 排序规则名称映射到用于 SQL 的名称。</span><span class="sxs-lookup"><span data-stu-id="b218b-160">The topic, [SQL Server Collation Name &#40;Transact-SQL&#41;](/sql/t-sql/statements/sql-server-collation-name-transact-sql), maps the Windows collation names to the names used for SQL.</span></span>  
  
 <span data-ttu-id="b218b-161">一旦创建了您的表格模型数据库后，该模型中的所有新对象都将从数据库属性继承语言和排序规则属性。</span><span class="sxs-lookup"><span data-stu-id="b218b-161">Once your tabular model database has been created, all new objects in the model will inherit the language and collation attributes from the database attributes.</span></span> <span data-ttu-id="b218b-162">所有对象都是这样的。</span><span class="sxs-lookup"><span data-stu-id="b218b-162">This is true for all objects.</span></span> <span data-ttu-id="b218b-163">继承路径将从该对象开始，查看父级中是否存在要继承的任何语言和排序规则属性，如果找不到，则继续向上查找到顶部，在数据库级别查找语言和排序规则属性。</span><span class="sxs-lookup"><span data-stu-id="b218b-163">The inheritance path begins at the object, looks at the parent for any language and collation attributes to inherit, and if none are found, continues to the top and finds the language and collation attributes at the database level.</span></span> <span data-ttu-id="b218b-164">换言之，如果您没有为某一对象指定语言和排序规则属性，则默认情况下，对象将继承其最接近的父级的属性。</span><span class="sxs-lookup"><span data-stu-id="b218b-164">In other words, if you do not specify the language and collation attributes for an object, by default, the object inherits the attributes of its closest parent.</span></span>  
  
 <span data-ttu-id="b218b-165">对于列，将根据以下规则在创建时继承语言和排序规则属性：</span><span class="sxs-lookup"><span data-stu-id="b218b-165">For columns, the language and collation attributes are inherited at creation, according to the following rules:</span></span>  
  
1.  <span data-ttu-id="b218b-166">搜索父维度对象以找到语言和排序规则属性。</span><span class="sxs-lookup"><span data-stu-id="b218b-166">The parent dimension object is searched for language and collation attributes.</span></span> <span data-ttu-id="b218b-167">如果这两个值存在，则将它们复制到列属性中；如果仅存在一个值，则从现有值推断另一个值并且分配这两个值；如果两个值都不存在，则转到下一步。</span><span class="sxs-lookup"><span data-stu-id="b218b-167">If both values exist, they are copied to the column attributes; if only one exists, the other is inferred from the existing one and both are assigned; if none exist, move to next step.</span></span>  
  
2.  <span data-ttu-id="b218b-168">使用与针对维度的步骤 1 中所述相同的过程搜索数据库对象；如果找不到任何属性，则转到下一步。</span><span class="sxs-lookup"><span data-stu-id="b218b-168">The database object is searched using the same process described in Step 1 for dimensions; if no attributes are found, move to the next step.</span></span>  
  
3.  <span data-ttu-id="b218b-169">使用与针对维度的步骤 1 中所述相同的过程搜索服务器对象；如果找不到任何属性，则该列将使用 Windows 语言标识符并且从该值推断排序规则属性。</span><span class="sxs-lookup"><span data-stu-id="b218b-169">The server object is searched using the same process described in Step 1 for dimensions; if no attributes are found, the column uses the Windows language identifier and infers the collation attribute from that value.</span></span>  
  
 <span data-ttu-id="b218b-170">特别要注意的是，源数据库中的语言标识符和排序规则顺序通常对在表格模型列中对值进行排序的方式的影响很小，甚至没有影响。</span><span class="sxs-lookup"><span data-stu-id="b218b-170">It is important to note that typically the language identifier and collation order in the source database has little to no effect on how values are stored in the tabular model column.</span></span> <span data-ttu-id="b218b-171">在源数据库转换或筛选请求的值时是例外情况。</span><span class="sxs-lookup"><span data-stu-id="b218b-171">The exception is if the source database transforms or filters the requested values.</span></span>  
  
  
