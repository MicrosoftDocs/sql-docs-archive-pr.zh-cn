---
title: 嵌套表 (Analysis Services 数据挖掘) |Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
helpviewer_keywords:
- data mining [Analysis Services], nested tables
- tables [Analysis Services], nested
- nested tables
ms.assetid: cb192aa2-597e-4d4f-ac34-3556d037fed4
author: minewiskan
ms.author: owend
ms.openlocfilehash: 78b1022751ae6d381b86512f45f7232bebe7fcd0
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87687364"
---
# <a name="nested-tables-analysis-services---data-mining"></a><span data-ttu-id="41d2d-102">嵌套表（Analysis Services – 数据挖掘）</span><span class="sxs-lookup"><span data-stu-id="41d2d-102">Nested Tables (Analysis Services - Data Mining)</span></span>
  <span data-ttu-id="41d2d-103">在中 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] ，数据必须作为包含在事例表中的一系列事例送入到数据挖掘算法。</span><span class="sxs-lookup"><span data-stu-id="41d2d-103">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], data must be fed to a data mining algorithm as a series of cases that are contained within a case table.</span></span> <span data-ttu-id="41d2d-104">但并非所有的事例都可以用一行数据来说明。</span><span class="sxs-lookup"><span data-stu-id="41d2d-104">However, not all cases can be described by a single row of data.</span></span> <span data-ttu-id="41d2d-105">例如，一个事例可能派生自两个表：其中一个表包含客户信息，而另一个表包含客户采购信息。</span><span class="sxs-lookup"><span data-stu-id="41d2d-105">For example, a case might be derived from two tables: one table that contains customer information, and another table that contains customer purchases.</span></span> <span data-ttu-id="41d2d-106">客户信息表中的一位客户可能在客户采购表中有多个采购项目，在这种情况下，很难使用单个行来说明该数据。</span><span class="sxs-lookup"><span data-stu-id="41d2d-106">A single customer in the customer information table might have multiple items in the customer purchases table, which makes it difficult to describe the data by using a single row.</span></span> [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]<span data-ttu-id="41d2d-107">提供使用*嵌套表*处理这些事例的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="41d2d-107">provides a unique method for handling these cases, by using *nested tables*.</span></span> <span data-ttu-id="41d2d-108">下图将阐释嵌套表的概念。</span><span class="sxs-lookup"><span data-stu-id="41d2d-108">The concept of a nested table is demonstrated in the following illustration.</span></span>  
  
 <span data-ttu-id="41d2d-109">![使用嵌套表组合的两个表](../media/nested-tables.gif "使用嵌套表组合的两个表")</span><span class="sxs-lookup"><span data-stu-id="41d2d-109">![Two tables combined by using a nested table](../media/nested-tables.gif "Two tables combined by using a nested table")</span></span>  
  
 <span data-ttu-id="41d2d-110">在此关系图中，第一个表（父表）包含客户的信息，并且为每位客户关联了一个唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="41d2d-110">In this diagram, the first table, which is the parent table, contains information about customers, and associates a unique identifier for each customer.</span></span> <span data-ttu-id="41d2d-111">第二个表（子表）包含每位客户的采购信息。</span><span class="sxs-lookup"><span data-stu-id="41d2d-111">The second table, the child table, contains the purchases for each customer.</span></span> <span data-ttu-id="41d2d-112">子表中的采购信息又通过唯一标识符 **CustomerKey** 列与父表关联。</span><span class="sxs-lookup"><span data-stu-id="41d2d-112">The purchases in the child table are related to the parent table by the unique identifier, the **CustomerKey** column.</span></span> <span data-ttu-id="41d2d-113">关系图中的第三个表显示了这两个表的结合。</span><span class="sxs-lookup"><span data-stu-id="41d2d-113">The third table in the diagram shows the two tables combined.</span></span>  
  
 <span data-ttu-id="41d2d-114">嵌套表作为特殊列显示在事例表中，该列的数据类型为 **TABLE**。</span><span class="sxs-lookup"><span data-stu-id="41d2d-114">A nested table is represented in the case table as a special column that has a data type of **TABLE**.</span></span> <span data-ttu-id="41d2d-115">对于任何特定事例行，此列均包含从子表中选出的、与父表相关的行。</span><span class="sxs-lookup"><span data-stu-id="41d2d-115">For any particular case row, this kind of column contains selected rows from the child table that pertain to the parent table.</span></span>  
  
 <span data-ttu-id="41d2d-116">嵌套表中的数据可用于预测和/或输入。</span><span class="sxs-lookup"><span data-stu-id="41d2d-116">The data in a nested table can be used for prediction or for input, or for both.</span></span> <span data-ttu-id="41d2d-117">例如，一个模型中可能有两个嵌套表列：一个嵌套表列可能包含客户已购买的产品列表，而另一个嵌套表列则包含有关该客户的兴趣爱好的信息，这些信息可能从调查获得。</span><span class="sxs-lookup"><span data-stu-id="41d2d-117">For example, you might have two nested table columns in a model: one nested table column might contain a list of the products that a customer has purchased, while the other nested table column contains information about the customer's hobbies and interests, possibly obtained from a survey.</span></span> <span data-ttu-id="41d2d-118">在这种情况下，您可以使用客户的兴趣爱好作为输入，以分析购买行为并预测可能购买的产品。</span><span class="sxs-lookup"><span data-stu-id="41d2d-118">In this scenario, you could use the customer's hobbies and interests as an input for analyzing purchasing behavior, and predicting likely purchases.</span></span>  
  
## <a name="joining-case-tables-and-nested-tables"></a><span data-ttu-id="41d2d-119">连接事例表和嵌套表</span><span class="sxs-lookup"><span data-stu-id="41d2d-119">Joining Case Tables and Nested Tables</span></span>  
 <span data-ttu-id="41d2d-120">要创建嵌套表，两个源表必须包含已定义的关系，以便一个表中的项可与另一个表关联。</span><span class="sxs-lookup"><span data-stu-id="41d2d-120">In order to create a nested table, the two source tables must contain a defined relationship so that the items in one table can be related to the other table.</span></span> <span data-ttu-id="41d2d-121">在 [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]中，可以在数据源视图中定义此关系。</span><span class="sxs-lookup"><span data-stu-id="41d2d-121">In [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)], you can define this relationship in the data source view.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="41d2d-122">**CustomerKey** 字段为关系键，用于链接数据源视图定义中的事例表和嵌套表，以及建立挖掘结构中的列之间的关系。</span><span class="sxs-lookup"><span data-stu-id="41d2d-122">The **CustomerKey** field is the relational key that is used to link the case table and the nested table within the data source view definition, and to establish the relationship of the columns within the mining structure.</span></span> <span data-ttu-id="41d2d-123">但通常不应在根据此结构建立的挖掘模型中使用该关系键。</span><span class="sxs-lookup"><span data-stu-id="41d2d-123">However, typically you should not use this relational key in mining models built on that structure.</span></span> <span data-ttu-id="41d2d-124">一般情况下，如果关系键仅用于联接表而不提供对分析有用的信息，则最好省略挖掘模型的关系键列。</span><span class="sxs-lookup"><span data-stu-id="41d2d-124">Usually it is best to omit the relational key column from the mining model if it serves only to join the tables and does not provide information that is interesting for analysis.</span></span>  
  
 <span data-ttu-id="41d2d-125">您可以通过使用数据挖掘扩展插件 (DMX) 或分析管理对象 (AMO) 以编程方式创建嵌套表，也可以使用 [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]中的数据挖掘向导或数据挖掘设计器创建嵌套表。</span><span class="sxs-lookup"><span data-stu-id="41d2d-125">You can create nested tables programmatically by either using Data Mining Extensions (DMX) or Analysis Management Objects (AMO), or you can use the Data Mining Wizard and Data Mining Designer in [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)].</span></span>  
  
## <a name="using-nested-table-columns-in-a-mining-model"></a><span data-ttu-id="41d2d-126">在挖掘模型中使用嵌套表列</span><span class="sxs-lookup"><span data-stu-id="41d2d-126">Using Nested Table Columns in a Mining Model</span></span>  
 <span data-ttu-id="41d2d-127">在事例表中，键通常是客户 ID、产品名称或日期序列，是唯一标识表中行的数据。</span><span class="sxs-lookup"><span data-stu-id="41d2d-127">In the case table, the key is often a customer ID, a product name, or date in a series: data that uniquely identifies a row in the table.</span></span> <span data-ttu-id="41d2d-128">.</span><span class="sxs-lookup"><span data-stu-id="41d2d-128">.</span></span> <span data-ttu-id="41d2d-129">而在嵌套表中，键通常不是关系键（或外键），而是表示要对其进行建模的属性的列。</span><span class="sxs-lookup"><span data-stu-id="41d2d-129">However, in nested tables, the key is typically not the relational key (or foreign key) but rather the column that represents the attribute that you are modeling.</span></span>  
  
 <span data-ttu-id="41d2d-130">例如，如果事例表包含订单，嵌套表包含订单中的项目，则您会对以下工作感兴趣：为存储在嵌套表中的跨事例表中多个订单的项目之间的关系建模。</span><span class="sxs-lookup"><span data-stu-id="41d2d-130">For example, if the case table contains orders, and the nested table contains items in the order, you would be interested in modeling the relationship between items stored in the nested table across multiple orders, which are stored in the case table.</span></span> <span data-ttu-id="41d2d-131">因此，虽然 **Items** 嵌套表通过关系键 **OrderID** 联接到 **Orders**事例表，但是不应将 **OrderID** 用作嵌套表键，</span><span class="sxs-lookup"><span data-stu-id="41d2d-131">Therefore, although the **Items** nested table is joined to the **Orders** case table by the relational key **OrderID**, you should not use **OrderID** as the nested table key.</span></span> <span data-ttu-id="41d2d-132">而应选择 **Items** 列作为嵌套表键，因为该列包含要建模的数据。</span><span class="sxs-lookup"><span data-stu-id="41d2d-132">Instead, you would select the **Items** column as the nested table key, because that column contains the data that you want to model.</span></span> <span data-ttu-id="41d2d-133">大多数情况下，由于事例表和嵌套表之间的关系已通过数据源视图定义建立起来，因此可以安全地在挖掘模型中忽略 **OrderID** 。</span><span class="sxs-lookup"><span data-stu-id="41d2d-133">In most cases, you can safely ignore **OrderID** in the mining model, because the relationship between the case table and the nested table has already been established by the data source view definition.</span></span>  
  
 <span data-ttu-id="41d2d-134">如果选择将某列用作嵌套表键，必须确保该列中的值对每个事例都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="41d2d-134">When you choose a column to use as the nested table key, you must ensure that the values in that column are unique for each case.</span></span> <span data-ttu-id="41d2d-135">例如，如果事例表表示客户，嵌套表表示客户购买的项目，则必须确保每个项目对每个客户均只列出一次。</span><span class="sxs-lookup"><span data-stu-id="41d2d-135">For example, if the case table represents customers and the nested table represents items purchased by the customer, you must ensure that no item is listed more than one time per customer.</span></span> <span data-ttu-id="41d2d-136">如果某位客户多次购买了相同的项目，您可能希望创建另一个视图，该视图包含对每个唯一产品的购买次数进行合计的列。</span><span class="sxs-lookup"><span data-stu-id="41d2d-136">If a customer has purchased the same item more than one time, you might want to create a different view that has a column that aggregates the count of purchases for each unique product.</span></span>  
  
 <span data-ttu-id="41d2d-137">确定处理嵌套表中的重复值的方式取决于要创建的挖掘模型和要解决的业务问题。</span><span class="sxs-lookup"><span data-stu-id="41d2d-137">How you decide to handle duplicate values in a nested table depends on the mining model that you are creating and the business problem that you are solving.</span></span> <span data-ttu-id="41d2d-138">在某些情况下，您可能不关心客户购买某个特定产品的次数，而只想检查是否至少购买一次。</span><span class="sxs-lookup"><span data-stu-id="41d2d-138">In some scenarios you might not care how many times a customer has purchased a particular product, but want to check for the existence of at least one purchase.</span></span> <span data-ttu-id="41d2d-139">在其他情况下，购买的数量和顺序可能非常重要。</span><span class="sxs-lookup"><span data-stu-id="41d2d-139">In other scenarios, the quantity and sequence of purchases might be very important.</span></span>  
  
 <span data-ttu-id="41d2d-140">如果项目顺序很重要，可能还需要一列来表示顺序。</span><span class="sxs-lookup"><span data-stu-id="41d2d-140">If the order of items is important, you might need an additional column that indicates the sequence.</span></span> <span data-ttu-id="41d2d-141">\*\* 使用顺序分析和聚类分析算法来创建模型时，必须另外选择“Key Sequence”列来表示项目顺序。</span><span class="sxs-lookup"><span data-stu-id="41d2d-141">When you use the sequence clustering algorithm to create a model, you must choose an additional *key sequence* column to represent the order of the items.</span></span> <span data-ttu-id="41d2d-142">Key Sequence 列是一种仅在顺序分析和聚类分析模型中使用的特殊嵌套键，它需要唯一数字数据类型。</span><span class="sxs-lookup"><span data-stu-id="41d2d-142">The key sequence column is a special kind of nested key that is used only in sequence clustering models, and requires a unique numeric data type.</span></span> <span data-ttu-id="41d2d-143">例如，整数和日期均可用作 Key Sequence 列，但所有序列值必须是唯一的。</span><span class="sxs-lookup"><span data-stu-id="41d2d-143">For example, integers and dates can both be used as a key sequence column, but all sequence values must be unique.</span></span> <span data-ttu-id="41d2d-144">除 Key Sequence 列以外，顺序分析和聚类分析模型还具有表示要建模的属性的嵌套表键，例如已购买的产品。</span><span class="sxs-lookup"><span data-stu-id="41d2d-144">In addition to the key sequence column, a sequence clustering model also has a nested table key that represents the attribute that is being modeled, such as the products that have been purchased.</span></span>  
  
### <a name="using-non-key-nested-columns-from-a-nested-table"></a><span data-ttu-id="41d2d-145">使用嵌套表中的非键嵌套列</span><span class="sxs-lookup"><span data-stu-id="41d2d-145">Using Non-Key Nested Columns from a Nested Table</span></span>  
 <span data-ttu-id="41d2d-146">定义了事例表和嵌套表之间的联接且选择了用作嵌套表键的列（包含有用的唯一属性）之后，可以将嵌套表的其他列用作模型的输入内容。</span><span class="sxs-lookup"><span data-stu-id="41d2d-146">After you have defined the join between the case table and the nested table, and you have chosen a column that contains interesting and unique attributes to use as the nested table key, you can include other columns from the nested table to use as input to the model.</span></span> <span data-ttu-id="41d2d-147">嵌套表中的所有列均可用于输入、预测兼输入或仅用于预测。</span><span class="sxs-lookup"><span data-stu-id="41d2d-147">All columns from the nested table can be used for input, prediction and input, or for prediction only.</span></span>  
  
 <span data-ttu-id="41d2d-148">例如，如果嵌套表包含 **Product**、 **ProductQuantity**和 **ProductPrice**列，则可以选择 **Product** 作为嵌套表键，但可将 **ProductQuantity** 添加到挖掘结构中以用作输入内容。</span><span class="sxs-lookup"><span data-stu-id="41d2d-148">For example, if the nested table contains the columns **Product**, **ProductQuantity**, and **ProductPrice**, you might choose **Product** as the nested table key, but add **ProductQuantity** to the mining structure to use as input.</span></span>  
  
## <a name="filtering-nested-table-data"></a><span data-ttu-id="41d2d-149">筛选嵌套表数据</span><span class="sxs-lookup"><span data-stu-id="41d2d-149">Filtering Nested Table Data</span></span>  
 <span data-ttu-id="41d2d-150">在 [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]中，可以对用于定型或测试数据挖掘模型的数据创建筛选器。</span><span class="sxs-lookup"><span data-stu-id="41d2d-150">In [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)], you can create filters on the data that is used to train or test a data mining model.</span></span> <span data-ttu-id="41d2d-151">筛选器可用于影响模型的构成或用于针对事例子集测试模型。</span><span class="sxs-lookup"><span data-stu-id="41d2d-151">A filer can be used to affect the composition of the model, or to test the model on a subset of cases.</span></span> <span data-ttu-id="41d2d-152">筛选器还可应用于嵌套表。</span><span class="sxs-lookup"><span data-stu-id="41d2d-152">Filters can also be applied to nested tables.</span></span> <span data-ttu-id="41d2d-153">但对于可用于嵌套表的语法有一些限制。</span><span class="sxs-lookup"><span data-stu-id="41d2d-153">However, there are limitations on the syntax that can be used with nested tables.</span></span>  
  
 <span data-ttu-id="41d2d-154">而上述情况通常发生在将筛选器应用于要测试是否存在某个属性的嵌套表时。</span><span class="sxs-lookup"><span data-stu-id="41d2d-154">Often when you apply a filter to a nested table you are testing for the existence or nonexistence of an attribute.</span></span> <span data-ttu-id="41d2d-155">例如，可将限制模型中使用的事例的筛选器仅用于那些在嵌套表中具有指定值的事例。</span><span class="sxs-lookup"><span data-stu-id="41d2d-155">For example, you can apply a filter that restricts the cases used in the model to only those cases that have a specified value in the nested table.</span></span> <span data-ttu-id="41d2d-156">或者，可将模型中使用的事例限制为未购买某个特定项目的客户。</span><span class="sxs-lookup"><span data-stu-id="41d2d-156">Or, you could restrict the cases used in the model to customers who have not purchased a particular item.</span></span>  
  
 <span data-ttu-id="41d2d-157">在对嵌套表创建筛选器时，也可使用运算符，例如大于或小于号。</span><span class="sxs-lookup"><span data-stu-id="41d2d-157">When you create filters on a nested table, you can also use operators such as greater than or less than.</span></span> <span data-ttu-id="41d2d-158">例如，可将模型中使用的事例限制为已购买至少 n 个单位的目标产品的客户。</span><span class="sxs-lookup"><span data-stu-id="41d2d-158">For example, you could restrict the cases used in the model to customers who had purchased at least n units of the target product.</span></span> <span data-ttu-id="41d2d-159">对嵌套表属性进行筛选这项功能为自定义模型提供了极大的灵活性。</span><span class="sxs-lookup"><span data-stu-id="41d2d-159">The ability to filter on nested table attributes provides great flexibility for customizing models.</span></span>  
  
 <span data-ttu-id="41d2d-160">有关如何创建和使用模型筛选器的详细信息，请参阅[挖掘模型的筛选器（Analysis Services - 数据挖掘）](mining-models-analysis-services-data-mining.md)。</span><span class="sxs-lookup"><span data-stu-id="41d2d-160">For more information about how to create and use model filters, see [Filters for Mining Models &#40;Analysis Services - Data Mining&#41;](mining-models-analysis-services-data-mining.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="41d2d-161">另请参阅</span><span class="sxs-lookup"><span data-stu-id="41d2d-161">See Also</span></span>  
 <span data-ttu-id="41d2d-162">[数据挖掘算法 &#40;Analysis Services 数据挖掘&#41;](data-mining-algorithms-analysis-services-data-mining.md) </span><span class="sxs-lookup"><span data-stu-id="41d2d-162">[Data Mining Algorithms &#40;Analysis Services - Data Mining&#41;](data-mining-algorithms-analysis-services-data-mining.md) </span></span>  
 [<span data-ttu-id="41d2d-163">挖掘结构（Analysis Services - 数据挖掘）</span><span class="sxs-lookup"><span data-stu-id="41d2d-163">Mining Structures &#40;Analysis Services - Data Mining&#41;</span></span>](mining-structures-analysis-services-data-mining.md)  
  
  
