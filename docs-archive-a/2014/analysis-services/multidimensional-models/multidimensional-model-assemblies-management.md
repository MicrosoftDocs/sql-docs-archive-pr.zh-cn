---
title: 多维模型程序集管理 |Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
helpviewer_keywords:
- permissions [Analysis Services], assemblies
- calling user-defined functions
- user impersonation [Analysis Services]
- impersonation [Analysis Services]
- Data Mining Extensions [Analysis Services], assemblies
- MDX [Analysis Services], assemblies
- user-defined functions [Analysis Services]
- Analysis Services objects, assemblies
- assemblies [Analysis Services]
- application domains [Analysis Services]
ms.assetid: b2645d10-6d17-444e-9289-f111ec48bbfb
author: minewiskan
ms.author: owend
ms.openlocfilehash: b95a3171b3b194e84f10809f71eb72fefb07172b
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87687276"
---
# <a name="multidimensional-model-assemblies-management"></a><span data-ttu-id="44dc2-102">多维模型程序集管理</span><span class="sxs-lookup"><span data-stu-id="44dc2-102">Multidimensional Model Assemblies Management</span></span>
  [!INCLUDE[msCoName](../../includes/msconame-md.md)]<span data-ttu-id="44dc2-103">提供了很 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 多内部函数，这些函数用于 (MDX) 的多维表达式和数据挖掘扩展插件 (DMX) 语言，旨在完成从标准统计计算到层次结构中的成员的所有操作。</span><span class="sxs-lookup"><span data-stu-id="44dc2-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] supplies lots of intrinsic functions for use with the Multidimensional Expressions (MDX) and Data Mining Extensions (DMX) languages, designed to accomplish everything from standard statistical calculations to traversing members in a hierarchy.</span></span> <span data-ttu-id="44dc2-104">但是，任何复杂且健壮的产品都需要不断地扩展其功能，本产品也不例外。</span><span class="sxs-lookup"><span data-stu-id="44dc2-104">But, as with any other complex and robust product, there is always the need to extend the functionality of such a product further.</span></span>  
  
 <span data-ttu-id="44dc2-105">因此，通过 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] ，您可以将程序集添加到 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 实例或数据库。</span><span class="sxs-lookup"><span data-stu-id="44dc2-105">Therefore, [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] lets you add assemblies to an [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] instance or database.</span></span> <span data-ttu-id="44dc2-106">使用程序集，您可以使用任何公共语言运行时 (CLR) 语言（如 Microsoft Visual Basic .NET 或 Microsoft Visual C#）来创建用户定义的外部函数。</span><span class="sxs-lookup"><span data-stu-id="44dc2-106">Assemblies let you create external, user-defined functions using any common language runtime (CLR) language, such as Microsoft Visual Basic .NET or Microsoft Visual C#.</span></span> <span data-ttu-id="44dc2-107">还可以使用组件对象模型 (COM) 自动化语言，如 Microsoft Visual Basic 或 Microsoft Visual C++。</span><span class="sxs-lookup"><span data-stu-id="44dc2-107">You can also use Component Object Model (COM) Automation languages such as Microsoft Visual Basic or Microsoft Visual C++.</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="44dc2-108">COM 程序集可能会造成安全风险。</span><span class="sxs-lookup"><span data-stu-id="44dc2-108">COM assemblies might pose a security risk.</span></span> <span data-ttu-id="44dc2-109">由于此风险和其他注意事项， [!INCLUDE[ssASversion10](../../includes/ssasversion10-md.md)]中不推荐使用 COM 程序集。</span><span class="sxs-lookup"><span data-stu-id="44dc2-109">Due to this risk and other considerations, COM assemblies were deprecated in [!INCLUDE[ssASversion10](../../includes/ssasversion10-md.md)].</span></span> <span data-ttu-id="44dc2-110">未来版本可能不支持 COM 程序集。</span><span class="sxs-lookup"><span data-stu-id="44dc2-110">COM assemblies might not be supported in future releases.</span></span>  
  
 <span data-ttu-id="44dc2-111">使用程序集可以扩展 MDX 和 DMX 的业务功能。</span><span class="sxs-lookup"><span data-stu-id="44dc2-111">Assemblies let you extend the business functionality of MDX and DMX.</span></span> <span data-ttu-id="44dc2-112">应当在诸如动态链接库 (DLL) 这样的库中构建所需的功能，然后将库作为程序集添加到 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 实例或 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 数据库。</span><span class="sxs-lookup"><span data-stu-id="44dc2-112">You build the functionality that you want into a library, such as a dynamic link library (DLL) and add the library as an assembly to an instance of [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] or to an [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] database.</span></span> <span data-ttu-id="44dc2-113">然后，库中的公共方法对 MDX 和 DMX 表达式、过程、计算、操作和客户端应用程序显示为用户定义函数。</span><span class="sxs-lookup"><span data-stu-id="44dc2-113">The public methods in the library are then exposed as user-defined functions to MDX and DMX expressions, procedures, calculations, actions, and client applications.</span></span>  
  
 <span data-ttu-id="44dc2-114">可向服务器添加具有新过程和新功能的程序集。</span><span class="sxs-lookup"><span data-stu-id="44dc2-114">An assembly with new procedures and functions can be added to the server.</span></span> <span data-ttu-id="44dc2-115">您可以使用程序集增强或添加服务器未提供的自定义功能。</span><span class="sxs-lookup"><span data-stu-id="44dc2-115">You can use assemblies to enhance or add custom functionality that is not provided by the server.</span></span> <span data-ttu-id="44dc2-116">您还可以通过使用程序集，向多维表达式 (MDX)、数据挖掘扩展 (DMX) 或存储过程添加新功能。</span><span class="sxs-lookup"><span data-stu-id="44dc2-116">By using assemblies, you can add new functions to Multidimensional Expressions (MDX), Data Mining Extensions (DMX), or stored procedures.</span></span> <span data-ttu-id="44dc2-117">可从运行自定义应用程序处加载程序集，并且程序集二进制文件的副本将和数据库数据一起保存到服务器中。</span><span class="sxs-lookup"><span data-stu-id="44dc2-117">Assemblies are loaded from the location where the custom application is run, and a copy of the assembly binary file is saved along with the database data in the server.</span></span> <span data-ttu-id="44dc2-118">删除程序集时，程序集副本也会从服务器中删除。</span><span class="sxs-lookup"><span data-stu-id="44dc2-118">When an assembly is removed, the copied assembly is also removed from the server.</span></span>  
  
 <span data-ttu-id="44dc2-119">程序集可为两种不同的类型：COM 和 CLR。</span><span class="sxs-lookup"><span data-stu-id="44dc2-119">Assemblies can be of two different types: COM and CLR.</span></span> <span data-ttu-id="44dc2-120">CLR 程序集是使用 .NET Framework 编程语言（如 C#、Visual Basic .NET 和托管 C++）开发的程序集。</span><span class="sxs-lookup"><span data-stu-id="44dc2-120">CLR assemblies are assemblies developed in .NET Framework programming languages such as C#, Visual Basic .NET, managed C++.</span></span> <span data-ttu-id="44dc2-121">COM 程序集是必须在服务器中注册的 COM 库。</span><span class="sxs-lookup"><span data-stu-id="44dc2-121">COM assemblies are COM libraries that must be registered in the server</span></span>  
  
 <span data-ttu-id="44dc2-122">可以将程序集添加到 <xref:Microsoft.AnalysisServices.Server> 或 <xref:Microsoft.AnalysisServices.Database> 对象。</span><span class="sxs-lookup"><span data-stu-id="44dc2-122">Assemblies can be added to <xref:Microsoft.AnalysisServices.Server> or <xref:Microsoft.AnalysisServices.Database> objects.</span></span> <span data-ttu-id="44dc2-123">连接到服务器的任何用户或服务器中任何对象均可以调用服务器程序集。</span><span class="sxs-lookup"><span data-stu-id="44dc2-123">Server assemblies can be called by any user connected to the server or any object in the server.</span></span> <span data-ttu-id="44dc2-124">但数据库程序集却只能由连接到 <xref:Microsoft.AnalysisServices.Database> 的数据库对象或用户调用。</span><span class="sxs-lookup"><span data-stu-id="44dc2-124">Database assemblies can be called only by <xref:Microsoft.AnalysisServices.Database> objects or users connected to the database.</span></span>  
  
 <span data-ttu-id="44dc2-125">简单 <xref:Microsoft.AnalysisServices.Assembly> 对象由基本信息（名称和 ID）、文件集合和安全规范组成。</span><span class="sxs-lookup"><span data-stu-id="44dc2-125">A simple <xref:Microsoft.AnalysisServices.Assembly> object is composed of basic information (Name and Id), file collection, and security specifications.</span></span>  
  
 <span data-ttu-id="44dc2-126">如果调试文件是和程序集文件一起加载的，则文件集合指已加载程序集文件及其相应调试文件 (.pdb)。</span><span class="sxs-lookup"><span data-stu-id="44dc2-126">The file collection refers to the loaded assembly files and their corresponding debugging (.pdb) files, if the debugging files were loaded with the assembly files.</span></span> <span data-ttu-id="44dc2-127">程序集文件可从应用程序定义该文件处进行加载，并且其副本将和数据一起保存到服务器中。</span><span class="sxs-lookup"><span data-stu-id="44dc2-127">Assembly files are loaded from the location where the application defined the files to, and a copy is saved in the server along with the data.</span></span> <span data-ttu-id="44dc2-128">程序集文件的副本可用于在每次启动服务时加载程序集。</span><span class="sxs-lookup"><span data-stu-id="44dc2-128">The copy of the assembly file is used to load the assembly every time the service is started.</span></span>  
  
 <span data-ttu-id="44dc2-129">安全规范包括用于运行程序集的权限集和模拟。</span><span class="sxs-lookup"><span data-stu-id="44dc2-129">Security specifications include the permission set and the impersonation used to run the assembly.</span></span>  
  
## <a name="calling-user-defined-functions"></a><span data-ttu-id="44dc2-130">调用用户定义函数</span><span class="sxs-lookup"><span data-stu-id="44dc2-130">Calling User-Defined Functions</span></span>  
 <span data-ttu-id="44dc2-131">调用程序集中用户定义函数的过程就像调用内部函数一样，但必须使用完全限定名称。</span><span class="sxs-lookup"><span data-stu-id="44dc2-131">Calling a user-defined function in an assembly is performed just like calling an intrinsic function, except that you must use a fully qualified name.</span></span> <span data-ttu-id="44dc2-132">例如，MDX 查询中包含一个返回 MDX 所需类型的用户定义函数，如下例所示：</span><span class="sxs-lookup"><span data-stu-id="44dc2-132">For example, a user-defined function that returns a type expected by MDX is included in an MDX query, as shown in the following example:</span></span>  
  
```  
Select MyAssembly.MyClass.MyStoredProcedure(a, b, c) on 0 from Sales  
```  
  
 <span data-ttu-id="44dc2-133">用户定义函数也可以使用 CALL 关键字调用。</span><span class="sxs-lookup"><span data-stu-id="44dc2-133">User-defined functions can also be called using the CALL keyword.</span></span> <span data-ttu-id="44dc2-134">必须对返回记录集或 void 值的用户定义函数使用 CALL 关键字，并且如果用户定义函数依赖于 MDX 或 DMX 语句或脚本（如当前多维数据集或数据挖掘模型）上下文中的对象，则不能使用 CALL 关键字。</span><span class="sxs-lookup"><span data-stu-id="44dc2-134">You must use the CALL keyword for user-defined functions which return recordsets or void values, and you cannot use the CALL keyword if the user-defined function depends on an object in the context of the MDX or DMX statement or script, such as the current cube or data mining model.</span></span> <span data-ttu-id="44dc2-135">在 MDX 或 DMX 查询之外调用函数的通常做法是使用 AMO 对象模型执行管理功能。</span><span class="sxs-lookup"><span data-stu-id="44dc2-135">A common use for a function called outside an MDX or DMX query is to use the AMO object model to perform administrative functions.</span></span> <span data-ttu-id="44dc2-136">例如，如果想要在 MDX 语句中使用 `MyVoidProcedure(a, b, c)` 函数，可采用下面的语法：</span><span class="sxs-lookup"><span data-stu-id="44dc2-136">If, for example, you wanted to use the function `MyVoidProcedure(a, b, c)` in an MDX statement, the following syntax would be employed:</span></span>  
  
```  
Call MyAssembly.MyClass.MyVoidProcedure(a, b, c)  
```  
  
 <span data-ttu-id="44dc2-137">程序集通过一次性地开发通用代码并将其存储在某个位置，使数据库开发过程得到了简化。</span><span class="sxs-lookup"><span data-stu-id="44dc2-137">Assemblies simplify database development by enabling common code to be developed once and stored in a single location.</span></span> <span data-ttu-id="44dc2-138">客户端软件开发人员可以创建 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 的函数库，并通过其应用程序对这些库进行分发。</span><span class="sxs-lookup"><span data-stu-id="44dc2-138">Client software developers can create libraries of functions for [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] and distribute them with their applications.</span></span>  
  
 <span data-ttu-id="44dc2-139">程序集和用户定义函数可以复制 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 函数库或其他程序集的函数名称。</span><span class="sxs-lookup"><span data-stu-id="44dc2-139">Assemblies and user-defined functions can duplicate the function names of the [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] function library or of other assemblies.</span></span> <span data-ttu-id="44dc2-140">只要用完全限定名称调用用户定义函数， [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 就会使用正确的步骤。</span><span class="sxs-lookup"><span data-stu-id="44dc2-140">As long as you call the user-defined function by using its fully qualified name, [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] will use the correct procedure.</span></span> <span data-ttu-id="44dc2-141">出于安全目的，并为了防止调用不同类库中的重复名称， [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 要求对存储过程仅使用完全限定名称。</span><span class="sxs-lookup"><span data-stu-id="44dc2-141">For security purposes, and to eliminate the chance of calling a duplicate name in a different class library, [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] requires that you use only fully qualified names for stored procedures.</span></span>  
  
 <span data-ttu-id="44dc2-142">若要从特定 CLR 程序集调用用户定义函数，用户定义函数前面必须有程序集名称、完整类名称和过程名称，如下所示：</span><span class="sxs-lookup"><span data-stu-id="44dc2-142">To call a user-defined function from a specific CLR assembly, the user-defined function is preceded by the assembly name, full class name, and procedure name, as demonstrated here:</span></span>  
  
 <span data-ttu-id="44dc2-143">*AssemblyName*。*FullClassName*。*ProcedureName* (*Argument1*， *Argument2*，... ) </span><span class="sxs-lookup"><span data-stu-id="44dc2-143">*AssemblyName*.*FullClassName*.*ProcedureName*(*Argument1*, *Argument2*, ...)</span></span>  
  
 <span data-ttu-id="44dc2-144">为了保持对 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]早期版本的向后兼容，下面的语法也可以接受：</span><span class="sxs-lookup"><span data-stu-id="44dc2-144">For backward compatibility with earlier versions of [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], the following syntax is also acceptable:</span></span>  
  
 <span data-ttu-id="44dc2-145">*AssemblyName*!*FullClassName*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span><span class="sxs-lookup"><span data-stu-id="44dc2-145">*AssemblyName*!*FullClassName*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span></span>  
  
 <span data-ttu-id="44dc2-146">如果 COM 库支持多个接口，则接口 ID 还可用于解析过程名称，如下所示：</span><span class="sxs-lookup"><span data-stu-id="44dc2-146">If a COM library supports multiple interfaces, the interface ID can also be used to resolve the procedure name, as demonstrated here:</span></span>  
  
 <span data-ttu-id="44dc2-147">*AssemblyName*!*InterfaceID*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span><span class="sxs-lookup"><span data-stu-id="44dc2-147">*AssemblyName*!*InterfaceID*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span></span>  
  
## <a name="security"></a><span data-ttu-id="44dc2-148">安全性</span><span class="sxs-lookup"><span data-stu-id="44dc2-148">Security</span></span>  
 <span data-ttu-id="44dc2-149">程序集的安全性基于 .NET Framework 安全模式，这是一个代码访问安全模式。</span><span class="sxs-lookup"><span data-stu-id="44dc2-149">Security for assemblies is based on the .NET Framework security model, which is a code-access security model.</span></span> <span data-ttu-id="44dc2-150">.NET Framework 支持代码访问安全机制，此机制假设：运行时可承载完全可信和部分可信的代码。</span><span class="sxs-lookup"><span data-stu-id="44dc2-150">.NET Framework supports a code-access security mechanism that assumes that the runtime can host both fully trusted and partially trusted code.</span></span> <span data-ttu-id="44dc2-151">.NET Framework 代码访问安全性所保护的资源通常由要求具有相应权限才能访问资源的托管代码所包装。</span><span class="sxs-lookup"><span data-stu-id="44dc2-151">The resources that are protected by .NET Framework code access security are typically wrapped by managed code which demands the corresponding permission before enabling access to the resource.</span></span> <span data-ttu-id="44dc2-152">仅当调用堆栈中的所有调用方（在程序集层）均具有相应资源权限时，此权限要求才得到满足。</span><span class="sxs-lookup"><span data-stu-id="44dc2-152">The demand for the permission is satisfied only if all the callers (at the assembly level) in the call stack have the corresponding resource permission.</span></span>  
  
 <span data-ttu-id="44dc2-153">对于程序集，执行权限随 `PermissionSet` 对象的 `Assembly` 属性传递。</span><span class="sxs-lookup"><span data-stu-id="44dc2-153">For assemblies, permission for execution is passed with the `PermissionSet` property on the `Assembly` object.</span></span> <span data-ttu-id="44dc2-154">托管代码接收的权限由有效的安全策略确定。</span><span class="sxs-lookup"><span data-stu-id="44dc2-154">The permissions that managed code receives are determined by the security policy in effect.</span></span> <span data-ttu-id="44dc2-155">非[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 宿主环境中已有三个有效的策略级别：企业、计算机和用户。</span><span class="sxs-lookup"><span data-stu-id="44dc2-155">There are already three levels of policy in effect in a non-[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] hosted environment: enterprise, computer and user.</span></span> <span data-ttu-id="44dc2-156">代码接收的有效权限列表由这三个级别获得的权限交集所确定。</span><span class="sxs-lookup"><span data-stu-id="44dc2-156">The effective list of permissions that code receives is determined by the intersection of the permissions obtained by these three levels.</span></span>  
  
 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] <span data-ttu-id="44dc2-157">如果是 CLR 的宿主，它将为其提供宿主级别的安全策略级别，此策略是低于始终有效的三个策略级别的附加策略级别。</span><span class="sxs-lookup"><span data-stu-id="44dc2-157">supplies a host-level security policy level to the CLR while hosting it; this policy is an additional policy level below the three policy levels that are always in effect.</span></span> <span data-ttu-id="44dc2-158">会为 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]创建的每个应用程序域设置此策略。</span><span class="sxs-lookup"><span data-stu-id="44dc2-158">This policy is set for every application domain that is created by [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="44dc2-159">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 宿主级别策略组合了用于系统程序集的 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 固定策略和用于用户程序集的用户指定策略。</span><span class="sxs-lookup"><span data-stu-id="44dc2-159">The [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] host-level policy is a combination of [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] fixed policy for system assemblies and user-specified policy for user assemblies.</span></span> <span data-ttu-id="44dc2-160">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 宿主策略的用户指定部分基于程序集所有者，此所有者将为每个程序集指定三个权限存储桶中的一个：</span><span class="sxs-lookup"><span data-stu-id="44dc2-160">The user-specified piece of the [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] host policy is based on the assembly owner specifying one of three permission buckets for each assembly:</span></span>  
  
|<span data-ttu-id="44dc2-161">权限设置</span><span class="sxs-lookup"><span data-stu-id="44dc2-161">Permission Setting</span></span>|<span data-ttu-id="44dc2-162">说明</span><span class="sxs-lookup"><span data-stu-id="44dc2-162">Description</span></span>|  
|------------------------|-----------------|  
|`Safe`|<span data-ttu-id="44dc2-163">提供内部计算权限。</span><span class="sxs-lookup"><span data-stu-id="44dc2-163">Provides internal computation permission.</span></span> <span data-ttu-id="44dc2-164">此权限存储桶不分配访问 .NET Framework 中任何受保护资源的权限。</span><span class="sxs-lookup"><span data-stu-id="44dc2-164">This permission bucket does not assign permissions to access any of the protected resources in the .NET Framework.</span></span> <span data-ttu-id="44dc2-165">如果没有对 `PermissionSet` 属性指定任何权限存储桶，则这是程序集的默认权限存储桶。</span><span class="sxs-lookup"><span data-stu-id="44dc2-165">This is the default permission bucket for an assembly if none is specified with the `PermissionSet` property.</span></span>|  
|`ExternalAccess`|<span data-ttu-id="44dc2-166">提供和 `Safe` 设置相同的访问权限，以及访问外部系统资源的附加功能。</span><span class="sxs-lookup"><span data-stu-id="44dc2-166">Provides the same access as the `Safe` setting, with the additional ability to access external system resources.</span></span> <span data-ttu-id="44dc2-167">此权限存储桶无法保证安全性（尽管有可能保证这种情况的安全），但可以保证可靠性。</span><span class="sxs-lookup"><span data-stu-id="44dc2-167">This permission bucket does not offer security guarantees (although it is possible to secure this scenario), but it does give reliability guarantees.</span></span>|  
|`Unsafe`|<span data-ttu-id="44dc2-168">无限制。</span><span class="sxs-lookup"><span data-stu-id="44dc2-168">Provides no restrictions.</span></span> <span data-ttu-id="44dc2-169">对运行于此权限集下的托管代码无法提供安全性或可靠性保证。</span><span class="sxs-lookup"><span data-stu-id="44dc2-169">No security or reliability guarantees can be made for managed code running under this permission set.</span></span> <span data-ttu-id="44dc2-170">任何权限，甚至管理员提供的自定义权限都将授予在此信任级别运行的代码。</span><span class="sxs-lookup"><span data-stu-id="44dc2-170">Any permission, even a custom permission included by the administrator, is granted to code running at this level of trust.</span></span>|  
  
 <span data-ttu-id="44dc2-171">当 CLR 由 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]承载时，基于堆栈审核的权限检查在本机 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 代码的边界停止。</span><span class="sxs-lookup"><span data-stu-id="44dc2-171">When CLR is hosted by [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], the stack-walk based permission check stops at the boundary with native [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] code.</span></span> <span data-ttu-id="44dc2-172">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 程序集中的任何托管代码始终属于前面列出的三种权限类别中的一种。</span><span class="sxs-lookup"><span data-stu-id="44dc2-172">Any managed code in [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] assemblies always falls into one of the three permission categories listed earlier.</span></span>  
  
 <span data-ttu-id="44dc2-173">COM（或非托管）程序集例程不支持 CLR 安全模式。</span><span class="sxs-lookup"><span data-stu-id="44dc2-173">COM (or unmanaged) assembly routines do not support the CLR security model.</span></span>  
  
### <a name="impersonation"></a><span data-ttu-id="44dc2-174">模拟</span><span class="sxs-lookup"><span data-stu-id="44dc2-174">Impersonation</span></span>  
 <span data-ttu-id="44dc2-175">无论托管代码何时访问 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 外的任何资源，[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 都将遵守与程序集的 `ImpersonationMode` 属性设置相关的规则，以确保访问在适当的 Windows 安全性上下文中进行。</span><span class="sxs-lookup"><span data-stu-id="44dc2-175">Whenever managed code accesses any resource outside [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] follows the rules associated with the `ImpersonationMode` property setting of the assembly to make sure that the access occurs in an appropriate Windows security context.</span></span> <span data-ttu-id="44dc2-176">由于使用 `Safe` 权限设置的程序集不能访问 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 外的资源，所以这些规则仅适用于使用 `ExternalAccess` 和 `Unsafe` 权限设置的程序集。</span><span class="sxs-lookup"><span data-stu-id="44dc2-176">Because assemblies using the `Safe` permission setting cannot access resources outside [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], these rules are applicable only for assemblies using the `ExternalAccess` and `Unsafe` permission settings.</span></span>  
  
-   <span data-ttu-id="44dc2-177">如果当前执行的上下文对应于通过 Windows 身份验证的登录，并且和原始调用方的上下文相同（即中间没有 EXECUTE AS），则 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 将在访问资源之前模拟通过 Windows 身份验证的登录。</span><span class="sxs-lookup"><span data-stu-id="44dc2-177">If the current execution context corresponds to Windows Authenticated login and is the same as the context of the original caller (that is, there is no EXECUTE AS in the middle), [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] will impersonate the Windows Authenticated login before accessing the resource.</span></span>  
  
-   <span data-ttu-id="44dc2-178">如果某个中间 EXECUTE AS 更改了执行上下文，使之不再是原始调用方的上下文，则访问外部资源的尝试将失败。</span><span class="sxs-lookup"><span data-stu-id="44dc2-178">If there is an intermediate EXECUTE AS that changed the context from that of the original caller), the attempt to access external resource will fail.</span></span>  
  
 <span data-ttu-id="44dc2-179">`ImpersonationMode` 属性可设置为 `ImpersonateCurrentUser` 或 `ImpersonateAnonymous`。</span><span class="sxs-lookup"><span data-stu-id="44dc2-179">The `ImpersonationMode` property can be set to `ImpersonateCurrentUser` or `ImpersonateAnonymous`.</span></span> <span data-ttu-id="44dc2-180">默认设置 `ImpersonateCurrentUser` 在当前用户的网络登录帐户下运行程序集。</span><span class="sxs-lookup"><span data-stu-id="44dc2-180">The default setting, `ImpersonateCurrentUser`, runs an assembly under the current user's network login account.</span></span> <span data-ttu-id="44dc2-181">如果 `ImpersonateAnonymous` 使用设置，则执行上下文对应于服务器上 IUSER_*Servername*的 Windows 登录用户帐户。</span><span class="sxs-lookup"><span data-stu-id="44dc2-181">If the `ImpersonateAnonymous` setting is used, the execution context is corresponds to the Windows login user account IUSER_*servername* on the server.</span></span> <span data-ttu-id="44dc2-182">这是 Internet guest 帐户，在服务器上只有有限的权限。</span><span class="sxs-lookup"><span data-stu-id="44dc2-182">This is the Internet guest account, which has limited privileges on the server.</span></span> <span data-ttu-id="44dc2-183">在此上下文中运行的程序集只能访问本地服务器上的有限资源。</span><span class="sxs-lookup"><span data-stu-id="44dc2-183">An assembly running in this context can only access limited resources on the local server.</span></span>  
  
### <a name="application-domains"></a><span data-ttu-id="44dc2-184">应用程序域</span><span class="sxs-lookup"><span data-stu-id="44dc2-184">Application Domains</span></span>  
 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] <span data-ttu-id="44dc2-185">不直接显示应用程序域。</span><span class="sxs-lookup"><span data-stu-id="44dc2-185">does not expose application domains directly.</span></span> <span data-ttu-id="44dc2-186">由于一组程序集运行于同一个应用程序域中，因此应用程序域可以在执行期间使用 .NET Framework 中的 `System.Reflection` 命名空间或以其他方式发现彼此，并且可以用后期绑定的方式调用这些程序集。</span><span class="sxs-lookup"><span data-stu-id="44dc2-186">Because of a set of assemblies running in the same application domain, application domains can discover each other at execution time by using the `System.Reflection` namespace in the .NET Framework or in some other way, and can call into them in late-bound manner.</span></span> <span data-ttu-id="44dc2-187">此类调用将受到基于 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 授权的安全性所使用的权限检查的约束。</span><span class="sxs-lookup"><span data-stu-id="44dc2-187">Such calls will be subject to the permission checks used by [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] authorization-based security.</span></span>  
  
 <span data-ttu-id="44dc2-188">不应依赖于在同一应用程序域中查找程序集，因为应用程序域边界和每个域中的程序集都是由此实现而定义的。</span><span class="sxs-lookup"><span data-stu-id="44dc2-188">You should not rely on finding assemblies in the same application domain, because the application domain boundary and the assemblies that go into each domain are defined by the implementation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="44dc2-189">另请参阅</span><span class="sxs-lookup"><span data-stu-id="44dc2-189">See Also</span></span>  
 <span data-ttu-id="44dc2-190">[设置存储过程的安全性](../multidimensional-models-extending-olap-stored-procedures/setting-security-for-stored-procedures.md) </span><span class="sxs-lookup"><span data-stu-id="44dc2-190">[Setting Security for Stored Procedures](../multidimensional-models-extending-olap-stored-procedures/setting-security-for-stored-procedures.md) </span></span>  
 [<span data-ttu-id="44dc2-191">定义存储过程</span><span class="sxs-lookup"><span data-stu-id="44dc2-191">Defining Stored Procedures</span></span>](../multidimensional-models-extending-olap-stored-procedures/defining-stored-procedures.md)  
  
  
