---
title: 已分区表和已分区索引 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- partitioned tables [SQL Server], about partitioned tables
- partitioned indexes [SQL Server], architecture
- partitioned tables [SQL Server], architecture
- partitioned indexes [SQL Server], about partitioned indexes
ms.assetid: cc5bf181-18a0-44d5-8bd7-8060d227c927
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: e8d041abcfe491f311e38bc8dab4be4ea253e37c
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87692867"
---
# <a name="partitioned-tables-and-indexes"></a><span data-ttu-id="c6ae5-102">已分区表和已分区索引</span><span class="sxs-lookup"><span data-stu-id="c6ae5-102">Partitioned Tables and Indexes</span></span>
  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="c6ae5-103">支持表和索引分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-103">supports table and index partitioning.</span></span> <span data-ttu-id="c6ae5-104">已分区表和已分区索引的数据划分为分布于一个数据库中多个文件组的单元。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-104">The data of partitioned tables and indexes is divided into units that can be spread across more than one filegroup in a database.</span></span> <span data-ttu-id="c6ae5-105">数据是按水平方式分区的，因此多组行映射到单个的分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-105">The data is partitioned horizontally, so that groups of rows are mapped into individual partitions.</span></span> <span data-ttu-id="c6ae5-106">单个索引或表的所有分区都必须位于同一个数据库中。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-106">All partitions of a single index or table must reside in the same database.</span></span> <span data-ttu-id="c6ae5-107">对数据进行查询或更新时，表或索引将被视为单个逻辑实体。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-107">The table or index is treated as a single logical entity when queries or updates are performed on the data.</span></span> <span data-ttu-id="c6ae5-108">在 [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 的各版本中均不提供已分区的表和索引。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-108">Partitioned tables and indexes are not available in every edition of [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="c6ae5-109">有关各个版本支持的功能列表 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ，请参阅 SQL Server 2014 的各个[版本支持的功能](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md)。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-109">For a list of features that are supported by the editions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], see [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span></span>  
  
> [!IMPORTANT]  
>  [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] <span data-ttu-id="c6ae5-110">在默认情况下支持多达 15,000 个分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-110">supports up to 15,000 partitions by default.</span></span> <span data-ttu-id="c6ae5-111">在 [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]之前的版本中，分区数默认限制为 1000。在基于 x86 的系统上，可以创建分区数超过 1000 的表或索引，但不受支持。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-111">In versions earlier than [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], the number of partitions was limited to 1,000 by default.On x86-based systems, creating a table or index with more than 1000 partitions is possible, but is not supported.</span></span>  
  
## <a name="benefits-of-partitioning"></a><span data-ttu-id="c6ae5-112">分区的优点</span><span class="sxs-lookup"><span data-stu-id="c6ae5-112">Benefits of Partitioning</span></span>  
 <span data-ttu-id="c6ae5-113">通过对大型表或索引进行分区，可以具有以下可管理性和性能优点。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-113">Partitioning large tables or indexes can have the following manageability and performance benefits.</span></span>  
  
-   <span data-ttu-id="c6ae5-114">可以快速、高效地传输或访问数据的子集，同时又能维护数据收集的完整性。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-114">You can transfer or access subsets of data quickly and efficiently, while maintaining the integrity of a data collection.</span></span> <span data-ttu-id="c6ae5-115">例如，将数据从 OLTP 加载到 OLAP 系统之类的操作仅需几秒钟即可完成，而如果不对数据进行分区，执行此操作需要几分钟或几小时。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-115">For example, an operation such as loading data from an OLTP to an OLAP system takes only seconds, instead of the minutes and hours the operation takes when the data is not partitioned.</span></span>  
  
-   <span data-ttu-id="c6ae5-116">您可以更快地对一个或多个分区执行维护操作。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-116">You can perform maintenance operations on one or more partitions more quickly.</span></span> <span data-ttu-id="c6ae5-117">这些操作的效率更高，因为它们仅针对这些数据子集，而非整个表。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-117">The operations are more efficient because they target only these data subsets, instead of the whole table.</span></span> <span data-ttu-id="c6ae5-118">例如，您可以选择在一个或多个分区中压缩数据，或者重新生成索引的一个或多个分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-118">For example, you can choose to compress data in one or more partitions or rebuild one or more partitions of an index.</span></span>  
  
-   <span data-ttu-id="c6ae5-119">您可以根据经常执行的查询类型和硬件配置，提高查询性能。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-119">You may improve query performance, based on the types of queries you frequently run and on your hardware configuration.</span></span> <span data-ttu-id="c6ae5-120">例如，在两个或更多的已分区表中的分区列相同时，查询优化器可以更快地处理这些表之间的同等联接查询，因为可以联接这些分区本身。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-120">For example, the query optimizer can process equi-join queries between two or more partitioned tables faster when the partitioning columns in the tables are the same, because the partitions themselves can be joined.</span></span>  
  
     <span data-ttu-id="c6ae5-121">当 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 针对 I/O 操作执行数据排序时，它会首先按分区对数据进行排序。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-121">When [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] performs data sorting for I/O operations, it sorts the data first by partition.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="c6ae5-122">每次访问一个驱动器，这样可能会降低性能。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-122">accesses one drive at a time, and this might reduce performance.</span></span> <span data-ttu-id="c6ae5-123">为了提高数据排序性能，可以通过设置 RAID 将多个磁盘中的分区数据文件条带化。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-123">To improve data sorting performance, stripe the data files of your partitions across more than one disk by setting up a RAID.</span></span> <span data-ttu-id="c6ae5-124">这样一来，尽管 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 仍按分区对数据进行排序，但它可以同时访问每个分区的所有驱动器。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-124">In this way, although [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] still sorts data by partition, it can access all the drives of each partition at the same time.</span></span>  
  
     <span data-ttu-id="c6ae5-125">此外，您可以通过对在分区级别而不是整个表启用锁升级来提高性能。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-125">In addition, you can improve performance by enabling lock escalation at the partition level instead of a whole table.</span></span> <span data-ttu-id="c6ae5-126">这可以减少表上的锁争用。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-126">This can reduce lock contention on the table.</span></span>  
  
## <a name="components-and-concepts"></a><span data-ttu-id="c6ae5-127">组件和概念</span><span class="sxs-lookup"><span data-stu-id="c6ae5-127">Components and Concepts</span></span>  
 <span data-ttu-id="c6ae5-128">以下术语适用于表和索引分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-128">The following terms are applicable to table and index partitioning.</span></span>  
  
 <span data-ttu-id="c6ae5-129">分区函数</span><span class="sxs-lookup"><span data-stu-id="c6ae5-129">Partition function</span></span>  
 <span data-ttu-id="c6ae5-130">一种数据库对象，它定义如何根据某个列（称为分区列）的值将表或索引的行映射到一组分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-130">A database object that defines how the rows of a table or index are mapped to a set of partitions based on the values of certain column, called a partitioning column.</span></span> <span data-ttu-id="c6ae5-131">也就是说，分区函数定义表将具有的分区数和分区边界的定义方式。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-131">That is, the partition function defines the number of partitions that the table will have and how the boundaries of the partitions are defined.</span></span> <span data-ttu-id="c6ae5-132">例如，假定一个包含销售订单数据的表，您可能需要基于 `datetime` 列（如销售日期）将表划分为 12 个（按月）分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-132">For example, given a table that contains sales order data, you may want to partition the table into twelve (monthly) partitions based on a `datetime` column such as a sales date.</span></span>  
  
 <span data-ttu-id="c6ae5-133">分区方案</span><span class="sxs-lookup"><span data-stu-id="c6ae5-133">Partition scheme</span></span>  
 <span data-ttu-id="c6ae5-134">将分区函数的分区映射到一组文件组的数据库对象。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-134">A database object that maps the partitions of a partition function to a set of filegroups.</span></span> <span data-ttu-id="c6ae5-135">在各个文件组上放置分区的主要原因是为了确保可以在分区上独立执行备份操作。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-135">The primary reason for placing your partitions on separate filegroups is to make sure that you can independently perform backup operations on partitions.</span></span> <span data-ttu-id="c6ae5-136">这是因为您可以在各个文件组上执行备份。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-136">This is because you can perform backups on individual filegroups.</span></span>  
  
 <span data-ttu-id="c6ae5-137">分区列</span><span class="sxs-lookup"><span data-stu-id="c6ae5-137">Partitioning column</span></span>  
 <span data-ttu-id="c6ae5-138">分区函数对表或索引进行分区时所使用的表或索引列。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-138">The column of a table or index that a partition function uses to partition the table or index.</span></span> <span data-ttu-id="c6ae5-139">参与分区函数的计算列必须显式标记为 PERSISTED。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-139">Computed columns that participate in a partition function must be explicitly marked PERSISTED.</span></span> <span data-ttu-id="c6ae5-140">用作索引列时有效的所有数据类型都可以用作分区依据列，`timestamp` 除外。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-140">All data types that are valid for use as index columns can be used as a partitioning column, except `timestamp`.</span></span> <span data-ttu-id="c6ae5-141">无法指定 `ntext`、`text`、`image`、`xml`、`varchar(max)`、`nvarchar(max)` 或 `varbinary(max)` 数据类型。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-141">The `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` data types cannot be specified.</span></span> <span data-ttu-id="c6ae5-142">此外，无法指定 Microsoft .NET Framework 公共语言运行时 (CLR) 用户定义类型和别名数据类型列。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-142">Also, Microsoft .NET Framework common language runtime (CLR) user-defined type and alias data type columns cannot be specified.</span></span>  
  
 <span data-ttu-id="c6ae5-143">对齐的索引</span><span class="sxs-lookup"><span data-stu-id="c6ae5-143">Aligned index</span></span>  
 <span data-ttu-id="c6ae5-144">与其对应的表建立在同一个分区方案之上的一种索引。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-144">An index that is built on the same partition scheme as its corresponding table.</span></span> <span data-ttu-id="c6ae5-145">如果表与其索引对齐，SQL Server 则可以快速高效地切换分区，同时又能维护表及其索引的分区结构。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-145">When a table and its indexes are in alignment, SQL Server can switch partitions quickly and efficiently while maintaining the partition structure of both the table and its indexes.</span></span> <span data-ttu-id="c6ae5-146">索引要与其基表对齐，并不需要与基表参与相同的命名分区函数。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-146">An index does not have to participate in the same named partition function to be aligned with its base table.</span></span> <span data-ttu-id="c6ae5-147">但是，索引和基表的分区函数在实质上必须相同，即：1) 分区函数的参数具有相同的数据类型；2) 分区函数定义了相同数目的分区；3) 分区函数为分区定义了相同的边界值。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-147">However, the partition function of the index and the base table must be essentially the same, in that 1) the arguments of the partition functions have the same data type, 2) they define the same number of partitions, and 3) they define the same boundary values for partitions.</span></span>  
  
 <span data-ttu-id="c6ae5-148">非对齐的索引</span><span class="sxs-lookup"><span data-stu-id="c6ae5-148">Nonaligned index</span></span>  
 <span data-ttu-id="c6ae5-149">独立于其相应的表进行分区的一种索引。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-149">An index partitioned independently from its corresponding table.</span></span> <span data-ttu-id="c6ae5-150">也就是说，索引具有不同的分区方案或者放置于不同于基表的单独文件组中。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-150">That is, the index has a different partition scheme or is placed on a separate filegroup from the base table.</span></span> <span data-ttu-id="c6ae5-151">在下列情况下，设计非对齐的分区索引可能会很有用：</span><span class="sxs-lookup"><span data-stu-id="c6ae5-151">Designing an nonaligned partitioned index can be useful in the following cases:</span></span>  
  
-   <span data-ttu-id="c6ae5-152">基表未分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-152">The base table has not been partitioned.</span></span>  
  
-   <span data-ttu-id="c6ae5-153">索引键是唯一的，不包含表的分区依据列。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-153">The index key is unique and it does not contain the partitioning column of the table.</span></span>  
  
-   <span data-ttu-id="c6ae5-154">您希望基表与使用不同联接列的多个表一起参与并置联接。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-154">You want the base table to participate in collocated joins with more tables using different join columns.</span></span>  
  
 <span data-ttu-id="c6ae5-155">分区排除</span><span class="sxs-lookup"><span data-stu-id="c6ae5-155">Partition elimination</span></span>  
 <span data-ttu-id="c6ae5-156">查询优化器用来仅访问相关分区以便满足查询的筛选条件的过程。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-156">The process by which the query optimizer accesses only the relevant partitions to satisfy the filter criteria of the query.</span></span>  
  
## <a name="performance-guidelines"></a><span data-ttu-id="c6ae5-157">性能准则</span><span class="sxs-lookup"><span data-stu-id="c6ae5-157">Performance Guidelines</span></span>  
 <span data-ttu-id="c6ae5-158">这个新的、更高的 15,000 个分区的限制将影响内存、分区的索引操作、DBCC 命令和查询。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-158">The new, higher limit of 15,000 partitions affects memory, partitioned index operations, DBCC commands, and queries.</span></span> <span data-ttu-id="c6ae5-159">本节介绍将分区数目增加到超过 1,000 个的性能影响并根据需要提供解决方法。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-159">This section describes the performance implications of increasing the number of partitions above 1,000 and provides workarounds as needed.</span></span> <span data-ttu-id="c6ae5-160">由于对分区最大数目的限制已增加到 15,000 个，因此您可以存储更长时间的数据。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-160">With the limit on the maximum number of partitions being increased to 15,000, you can store data for a longer time.</span></span> <span data-ttu-id="c6ae5-161">不过，您应该仅保留所需时长的数据，并且在性能和分区数目之间保持平衡。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-161">However, you should retain data only for as long as it is needed and maintain a balance between performance and number of partitions.</span></span>  
  
### <a name="memory-usage-and-guidelines"></a><span data-ttu-id="c6ae5-162">内存使用情况和指导方针</span><span class="sxs-lookup"><span data-stu-id="c6ae5-162">Memory Usage and Guidelines</span></span>  
 <span data-ttu-id="c6ae5-163">如果正在使用大量分区，我们建议您使用至少 16 GB 的 RAM。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-163">We recommend that you use at least 16 GB of RAM if a large number of partitions are in use.</span></span> <span data-ttu-id="c6ae5-164">如果系统没有足够的内存，则数据操作语言 (DML) 语句、数据定义语言 (DDL) 语句和其他操作可能会由于内存不足而失败。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-164">If the system does not have enough memory, Data Manipulation Language (DML) statements, Data Definition Language (DDL) statements and other operations can fail due to insufficient memory.</span></span> <span data-ttu-id="c6ae5-165">如果系统具有 16 GB 的 RAM 并且运行许多大量占用内存的进程，则在运行大量分区的操作时，可能会出现内存不足的情况。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-165">Systems with 16 GB of RAM that run many memory-intensive processes may run out of memory on operations that run on a large number of partitions.</span></span> <span data-ttu-id="c6ae5-166">因此，您具有超过 16 GB 的内存越多，您遇到性能和内存问题的可能性就越低。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-166">Therefore, the more memory you have over 16 GB, the less likely you are to encounter performance and memory issues.</span></span>  
  
 <span data-ttu-id="c6ae5-167">内存限制可能会影响 SQL Server 生成已分区索引的性能或能力。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-167">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="c6ae5-168">如果表中已应用聚集索引，当索引未与其基表或聚集索引对齐时更是如此。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-168">This is especially the case when the index is not aligned with its base table or is not aligned with its clustered index, if the table already has a clustered index applied to it.</span></span>  
  
### <a name="partitioned-index-operations"></a><span data-ttu-id="c6ae5-169">已分区索引操作</span><span class="sxs-lookup"><span data-stu-id="c6ae5-169">Partitioned Index Operations</span></span>  
 <span data-ttu-id="c6ae5-170">内存限制可能会影响 SQL Server 生成已分区索引的性能或能力。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-170">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="c6ae5-171">具有非对齐索引的情况尤其是这样。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-171">This is especially the case with nonaligned indexes.</span></span> <span data-ttu-id="c6ae5-172">对超过 1,000 个分区的表创建和重新生成非对齐索引是可能的，但不支持。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-172">Creating and rebuilding nonaligned indexes on a table with more than 1,000 partitions is possible, but is not supported.</span></span> <span data-ttu-id="c6ae5-173">这样做可能会导致性能下降，或在执行这些操作的过程中占用过多内存。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-173">Doing so may cause degraded performance or excessive memory consumption during these operations.</span></span>  
  
 <span data-ttu-id="c6ae5-174">随着分区数目的增加，创建和重新生成对齐索引的执行时间可能会更长。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-174">Creating and rebuilding aligned indexes could take longer to execute as the number of partitions increases.</span></span> <span data-ttu-id="c6ae5-175">我们建议您不要同时运行多个创建和重新生成索引命令，因为可能会遇到性能和内存问题。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-175">We recommend that you do not run multiple create and rebuild index commands at the same time as you may run into performance and memory issues.</span></span>  
  
 <span data-ttu-id="c6ae5-176">当 SQL Server 执行排序以生成已分区索引时，它首先为每个分区生成一个排序表。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-176">When SQL Server performs sorting to build partitioned indexes, it first builds one sort table for each partition.</span></span> <span data-ttu-id="c6ae5-177">然后在每个分区各自的文件组中生成排序表，或者在 `tempdb` 中生成排序表（如果指定了 SORT_IN_TEMPDB 索引选项）。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-177">It then builds the sort tables either in the respective filegroup of each partition or in `tempdb`, if the SORT_IN_TEMPDB index option is specified.</span></span> <span data-ttu-id="c6ae5-178">每个排序表都需要一个最小内存量才能生成。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-178">Each sort table requires a minimum amount of memory to build.</span></span> <span data-ttu-id="c6ae5-179">在生成与其基表对齐的已分区索引时，将一次生成一个排序表，因此使用的内存较少。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-179">When you are building a partitioned index that is aligned with its base table, sort tables are built one at a time, using less memory.</span></span> <span data-ttu-id="c6ae5-180">但是，在生成非对齐的已分区索引时，将同时生成排序表。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-180">However, when you are building a nonaligned partitioned index, the sort tables are built at the same time.</span></span> <span data-ttu-id="c6ae5-181">因此，必须有足够的内存来处理这些并发的排序。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-181">As a result, there must be sufficient memory to handle these concurrent sorts.</span></span> <span data-ttu-id="c6ae5-182">分区数越多，所需的内存越多。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-182">The larger the number of partitions, the more memory required.</span></span> <span data-ttu-id="c6ae5-183">每个分区的每个排序表的最小大小为 40 页，每页 8 KB。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-183">The minimum size for each sort table, for each partition, is 40 pages, with 8 kilobytes per page.</span></span> <span data-ttu-id="c6ae5-184">例如，具有 100 个分区的非对齐已分区索引需要足够的内存才能同时连续地对 4,000 (40 \* 100) 页进行排序。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-184">For example, a nonaligned partitioned index with 100 partitions requires sufficient memory to serially sort 4,000 (40 \* 100) pages at the same time.</span></span> <span data-ttu-id="c6ae5-185">如果有这么多的可用内存，生成操作将成功，但性能可能会降低。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-185">If this memory is available, the build operation will succeed, but performance may suffer.</span></span> <span data-ttu-id="c6ae5-186">如果没有这么多可用内存，生成操作将失败。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-186">If this memory is not available, the build operation will fail.</span></span> <span data-ttu-id="c6ae5-187">而具有 100 个分区的对齐已分区索引只需要具有对 40 页进行排序的内存就足够了，因为不会同时执行排序。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-187">Alternatively, an aligned partitioned index with 100 partitions requires only sufficient memory to sort 40 pages, because the sorts are not performed at the same time.</span></span>  
  
 <span data-ttu-id="c6ae5-188">无论是对齐索引还是非对齐索引，如果 SQL Server 对多处理器计算机上的生成操作应用了并行度，需要的内存可能会更多。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-188">For both aligned and nonaligned indexes, the memory requirement can be greater if SQL Server is applying degrees of parallelism to the build operation on a multiprocessor computer.</span></span> <span data-ttu-id="c6ae5-189">这是因为并行度越高，需要的内存就越多。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-189">This is because the greater the degrees of parallelism, the greater the memory requirement.</span></span> <span data-ttu-id="c6ae5-190">例如，如果 SQL Server 将并行度设置为 4，那么具有 100 个分区的非对齐已分区索引将需要使四个处理器同时分别对 4,000 页（即，共 16,000 页）进行排序的足够内存。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-190">For example, if SQL Server sets degrees of parallelism to 4, a nonaligned partitioned index with 100 partitions requires sufficient memory for four processors to sort 4,000 pages at the same time, or 16,000 pages.</span></span> <span data-ttu-id="c6ae5-191">如果已分区索引是对齐的，需要的内存将减少，只要够四个处理器分别对 40 页（共 160 页，即 4 \* 40）进行排序就行了。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-191">If the partitioned index is aligned, the memory requirement is reduced to four processors sorting 40 pages, or 160 (4 \* 40) pages.</span></span> <span data-ttu-id="c6ae5-192">您可以使用 MAXDOP 索引选项手动降低并行度。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-192">You can use the MAXDOP index option to manually reduce the degrees of parallelism.</span></span>  
  
### <a name="dbcc-commands"></a><span data-ttu-id="c6ae5-193">DBCC 命令</span><span class="sxs-lookup"><span data-stu-id="c6ae5-193">DBCC Commands</span></span>  
 <span data-ttu-id="c6ae5-194">在具有较多分区的情况下，随着分区数目的增加，DBCC 命令可能需要更长的时间来执行。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-194">With a larger number of partitions, DBCC commands could take longer to execute as the number of partitions increases.</span></span>  
  
### <a name="queries"></a><span data-ttu-id="c6ae5-195">查询</span><span class="sxs-lookup"><span data-stu-id="c6ae5-195">Queries</span></span>  
 <span data-ttu-id="c6ae5-196">与具有大量分区的查询相比，使用分区排除的查询在性能上相当或更高。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-196">Queries that use partition elimination could have comparable or improved performance with larger number of partitions.</span></span> <span data-ttu-id="c6ae5-197">随着分区数目的增加，未使用分区排除的查询可能需要更长的时间来执行。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-197">Queries that do not use partition elimination could take longer to execute as the number of partitions increases.</span></span>  
  
 <span data-ttu-id="c6ae5-198">例如，假定一个表具有 1 亿行和列的 `A`、 `B`和 `C`。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-198">For example, assume a table has 100 million rows and columns `A`, `B`, and `C`.</span></span> <span data-ttu-id="c6ae5-199">在方案 1 中，该表在列 `A`上划分为 1000 个分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-199">In scenario 1, the table is divided into 1000 partitions on column `A`.</span></span> <span data-ttu-id="c6ae5-200">在方案 2 中，该表在列 `A`上划分为 10,000 个分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-200">In scenario 2, the table is divided into 10,000 partitions on column `A`.</span></span> <span data-ttu-id="c6ae5-201">针对该表的一个查询（该查询对列 `A` 具有 WHERE 子句筛选）将执行分区排除并且扫描一个分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-201">A query on the table that has a WHERE clause filtering on column `A` will perform partition elimination and scan one partition.</span></span> <span data-ttu-id="c6ae5-202">同一个查询在方案 2 中的运行速度可能会更快，因为在分区中要扫描的行数更少。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-202">That same query may run faster in scenario 2 as there are fewer rows to scan in a partition.</span></span> <span data-ttu-id="c6ae5-203">对列 B 具有 WHERE 子句筛选的查询将扫描所有分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-203">A query that has a WHERE clause filtering on column B will scan all partitions.</span></span> <span data-ttu-id="c6ae5-204">与在方案 2 中相比，该查询在方案 1 中的运行速度会更快，因为要扫描更少的分区。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-204">The query may run faster in scenario 1 than in scenario 2 as there are fewer partitions to scan.</span></span>  
  
 <span data-ttu-id="c6ae5-205">在分区列之外的其他列上使用运算符（如 TOP 或 MAX/MIN）的查询可能会遇到分区性能降低的情况，因为所有分区都必须进行评估。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-205">Queries that use operators such as TOP or MAX/MIN on columns other than the partitioning column may experience reduced performance with partitioning because all partitions must be evaluated.</span></span>  
  
## <a name="behavior-changes-in-statistics-computation-during-partitioned-index-operations"></a><span data-ttu-id="c6ae5-206">已分区索引操作期间统计信息计算中的行为更改</span><span class="sxs-lookup"><span data-stu-id="c6ae5-206">Behavior Changes in Statistics Computation During Partitioned Index Operations</span></span>  
 <span data-ttu-id="c6ae5-207">从 [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]开始，当创建或重新生成已分区索引时，将通过扫描表中的所有行来创建统计信息。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-207">Beginning with [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], statistics are not created by scanning all the rows in the table when a partitioned index is created or rebuilt.</span></span> <span data-ttu-id="c6ae5-208">相反，查询优化器使用默认采样算法来生成统计信息。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-208">Instead, the query optimizer uses the default sampling algorithm to generate statistics.</span></span> <span data-ttu-id="c6ae5-209">在升级具有已分区索引的数据库后，您可以在直方图数据中注意到针对这些索引的差异。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-209">After upgrading a database with partitioned indexes, you may notice a difference in the histogram data for these indexes.</span></span> <span data-ttu-id="c6ae5-210">此行为更改可能不会影响查询性能。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-210">This change in behavior may not affect query performance.</span></span> <span data-ttu-id="c6ae5-211">若要通过扫描表中所有行的方法获得有关已分区索引的统计信息，请使用 CREATE STATISTICS 或 UPDATE STATISTICS 以及 FULLSCAN 子句。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-211">To obtain statistics on partitioned indexes by scanning all the rows in the table, use CREATE STATISTICS or UPDATE STATISTICS with the FULLSCAN clause.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="c6ae5-212">Related Tasks</span><span class="sxs-lookup"><span data-stu-id="c6ae5-212">Related Tasks</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c6ae5-213">**任务**</span><span class="sxs-lookup"><span data-stu-id="c6ae5-213">**Tasks**</span></span>|<span data-ttu-id="c6ae5-214">**主题**</span><span class="sxs-lookup"><span data-stu-id="c6ae5-214">**Topic**</span></span>|  
|<span data-ttu-id="c6ae5-215">说明如何创建分区函数和分区方案，然后如何将它们应用于表和索引。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-215">Describes how to create partition functions and partition schemes and then apply these to a table and index.</span></span>|[<span data-ttu-id="c6ae5-216">创建已分区表和索引</span><span class="sxs-lookup"><span data-stu-id="c6ae5-216">Create Partitioned Tables and Indexes</span></span>](create-partitioned-tables-and-indexes.md)|  
|||  
  
## <a name="related-content"></a><span data-ttu-id="c6ae5-217">相关内容</span><span class="sxs-lookup"><span data-stu-id="c6ae5-217">Related Content</span></span>  
 <span data-ttu-id="c6ae5-218">对于已分区表和索引策略以及实现方式，以下白皮书可能对您很有用。</span><span class="sxs-lookup"><span data-stu-id="c6ae5-218">You may find the following white papers on partitioned table and index strategies and implementations useful.</span></span>  
  
-   <span data-ttu-id="c6ae5-219">[使用 SQL Server 2008 的已分区表和索引策略](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span><span class="sxs-lookup"><span data-stu-id="c6ae5-219">[Partitioned Table and Index Strategies Using SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span></span>  
  
-   <span data-ttu-id="c6ae5-220">[如何实现自动滑动窗口](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span><span class="sxs-lookup"><span data-stu-id="c6ae5-220">[How to Implement an Automatic Sliding Window](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span></span>  
  
-   [<span data-ttu-id="c6ae5-221">大容量加载到已分区表</span><span class="sxs-lookup"><span data-stu-id="c6ae5-221">Bulk Loading into a Partitioned Table</span></span>](https://msdn.microsoft.com/library/cc966380.aspx)  
  
-   [<span data-ttu-id="c6ae5-222">关于已分区表和索引的查询处理增强功能</span><span class="sxs-lookup"><span data-stu-id="c6ae5-222">Query Processing Enhancements on Partitioned Tables and Indexes</span></span>](https://msdn.microsoft.com/library/ms345599.aspx)  
  
-   [<span data-ttu-id="c6ae5-223">生成大型关系数据仓库的前 10 大最佳做法</span><span class="sxs-lookup"><span data-stu-id="c6ae5-223">Top 10 Best Practices for Building a Large Scale Relational Data Warehouse</span></span>](http://sqlcat.com/top10lists/archive/2008/02/06/top-10-best-practices-for-building-a-large-scale-relational-data-warehouse.aspx)  
  
  
