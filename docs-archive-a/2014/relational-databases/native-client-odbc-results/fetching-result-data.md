---
title: 提取结果数据 |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQLFetchScroll function
- SQL Server Native Client ODBC driver, result sets
- ODBC applications, result sets
- data types [ODBC], fetching
- SQLBindCol function
- result sets [ODBC], fetching
- fetching [ODBC]
- ODBC data types, fetching
- SQLFetch function
- SQL Server Native Client ODBC driver, data types
- SQLGetData function
ms.assetid: b289c7fb-5017-4d7e-a2d3-19401e9fc4cd
author: rothja
ms.author: jroth
ms.openlocfilehash: 7eb038d431dd7f733c36e5913d72cdc6a161acad
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87693824"
---
# <a name="fetching-result-data"></a><span data-ttu-id="08733-102">提取结果数据</span><span class="sxs-lookup"><span data-stu-id="08733-102">Fetching Result Data</span></span>
  <span data-ttu-id="08733-103">ODBC 应用程序具有三个用于提取结果数据的选项。</span><span class="sxs-lookup"><span data-stu-id="08733-103">An ODBC application has three options for fetching result data.</span></span>  
  
 <span data-ttu-id="08733-104">第一个选项基于[SQLBindCol](../native-client-odbc-api/sqlbindcol.md)。</span><span class="sxs-lookup"><span data-stu-id="08733-104">The first option is based on [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span></span> <span data-ttu-id="08733-105">在提取结果集之前，应用程序使用**SQLBindCol**将结果集中的每列绑定到程序变量。</span><span class="sxs-lookup"><span data-stu-id="08733-105">Before fetching the result set, the application uses **SQLBindCol** to bind each column in the result set to a program variable.</span></span> <span data-ttu-id="08733-106">绑定列后，驱动程序会在每次应用程序调用**SQLFetch**或[SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md)时，将当前行的数据传输到绑定到结果集列的变量中。</span><span class="sxs-lookup"><span data-stu-id="08733-106">After the columns have been bound, the driver transfers the data of the current row into the variables bound to the result set columns each time the application calls **SQLFetch** or [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span></span> <span data-ttu-id="08733-107">如果结果集列和程序变量具有不同的数据类型，则驱动程序将处理数据转换。</span><span class="sxs-lookup"><span data-stu-id="08733-107">The driver handles data conversions if the result set column and program variable have different data types.</span></span> <span data-ttu-id="08733-108">如果应用程序 SQL_ATTR_ROW_ARRAY_SIZE 设置为大于1，则它可以将结果列绑定到变量数组，这将在每次调用**SQLFetchScroll**时都进行填充。</span><span class="sxs-lookup"><span data-stu-id="08733-108">If the application has SQL_ATTR_ROW_ARRAY_SIZE set greater than 1, it can bind result columns to arrays of variables, which will all be filled on each call to **SQLFetchScroll**.</span></span>  
  
 <span data-ttu-id="08733-109">第二个选项基于[SQLGetData](../native-client-odbc-api/sqlgetdata.md)。</span><span class="sxs-lookup"><span data-stu-id="08733-109">The second option is based on [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span></span> <span data-ttu-id="08733-110">应用程序不使用**SQLBindCol**将结果集列绑定到程序变量。</span><span class="sxs-lookup"><span data-stu-id="08733-110">The application does not use **SQLBindCol** to bind result set columns to program variables.</span></span> <span data-ttu-id="08733-111">每次调用**SQLFetch**后，应用程序将为结果集中的每一列调用**SQLGetData**一次。</span><span class="sxs-lookup"><span data-stu-id="08733-111">After each call to **SQLFetch**, the application calls **SQLGetData** once for each column in the result set.</span></span> <span data-ttu-id="08733-112">**SQLGetData**指示驱动程序将数据从特定的结果集列传输到特定的程序变量，并指定列和变量的数据类型。</span><span class="sxs-lookup"><span data-stu-id="08733-112">**SQLGetData** instructs the driver to transfer data from a specific result set column to a specific program variable and specifies the data types of the column and variable.</span></span> <span data-ttu-id="08733-113">如果结果集列和程序变量具有不同的数据类型，则上述操作将允许驱动程序转换数据。</span><span class="sxs-lookup"><span data-stu-id="08733-113">This allows the driver to convert data if the result column and program variable have different data types.</span></span> <span data-ttu-id="08733-114">**Text**、 **ntext**和**image**列通常太大，无法放入程序变量中，但仍可使用**SQLGetData**进行检索。</span><span class="sxs-lookup"><span data-stu-id="08733-114">**Text**, **ntext**, and **image** columns are typically too large to fit into a program variable but can still be retrieved using **SQLGetData**.</span></span> <span data-ttu-id="08733-115">如果 "结果" 列中的**text**、 **ntext**或**image**数据大于程序变量，则**SQLGetData**将返回 SQL_SUCCESS_WITH_INFO 和 SQLSTATE 01004 (字符串数据，并在) 右截断。</span><span class="sxs-lookup"><span data-stu-id="08733-115">If the **text**, **ntext**, or **image** data in the result column is larger than the program variable, **SQLGetData** returns SQL_SUCCESS_WITH_INFO and SQLSTATE 01004 (string data, right truncated).</span></span> <span data-ttu-id="08733-116">对**SQLGetData**的后续调用返回**文本**或**图像**数据的连续块。</span><span class="sxs-lookup"><span data-stu-id="08733-116">Successive calls to **SQLGetData** return successive chunks of the **text** or **image** data.</span></span> <span data-ttu-id="08733-117">在到达数据末尾后， **SQLGetData**将返回 SQL_SUCCESS。</span><span class="sxs-lookup"><span data-stu-id="08733-117">When the end of the data is reached, **SQLGetData** returns SQL_SUCCESS.</span></span> <span data-ttu-id="08733-118">如果 SQL_ATTR_ROW_ARRAY_SIZE 大于 1，则每个提取都将返回一组行或行集。</span><span class="sxs-lookup"><span data-stu-id="08733-118">Each fetch returns a set of rows, or rowset, if SQL_ATTR_ROW_ARRAY_SIZE is greater than 1.</span></span> <span data-ttu-id="08733-119">使用**SQLGetData**之前，必须先使用**SQLSetPos**将行集中的特定行指定为当前行。</span><span class="sxs-lookup"><span data-stu-id="08733-119">Before using **SQLGetData**, you must first use **SQLSetPos** to specify a specific row within the rowset as the current row.</span></span>  
  
 <span data-ttu-id="08733-120">第三种方法是使用**SQLBindCol**和**SQLGetData**的混合。</span><span class="sxs-lookup"><span data-stu-id="08733-120">The third option is to use a mix of **SQLBindCol** and **SQLGetData**.</span></span> <span data-ttu-id="08733-121">例如，应用程序可以绑定一个结果集的前10列，然后在每次提取时调用**SQLGetData**三次，以从三个未绑定的列中检索数据。</span><span class="sxs-lookup"><span data-stu-id="08733-121">An application could, for example, bind the first ten columns of a result set and then, on each fetch, call **SQLGetData** three times to retrieve the data from three unbound columns.</span></span> <span data-ttu-id="08733-122">当结果集包含一个或多个**text**或**image**列时，通常使用此方法。</span><span class="sxs-lookup"><span data-stu-id="08733-122">This would typically be used when a result set contains one or more **text** or **image** columns.</span></span>  
  
 <span data-ttu-id="08733-123">根据为结果集设置的游标选项，应用程序还可以使用**SQLFetchScroll**的滚动选项在结果集的周围滚动。</span><span class="sxs-lookup"><span data-stu-id="08733-123">Depending on the cursor options set for the result set, an application can also use the scrolling options of **SQLFetchScroll** to scroll around the result set.</span></span>  
  
 <span data-ttu-id="08733-124">过度使用**SQLBindCol**将结果集列绑定到程序变量代价高昂，因为**SQLBINDCOL**会导致 ODBC 驱动程序分配内存。</span><span class="sxs-lookup"><span data-stu-id="08733-124">Excess use of **SQLBindCol** to bind a result set column to a program variable is expensive because **SQLBindCol** causes an ODBC driver to allocate memory.</span></span> <span data-ttu-id="08733-125">将结果列绑定到变量时，该绑定始终有效，直到调用[SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md)释放语句句柄，或调用[SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md)并将*fOption*设置为 SQL_UNBIND。</span><span class="sxs-lookup"><span data-stu-id="08733-125">When you bind a result column to a variable, that binding remains in effect until you either call [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) to free the statement handle or call [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) with *fOption* set to SQL_UNBIND.</span></span> <span data-ttu-id="08733-126">在该语句完成前绑定不自动撤消。</span><span class="sxs-lookup"><span data-stu-id="08733-126">The bindings are not automatically undone when the statement completes.</span></span>  
  
 <span data-ttu-id="08733-127">通过这一逻辑，您可以高效地处理使用不同参数多次执行同一 SELECT 语句的情况。</span><span class="sxs-lookup"><span data-stu-id="08733-127">This logic allows you to effectively deal with executing the same SELECT statement several times with different parameters.</span></span> <span data-ttu-id="08733-128">由于结果集保留相同的结构，因此你可以将结果集绑定一次，处理所有 SELECT 语句，然后调用**SQLFreeStmt** ，并将*fOption*设置为在上次执行后 SQL_UNBIND。</span><span class="sxs-lookup"><span data-stu-id="08733-128">Because the result set keeps the same structure, you can bind the result set once, process all the SELECT statements, then call **SQLFreeStmt** with *fOption* set to SQL_UNBIND after the last execution.</span></span> <span data-ttu-id="08733-129">不应调用**SQLBindCol**来绑定结果集中的列，而无需先调用**SQLFreeStmt**并将*fOption*设置为 SQL_UNBIND，以释放以前的任何绑定。</span><span class="sxs-lookup"><span data-stu-id="08733-129">You should not call **SQLBindCol** to bind the columns in a result set without first calling **SQLFreeStmt** with *fOption* set to SQL_UNBIND to free any previous bindings.</span></span>  
  
 <span data-ttu-id="08733-130">当使用**SQLBindCol**时，可以执行按行绑定或按列绑定。</span><span class="sxs-lookup"><span data-stu-id="08733-130">When using **SQLBindCol**, you can either do row-wise or column-wise binding.</span></span> <span data-ttu-id="08733-131">按行绑定比按列绑定稍快。</span><span class="sxs-lookup"><span data-stu-id="08733-131">Row-wise binding is somewhat faster than column-wise binding.</span></span>  
  
 <span data-ttu-id="08733-132">您可以使用**SQLGetData**来逐列检索数据，而不是使用**SQLBindCol**绑定结果集列。</span><span class="sxs-lookup"><span data-stu-id="08733-132">You can use **SQLGetData** to retrieve data on a column-by-column basis instead of binding result set columns using **SQLBindCol**.</span></span> <span data-ttu-id="08733-133">如果结果集只包含几行，则使用**SQLGetData**而不是**SQLBindCol**的速度更快;否则， **SQLBindCol**可提供最佳性能。</span><span class="sxs-lookup"><span data-stu-id="08733-133">If a result set contains only a few rows, using **SQLGetData** instead of **SQLBindCol** is faster; otherwise, **SQLBindCol** gives the best performance.</span></span> <span data-ttu-id="08733-134">如果不始终将数据置于同一组变量中，则应使用**SQLGetData** ，而不是经常重新绑定。</span><span class="sxs-lookup"><span data-stu-id="08733-134">If you do not always put the data in the same set of variables, you should use **SQLGetData** instead of constantly rebinding.</span></span> <span data-ttu-id="08733-135">在所有列都与**SQLBindCol**绑定后，只能对选择列表中的列使用**SQLGetData** 。</span><span class="sxs-lookup"><span data-stu-id="08733-135">You can only use **SQLGetData** on columns that are in the select list after all columns are bound with **SQLBindCol**.</span></span> <span data-ttu-id="08733-136">列还必须出现在已使用**SQLGetData**的任何列之后。</span><span class="sxs-lookup"><span data-stu-id="08733-136">The column must also appear after any columns on which you have already used **SQLGetData**.</span></span>  
  
 <span data-ttu-id="08733-137">用于处理将数据移入或移出程序变量的 ODBC 函数（如**SQLGetData**、 **SQLBindCol**和[SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md)）支持隐式数据类型转换。</span><span class="sxs-lookup"><span data-stu-id="08733-137">The ODBC functions that deal with moving data into or out of program variables, such as **SQLGetData**, **SQLBindCol**, and [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), support implicit data type conversion.</span></span> <span data-ttu-id="08733-138">例如，如果应用程序将某一整数列绑定到某一字符串程序变量，则驱动程序将会首先自动把数据从整数转换为字符，然后将其置于该程序变量中。</span><span class="sxs-lookup"><span data-stu-id="08733-138">For example, if an application binds an integer column to a character string program variable, the driver automatically converts the data from integer to character before placing it into the program variable.</span></span>  
  
 <span data-ttu-id="08733-139">应用程序中的数据转换应尽可能少。</span><span class="sxs-lookup"><span data-stu-id="08733-139">Data conversion in applications should be minimized.</span></span> <span data-ttu-id="08733-140">如果对应用程序执行的处理不要求数据转换，则应用程序应将列和参数绑定到同一数据类型的程序变量。</span><span class="sxs-lookup"><span data-stu-id="08733-140">Unless data conversion is required for the processing done by the application, applications should bind columns and parameters to program variables of the same data type.</span></span> <span data-ttu-id="08733-141">但是，如果数据必须从一种类型转换为另一种类型，让驱动程序执行转换比在应用程序中执行转换的效率更高。</span><span class="sxs-lookup"><span data-stu-id="08733-141">If the data must be converted from one type to another, however, it is more efficient to have the driver do the conversion than doing it in the application.</span></span> <span data-ttu-id="08733-142">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC 驱动程序通常只将数据直接从网络缓冲区传输到应用程序的变量。</span><span class="sxs-lookup"><span data-stu-id="08733-142">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver normally just transfers data directly from the network buffers to the variables of the application.</span></span> <span data-ttu-id="08733-143">请求驱动程序执行数据转换将强制驱动程序把数据存入缓冲区并使用 CPU 周期来转换数据。</span><span class="sxs-lookup"><span data-stu-id="08733-143">Requesting the driver to do data conversion forces the driver to buffer the data and use CPU cycles to convert the data.</span></span>  
  
 <span data-ttu-id="08733-144">除了**text**、 **ntext**和**image**数据之外，程序变量还应足够大以保存从列传入的数据。</span><span class="sxs-lookup"><span data-stu-id="08733-144">Program variables should be large enough to hold data transferred in from a column, except for **text**, **ntext**, and **image** data.</span></span> <span data-ttu-id="08733-145">如果某一应用程序尝试检索结果集数据，而放置这些数据的变量太小以致无法保存数据，则驱动程序将生成一个警告。</span><span class="sxs-lookup"><span data-stu-id="08733-145">If an application attempts to retrieve result set data and place it into a variable that is too small to hold it, the driver generates a warning.</span></span> <span data-ttu-id="08733-146">这强制驱动程序为消息分配内存，并且驱动程序和应用程序都必须将 CPU 周期花在处理消息和执行错误处理上。</span><span class="sxs-lookup"><span data-stu-id="08733-146">This forces the driver to allocate memory for the message, and the driver and application both have to spend CPU cycles processing the message and doing error handling.</span></span> <span data-ttu-id="08733-147">应用程序应或者分配在大小上足以存放检索的数据的变量，或者在选择列表中使用 SUBSTRING 函数减小结果集中列的大小。</span><span class="sxs-lookup"><span data-stu-id="08733-147">The application should either allocate a variable large enough to hold the data being retrieved or use the SUBSTRING function in the select list to reduce the size of the column in the result set.</span></span>  
  
 <span data-ttu-id="08733-148">在使用 SQL_C_DEFAULT 指定 C 变量的类型时必须小心。</span><span class="sxs-lookup"><span data-stu-id="08733-148">Care must be taken when using SQL_C_DEFAULT to specify the type of the C variable.</span></span> <span data-ttu-id="08733-149">SQL_C_DEFAULT 指定 C 变量的类型与列或参数的 SQL 数据类型匹配。</span><span class="sxs-lookup"><span data-stu-id="08733-149">SQL_C_DEFAULT specifies that the type of the C variable matches the SQL data type of the column or parameter.</span></span> <span data-ttu-id="08733-150">如果为**ntext**、 **nchar**或**nvarchar**列指定了 SQL_C_DEFAULT，则会将 Unicode 数据返回到应用程序。</span><span class="sxs-lookup"><span data-stu-id="08733-150">If SQL_C_DEFAULT is specified for an **ntext**, **nchar**, or **nvarchar** column, Unicode data is returned to the application.</span></span> <span data-ttu-id="08733-151">如果尚未对应用程序进行编码以处理 Unicode 数据，则上述操作可能导致不同的问题。</span><span class="sxs-lookup"><span data-stu-id="08733-151">This can cause various problems if the application has not been coded to handle Unicode data.</span></span> <span data-ttu-id="08733-152">SQL_GUID) 数据类型的**uniqueidentifier** (会出现相同的问题类型。</span><span class="sxs-lookup"><span data-stu-id="08733-152">The same types of problems can occur with the **uniqueidentifier** (SQL_GUID) data type.</span></span>  
  
 <span data-ttu-id="08733-153">**text**、 **ntext**和**image**数据通常太大，无法放入单个程序变量，通常使用**SQLGetData**而不是**SQLBindCol**进行处理。</span><span class="sxs-lookup"><span data-stu-id="08733-153">**text**, **ntext**, and **image** data is typically too large to fit into a single program variable, and is usually processed with **SQLGetData** instead of **SQLBindCol**.</span></span> <span data-ttu-id="08733-154">使用服务器游标时， [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native CLIENT ODBC 驱动程序会经过优化，以便在提取行时不传输未绑定的**text**、 **ntext**或**image**列的数据。</span><span class="sxs-lookup"><span data-stu-id="08733-154">When using server cursors, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver is optimized to not transmit the data for unbound **text**, **ntext**, or **image** columns at the time the row is fetched.</span></span> <span data-ttu-id="08733-155">在应用程序为列发出**SQLGetData**之前，不会实际从服务器中检索**text**、 **ntext**或**image**数据。</span><span class="sxs-lookup"><span data-stu-id="08733-155">The **text**, **ntext**, or **image** data is not actually retrieved from the server until the application issues **SQLGetData** for the column.</span></span>  
  
 <span data-ttu-id="08733-156">此优化可应用于应用程序，以便用户在滚动和向下滚动时不显示**text**、 **ntext**或**image**数据。</span><span class="sxs-lookup"><span data-stu-id="08733-156">This optimization can be applied to applications so that no **text**, **ntext**, or **image** data is displayed while a user is scrolling up and down a cursor.</span></span> <span data-ttu-id="08733-157">用户选择行后，应用程序可以调用**SQLGetData**来检索**text**、 **ntext**或**image**数据。</span><span class="sxs-lookup"><span data-stu-id="08733-157">After the user selects a row, the application can call **SQLGetData** to retrieve the **text**, **ntext**, or **image** data.</span></span> <span data-ttu-id="08733-158">这会为用户不选择的任何行保存**文本**、 **ntext**或**图像**数据的传输，并且可以保存非常大的数据量。</span><span class="sxs-lookup"><span data-stu-id="08733-158">This saves transmitting the **text**, **ntext**, or **image** data for any of the rows the user does not select and can save the transmission of very large amounts of data.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="08733-159">另请参阅</span><span class="sxs-lookup"><span data-stu-id="08733-159">See Also</span></span>  
 [<span data-ttu-id="08733-160">&#40;ODBC&#41;处理结果</span><span class="sxs-lookup"><span data-stu-id="08733-160">Processing Results &#40;ODBC&#41;</span></span>](processing-results-odbc.md)  
  
  
