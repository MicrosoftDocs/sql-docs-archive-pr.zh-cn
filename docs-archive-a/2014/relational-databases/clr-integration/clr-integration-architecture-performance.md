---
title: CLR 集成的性能 |Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- common language runtime [SQL Server], performance
- common language runtime [SQL Server], compilation process
- performance [CLR integration]
ms.assetid: 7ce2dfc0-4b1f-4dcb-a979-2c4f95b4cb15
author: rothja
ms.author: jroth
ms.openlocfilehash: 33e45039ed98ea3df607df1714b3c6108ec17c35
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87691235"
---
# <a name="performance-of-clr-integration"></a><span data-ttu-id="9efac-102">CLR 集成的性能</span><span class="sxs-lookup"><span data-stu-id="9efac-102">Performance of CLR Integration</span></span>
  <span data-ttu-id="9efac-103">本主题讨论一些可提高 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 与 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework 公共语言运行时 (CLR) 集成性能的设计选择。</span><span class="sxs-lookup"><span data-stu-id="9efac-103">This topic discusses some of the design choices that enhance the performance of [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integration with the [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework common language runtime (CLR).</span></span>  
  
## <a name="the-compilation-process"></a><span data-ttu-id="9efac-104">编译过程</span><span class="sxs-lookup"><span data-stu-id="9efac-104">The Compilation Process</span></span>  
 <span data-ttu-id="9efac-105">在编译 SQL 表达式时，如果遇到对托管例程的引用，则生成 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] 中间语言 (MSIL) 存根。</span><span class="sxs-lookup"><span data-stu-id="9efac-105">During compilation of SQL expressions, when a reference to a managed routine is encountered, a [!INCLUDE[msCoName](../../../includes/msconame-md.md)] intermediate language (MSIL) stub is generated.</span></span> <span data-ttu-id="9efac-106">该存根包含的代码用于将例程参数从 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 封送到 CLR、调用函数并返回结果。</span><span class="sxs-lookup"><span data-stu-id="9efac-106">This stub includes code to marshal the routine parameters from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to the CLR, invoke the function, and return the result.</span></span> <span data-ttu-id="9efac-107">该“粘附”代码基于参数类型和参数方向（向内、向外或引用）。</span><span class="sxs-lookup"><span data-stu-id="9efac-107">This "glue" code is based on the type of parameter and on parameter direction (in, out, or reference).</span></span>  
  
 <span data-ttu-id="9efac-108">粘附代码支持特定于类型的优化，并确保有效地强制实现 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 语义，例如为 Null 性、约束方面、按值和标准异常处理。</span><span class="sxs-lookup"><span data-stu-id="9efac-108">The glue code enables type-specific optimizations and ensures efficient enforcement of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] semantics, such as nullability, constraining facets, by-value, and standard exception handling.</span></span> <span data-ttu-id="9efac-109">通过为确切类型的参数生成代码，可以避免跨调用边界的类型强制或包装对象创建开销（称为“装箱”）。</span><span class="sxs-lookup"><span data-stu-id="9efac-109">By generating code for the exact types of the arguments, you avoid type coercion or wrapper object creation costs (called "boxing") across the invocation boundary.</span></span>  
  
 <span data-ttu-id="9efac-110">随后，使用 CLR 的 JIT（实时）编译服务将生成的存根编译为本机代码，并针对 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 执行所在的特定硬件体系结构进行优化。</span><span class="sxs-lookup"><span data-stu-id="9efac-110">The generated stub is then compiled to native code and optimized for the particular hardware architecture on which [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] executes, using the JIT (just-in-time) compilation services of the CLR.</span></span> <span data-ttu-id="9efac-111">JIT 服务是在方法级别调用的，并允许 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 宿主环境创建一个跨 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 和 CLR 执行的编译单元。</span><span class="sxs-lookup"><span data-stu-id="9efac-111">The JIT services are invoked at the method level and allow the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] hosting environment to create a single compilation unit that spans both [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and CLR execution.</span></span> <span data-ttu-id="9efac-112">编译存根之后，生成的函数指针即成为函数的运行时实现。</span><span class="sxs-lookup"><span data-stu-id="9efac-112">Once the stub is compiled, the resulting function pointer becomes the run-time implementation of the function.</span></span> <span data-ttu-id="9efac-113">此代码生成方法确保不会发生与运行时反射或元数据访问相关的其他调用开销。</span><span class="sxs-lookup"><span data-stu-id="9efac-113">This code generation approach ensures that there are no additional invocation costs related to reflection or metadata access at run time.</span></span>  
  
### <a name="fast-transitions-between-sql-server-and-clr"></a><span data-ttu-id="9efac-114">在 SQL Server 和 CLR 之间快速转换</span><span class="sxs-lookup"><span data-stu-id="9efac-114">Fast Transitions Between SQL Server and CLR</span></span>  
 <span data-ttu-id="9efac-115">编译过程生成的函数指针可以在运行时通过本机代码调用。</span><span class="sxs-lookup"><span data-stu-id="9efac-115">The compilation process yields a function pointer that can be called at run time from native code.</span></span> <span data-ttu-id="9efac-116">对于标量值用户定义函数，可基于每行调用此函数。</span><span class="sxs-lookup"><span data-stu-id="9efac-116">In the case of scalar-valued user-defined functions, this function invocation happens on a per-row basis.</span></span> <span data-ttu-id="9efac-117">为最大程度地降低在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 和 CLR 之间转换的成本，包含任何托管调用的语句都具有一个标识目标应用程序域的启动步骤。</span><span class="sxs-lookup"><span data-stu-id="9efac-117">To minimize the cost of transitioning between [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR, statements that contain any managed invocation have a startup step to identify the target application domain.</span></span> <span data-ttu-id="9efac-118">该标识步骤减少每行的转换成本。</span><span class="sxs-lookup"><span data-stu-id="9efac-118">This identification step reduces the cost of transitioning for each row.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="9efac-119">性能注意事项</span><span class="sxs-lookup"><span data-stu-id="9efac-119">Performance Considerations</span></span>  
 <span data-ttu-id="9efac-120">以下内容概述了 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中特定于 CLR 集成的性能注意事项。</span><span class="sxs-lookup"><span data-stu-id="9efac-120">The following summarizes performance considerations specific to CLR integration in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="9efac-121">MSDN 网站上的 "[使用 CLR 集成 SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)" 中可找到更详细的信息。</span><span class="sxs-lookup"><span data-stu-id="9efac-121">More detailed information can be found in "[Using CLR Integration in SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)" on the MSDN Web site.</span></span> <span data-ttu-id="9efac-122">有关托管代码性能的常规信息，请参阅 MSDN 网站上的 "[改进 .Net 应用程序的性能和可伸缩性](https://go.microsoft.com/fwlink/?LinkId=50333)"。</span><span class="sxs-lookup"><span data-stu-id="9efac-122">General information regarding managed code performance can be found in "[Improving .NET Application Performance and Scalability](https://go.microsoft.com/fwlink/?LinkId=50333)" on the MSDN Web site.</span></span>  
  
### <a name="user-defined-functions"></a><span data-ttu-id="9efac-123">用户定义函数</span><span class="sxs-lookup"><span data-stu-id="9efac-123">User-Defined Functions</span></span>  
 <span data-ttu-id="9efac-124">相较于 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 用户定义函数，CLR 函数可以从更快的调用路径中受益。</span><span class="sxs-lookup"><span data-stu-id="9efac-124">CLR functions benefit from a quicker invocation path than that of [!INCLUDE[tsql](../../../includes/tsql-md.md)] user-defined functions.</span></span> <span data-ttu-id="9efac-125">此外，同 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 相比，托管代码在过程代码、计算和字符串操作方面具有决定性性能优势。</span><span class="sxs-lookup"><span data-stu-id="9efac-125">Additionally, managed code has a decisive performance advantage over [!INCLUDE[tsql](../../../includes/tsql-md.md)] in terms of procedural code, computation, and string manipulation.</span></span> <span data-ttu-id="9efac-126">需要大量计算且不执行数据访问的 CLR 函数采用托管代码编写的效果更好。</span><span class="sxs-lookup"><span data-stu-id="9efac-126">CLR functions that are computing-intensive and that do not perform data access are better written in managed code.</span></span> <span data-ttu-id="9efac-127">但是与 CLR 集成相比，[!INCLUDE[tsql](../../../includes/tsql-md.md)] 函数的确可以更有效地执行数据访问。</span><span class="sxs-lookup"><span data-stu-id="9efac-127">[!INCLUDE[tsql](../../../includes/tsql-md.md)] functions do, however, perform data access more efficiently than CLR integration.</span></span>  
  
### <a name="user-defined-aggregates"></a><span data-ttu-id="9efac-128">用户定义聚合</span><span class="sxs-lookup"><span data-stu-id="9efac-128">User-Defined Aggregates</span></span>  
 <span data-ttu-id="9efac-129">托管代码的性能大大优于基于游标的聚合。</span><span class="sxs-lookup"><span data-stu-id="9efac-129">Managed code can significantly outperform cursor-based aggregation.</span></span> <span data-ttu-id="9efac-130">托管代码的执行速度通常稍慢于内置 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 聚合函数的执行速度。</span><span class="sxs-lookup"><span data-stu-id="9efac-130">Managed code generally performs slightly slower than built-in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] aggregate functions.</span></span> <span data-ttu-id="9efac-131">如果存在本机内置聚合函数，建议您使用该函数。</span><span class="sxs-lookup"><span data-stu-id="9efac-131">We recommend that if a native built-in aggregate function exists, you should use it.</span></span> <span data-ttu-id="9efac-132">对于所需聚合不受本机支持的情况，出于性能原因，请考虑使用 CLR 用户定义聚合，而不是基于游标的实现。</span><span class="sxs-lookup"><span data-stu-id="9efac-132">In cases in which the needed aggregation is not natively supported, consider a CLR user-defined aggregate over a cursor-based implementation for performance reasons.</span></span>  
  
### <a name="streaming-table-valued-functions"></a><span data-ttu-id="9efac-133">流式表值函数</span><span class="sxs-lookup"><span data-stu-id="9efac-133">Streaming Table-Valued Functions</span></span>  
 <span data-ttu-id="9efac-134">应用程序通常需要返回一个表作为调用函数的结果。</span><span class="sxs-lookup"><span data-stu-id="9efac-134">Applications often need to return a table as a result of invoking a function.</span></span> <span data-ttu-id="9efac-135">示例包括从文件读取表格格式数据作为导入操作的一部分，并将逗号分隔值转换为关系表示形式。</span><span class="sxs-lookup"><span data-stu-id="9efac-135">Examples include reading tabular data from a file as part of an import operation, and converting comma-separated-values to a relational representation.</span></span> <span data-ttu-id="9efac-136">通常，您可以通过在调用方使用结果表之前具体化和填充此结果表来实现此目的。</span><span class="sxs-lookup"><span data-stu-id="9efac-136">Typically, you can accomplish this by materializing and populating the result table before it can be consumed by the caller.</span></span> <span data-ttu-id="9efac-137">CLR 与 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 的集成引入了一种名为流式表值函数 (STVF) 的新扩展性机制。</span><span class="sxs-lookup"><span data-stu-id="9efac-137">The integration of the CLR into [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] introduces a new extensibility mechanism called a streaming table-valued function (STVF).</span></span> <span data-ttu-id="9efac-138">托管 STVF 的性能优于可比扩展存储过程实现的性能。</span><span class="sxs-lookup"><span data-stu-id="9efac-138">Managed STVFs perform better than comparable extended stored procedure implementations.</span></span>  
  
 <span data-ttu-id="9efac-139">STVF 是可返回 `IEnumerable` 接口的托管函数。</span><span class="sxs-lookup"><span data-stu-id="9efac-139">STVFs are managed functions that return an `IEnumerable` interface.</span></span> <span data-ttu-id="9efac-140">`IEnumerable` 具有用于导航 STVF 返回的结果集的方法。</span><span class="sxs-lookup"><span data-stu-id="9efac-140">`IEnumerable` has methods to navigate the result set returned by the STVF.</span></span> <span data-ttu-id="9efac-141">当调用 STVF 时，返回的 `IEnumerable` 直接连接到查询计划。</span><span class="sxs-lookup"><span data-stu-id="9efac-141">When the STVF is invoked, the returned `IEnumerable` is directly connected to the query plan.</span></span> <span data-ttu-id="9efac-142">查询计划在需要提取行时调用 `IEnumerable` 方法。</span><span class="sxs-lookup"><span data-stu-id="9efac-142">The query plan calls `IEnumerable` methods when it needs to fetch rows.</span></span> <span data-ttu-id="9efac-143">使用此迭代模型，结果在第一行生成之后即可使用，而不需要等到整个表填充完。</span><span class="sxs-lookup"><span data-stu-id="9efac-143">This iteration model allows results to be consumed immediately after the first row is produced, instead of waiting until the entire table is populated.</span></span> <span data-ttu-id="9efac-144">还可以极大地减少调用该函数而占用的内存。</span><span class="sxs-lookup"><span data-stu-id="9efac-144">It also significantly reduces the memory consumed by invoking the function.</span></span>  
  
### <a name="arrays-vs-cursors"></a><span data-ttu-id="9efac-145">数组与游标</span><span class="sxs-lookup"><span data-stu-id="9efac-145">Arrays vs. Cursors</span></span>  
 <span data-ttu-id="9efac-146">当 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 游标必须遍历更容易表示为数组的数据时，使用托管代码可以显著提高性能。</span><span class="sxs-lookup"><span data-stu-id="9efac-146">When [!INCLUDE[tsql](../../../includes/tsql-md.md)] cursors must traverse data that is more easily expressed as an array, managed code can be used with significant performance gains.</span></span>  
  
### <a name="string-data"></a><span data-ttu-id="9efac-147">字符串数据</span><span class="sxs-lookup"><span data-stu-id="9efac-147">String Data</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="9efac-148">字符数据（如 `varchar`）在托管函数中可以是 SqlString 或 SqlChars 类型。</span><span class="sxs-lookup"><span data-stu-id="9efac-148">character data, such as `varchar`, can be of the type SqlString or SqlChars in managed functions.</span></span> <span data-ttu-id="9efac-149">SqlString 变量将整个值的实例创建到内存中。</span><span class="sxs-lookup"><span data-stu-id="9efac-149">SqlString variables create an instance of the entire value into memory.</span></span> <span data-ttu-id="9efac-150">SqlChars 变量提供可用于获得更好性能和可扩展性的流式接口，而无需将整个值的实例创建到内存中。</span><span class="sxs-lookup"><span data-stu-id="9efac-150">SqlChars variables provide a streaming interface that can be used to achieve better performance and scalability by not creating an instance of the entire value into memory.</span></span> <span data-ttu-id="9efac-151">这对于大型对象 (LOB) 数据尤为重要。</span><span class="sxs-lookup"><span data-stu-id="9efac-151">This becomes particularly important for large object (LOB) data.</span></span> <span data-ttu-id="9efac-152">此外，还可以通过 `SqlXml.CreateReader()` 返回的流式接口访问服务器 XML 数据。</span><span class="sxs-lookup"><span data-stu-id="9efac-152">Additionally, server XML data can be accessed through a streaming interface returned by `SqlXml.CreateReader()`.</span></span>  
  
### <a name="clr-vs-extended-stored-procedures"></a><span data-ttu-id="9efac-153">CLR 与扩展存储过程</span><span class="sxs-lookup"><span data-stu-id="9efac-153">CLR vs. Extended Stored Procedures</span></span>  
 <span data-ttu-id="9efac-154">允许托管过程向客户端回发结果集的 Microsoft.SqlServer.Server 应用程序编程接口 (API) 的性能优于扩展存储过程使用的开放式数据服务 (ODS) API。</span><span class="sxs-lookup"><span data-stu-id="9efac-154">The Microsoft.SqlServer.Server application programming interfaces (APIs) that allow managed procedures to send result sets back to the client perform better than the Open Data Services (ODS) APIs used by extended stored procedures.</span></span> <span data-ttu-id="9efac-155">此外，System.Data.SqlServer API 支持 `xml`、`varchar(max)`、`nvarchar(max)` 和 `varbinary(max)` 等 [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] 中引入的数据类型，但是尚未将 ODS API 扩展为支持新的数据类型。</span><span class="sxs-lookup"><span data-stu-id="9efac-155">Furthermore, the System.Data.SqlServer APIs support data types such as `xml`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)`, introduced in [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)], while the ODS APIs have not been extended to support the new data types.</span></span>  
  
 <span data-ttu-id="9efac-156">通过托管代码，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 管理对内存、线程和同步等资源的使用。</span><span class="sxs-lookup"><span data-stu-id="9efac-156">With managed code, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] manages use of resources such as memory, threads, and synchronization.</span></span> <span data-ttu-id="9efac-157">这是因为公开这些资源的托管 API 是针对 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 资源管理器实现的。</span><span class="sxs-lookup"><span data-stu-id="9efac-157">This is because the managed APIs that expose these resources are implemented on top of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] resource manager.</span></span> <span data-ttu-id="9efac-158">相反，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 无法查看或控制扩展存储过程的资源使用情况。</span><span class="sxs-lookup"><span data-stu-id="9efac-158">Conversely, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] has no view or control over the resource usage of the extended stored procedure.</span></span> <span data-ttu-id="9efac-159">例如，如果扩展存储过程占用过多 CPU 或内存资源，则无法通过 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 检测或控制此种情况。</span><span class="sxs-lookup"><span data-stu-id="9efac-159">For example, if an extended stored procedure consumes too much CPU or memory resources, there is no way to detect or control this with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="9efac-160">但是，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 可以使用托管代码检测到给定线程已有很长一段时间未生成结果，并强制该任务生成以便安排其他工作。</span><span class="sxs-lookup"><span data-stu-id="9efac-160">With managed code, however, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can detect that a given thread has not yielded for a long period of time, and then force the task to yield so that other work can be scheduled.</span></span> <span data-ttu-id="9efac-161">因此，使用托管代码可以提高可扩展性，并改善系统资源使用情况。</span><span class="sxs-lookup"><span data-stu-id="9efac-161">Consequently, using managed code provides for better scalability and system resource usage.</span></span>  
  
 <span data-ttu-id="9efac-162">托管代码可能带来维护执行环境和执行安全检查所需的额外开销。</span><span class="sxs-lookup"><span data-stu-id="9efac-162">Managed code may incur additional overhead necessary to maintain the execution environment and perform security checks.</span></span> <span data-ttu-id="9efac-163">例如，当在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 内运行并需要执行从托管代码到本机代码的大量转换时，可能会发生此种情况（因为在托管代码和本机代码之间来回转换时，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 需要对特定于线程的设置进行额外维护）。</span><span class="sxs-lookup"><span data-stu-id="9efac-163">This is the case, for example, when running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and numerous transitions from managed to native code are required (because [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] needs to do additional maintenance on thread-specific settings when moving out to native code and back).</span></span> <span data-ttu-id="9efac-164">因此，对于在托管代码和本机代码之间进行频繁转换的情况，扩展存储过程的性能大大优于在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 内运行的托管代码的性能。</span><span class="sxs-lookup"><span data-stu-id="9efac-164">Consequently, extended stored procedures can significantly outperform managed code running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for cases in which there are frequent transitions between managed and native code.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9efac-165">建议您不要开发新的扩展存储过程，因为已不推荐使用此功能。</span><span class="sxs-lookup"><span data-stu-id="9efac-165">It is recommended that you do not develop new extended stored procedures, because this feature has been deprecated.</span></span>  
  
### <a name="native-serialization-for-user-defined-types"></a><span data-ttu-id="9efac-166">用户定义类型的本机序列化</span><span class="sxs-lookup"><span data-stu-id="9efac-166">Native Serialization for User-Defined Types</span></span>  
 <span data-ttu-id="9efac-167">用户定义类型 (UDT) 是作为标量类型系统的扩展性机制设计的。</span><span class="sxs-lookup"><span data-stu-id="9efac-167">User-defined types (UDTs) are designed as an extensibility mechanism for the scalar type system.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="9efac-168">实现一种称为 `Format.Native` 的 UDT 序列化格式。</span><span class="sxs-lookup"><span data-stu-id="9efac-168">implements a serialization format for UDTs called `Format.Native`.</span></span> <span data-ttu-id="9efac-169">在编译期间，检查该类型的结构以便生成针对该特定类型定义自定义的 MSIL。</span><span class="sxs-lookup"><span data-stu-id="9efac-169">During compilation, the structure of the type is examined to generate MSIL that is customized for that particular type definition.</span></span>  
  
 <span data-ttu-id="9efac-170">本机序列化是针对 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 的默认实现。</span><span class="sxs-lookup"><span data-stu-id="9efac-170">Native serialization is the default implementation for [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="9efac-171">用户定义序列化调用由类型作者定义的方法来执行序列化。</span><span class="sxs-lookup"><span data-stu-id="9efac-171">User-defined serialization invokes a method defined by the type author to do the serialization.</span></span> <span data-ttu-id="9efac-172">应尽可能使用 `Format.Native` 序列化以便获得最佳性能。</span><span class="sxs-lookup"><span data-stu-id="9efac-172">`Format.Native` serialization should be used when possible for best performance.</span></span>  
  
### <a name="normalization-of-comparable-udts"></a><span data-ttu-id="9efac-173">可比 UDT 的规范化</span><span class="sxs-lookup"><span data-stu-id="9efac-173">Normalization of Comparable UDTs</span></span>  
 <span data-ttu-id="9efac-174">关系操作（例如对 UDT 进行排序和比较）是针对值的二进制表示形式直接执行的。</span><span class="sxs-lookup"><span data-stu-id="9efac-174">Relational operations, such as sorting and comparing UDTs, operate directly on the binary representation of the value.</span></span> <span data-ttu-id="9efac-175">通过在磁盘上存储 UDT 状态的规范化（二进制排序）表示形式可以实现此目的。</span><span class="sxs-lookup"><span data-stu-id="9efac-175">This is accomplished by storing a normalized (binary ordered) representation of the state of the UDT on disk.</span></span>  
  
 <span data-ttu-id="9efac-176">规范化具有两个优点：避免构造类型实例和方法调用开销，进而极大地降低了比较操作的成本；为 UDT 创建二进制域，支持构造直方图、索引以及该类型的值的直方图。</span><span class="sxs-lookup"><span data-stu-id="9efac-176">Normalization has two benefits: it makes the comparison operation considerably less expensive by avoiding the construction of the type instance and the method invocation overhead; and it creates a binary domain for the UDT, enabling the construction of histograms, indexes, and histograms for values of the type.</span></span> <span data-ttu-id="9efac-177">因此，规范化 UDT 的性能配置文件类似于未涉及方法调用的操作的本机内置类型性能配置文件。</span><span class="sxs-lookup"><span data-stu-id="9efac-177">Consequently, normalized UDTs have a very similar performance profile to the native built-in types for operations that do not involve method invocation.</span></span>  
  
### <a name="scalable-memory-usage"></a><span data-ttu-id="9efac-178">可扩展内存使用量</span><span class="sxs-lookup"><span data-stu-id="9efac-178">Scalable Memory Usage</span></span>  
 <span data-ttu-id="9efac-179">为了在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中很好地执行和调整托管垃圾回收，请避免使用大型单一分配。</span><span class="sxs-lookup"><span data-stu-id="9efac-179">In order for managed garbage collection to perform and scale well in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], avoid large, single allocation.</span></span> <span data-ttu-id="9efac-180">大小大于 88 千字节 (KB) 的分配将被放置到大对象堆，这将导致垃圾回收的性能和调整结果远不如多个较小分配的性能和调整结果。</span><span class="sxs-lookup"><span data-stu-id="9efac-180">Allocations greater than 88 kilobytes (KB) in size will be placed on the Large Object Heap, which will cause garbage collection to perform and scale much worse than many smaller allocations.</span></span> <span data-ttu-id="9efac-181">例如，如果需要分配一个大型多维数组，最好分配一个交错（分散）数组。</span><span class="sxs-lookup"><span data-stu-id="9efac-181">For example, if you need to allocate a large multi-dimensional array, it is better to allocate a jagged (scattered) array.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9efac-182">另请参阅</span><span class="sxs-lookup"><span data-stu-id="9efac-182">See Also</span></span>  
 [<span data-ttu-id="9efac-183">CLR 用户定义类型</span><span class="sxs-lookup"><span data-stu-id="9efac-183">CLR User-Defined Types</span></span>](../clr-integration-database-objects-user-defined-types/clr-user-defined-types.md)  
  
  
