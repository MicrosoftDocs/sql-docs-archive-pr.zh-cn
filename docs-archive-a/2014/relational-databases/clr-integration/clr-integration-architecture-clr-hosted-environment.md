---
title: CLR 托管环境 |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- type-safe code [CLR integration]
- UNSAFE permission set
- run-time environments [CLR integration]
- common language runtime [SQL Server], about CLR integration
- application domains [CLR integration]
- host protection attributes [CLR integration]
- managed code [SQL Server], common language runtime
- permission sets [CLR integration]
- reliability [CLR integration]
- SAFE permission set
- code access security [CLR integration]
- EXTERNAL_ACCESS permission set
- verifying type safety
- scalability [CLR integration]
- hosted environments [CLR integration]
- HPAs [CLR integration]
ms.assetid: d280d359-08f0-47b5-a07e-67dd2a58ad73
author: rothja
ms.author: jroth
ms.openlocfilehash: bd04536d1dfb8a4657fbe116cdfd38a6639a6327
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87691237"
---
# <a name="clr-hosted-environment"></a><span data-ttu-id="10312-102">CLR 宿主环境</span><span class="sxs-lookup"><span data-stu-id="10312-102">CLR Hosted Environment</span></span>
  <span data-ttu-id="10312-103">[!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework 公共语言运行时 (CLR) 是执行很多现代编程语言的环境，这些语言包括 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C#、[!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual Basic 和 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C++。</span><span class="sxs-lookup"><span data-stu-id="10312-103">The [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework common language runtime (CLR) is an environment that executes many modern programming languages, including [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C#, [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual Basic, and [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C++.</span></span> <span data-ttu-id="10312-104">CLR 具有收集垃圾的内存、抢先线程化、元数据服务（类型反射）、代码可验证和代码访问安全性等特点。</span><span class="sxs-lookup"><span data-stu-id="10312-104">The CLR features garbage-collected memory, pre-emptive threading, metadata services (type reflection), code verifiability, and code access security.</span></span> <span data-ttu-id="10312-105">CLR 使用元数据来完成以下任务：查找和加载类、在内存中安排实例、解析方法调用、生成本机代码、强制安全性以及设置运行时上下文边界。</span><span class="sxs-lookup"><span data-stu-id="10312-105">The CLR uses metadata to locate and load classes, lay out instances in memory, resolve method invocations, generate native code, enforce security, and set run-time context boundaries.</span></span>  
  
 <span data-ttu-id="10312-106">CLR 和 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 作为运行时环境以不同的方式处理内存、线程和同步。</span><span class="sxs-lookup"><span data-stu-id="10312-106">The CLR and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] differ as run-time environments in the way they handle memory, threads, and synchronization.</span></span> <span data-ttu-id="10312-107">本主题说明如何集成这两种运行时以便统一管理所有系统资源，</span><span class="sxs-lookup"><span data-stu-id="10312-107">This topic describes the way in which these two run times are integrated so that all system resources are managed uniformly.</span></span> <span data-ttu-id="10312-108">还涉及如何集成 CLR 代码访问安全性 (CAS) 和 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 安全性以为用户代码提供安全可靠的执行环境。</span><span class="sxs-lookup"><span data-stu-id="10312-108">This topic also covers the way in which CLR code access security (CAS) and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] security are integrated to provide a reliable and secure execution environment for user code.</span></span>  
  
## <a name="basic-concepts-of-clr-architecture"></a><span data-ttu-id="10312-109">CLR 体系结构的基本概念</span><span class="sxs-lookup"><span data-stu-id="10312-109">Basic Concepts of CLR Architecture</span></span>  
 <span data-ttu-id="10312-110">在 .NET Framework 中，程序员使用高级语言实现定义其结构的类（例如，类的字段或属性）和方法。</span><span class="sxs-lookup"><span data-stu-id="10312-110">In the .NET Framework, a programmer writes in a high-level language that implements a class defining its structure (for example, the fields or properties of the class) and methods.</span></span> <span data-ttu-id="10312-111">其中某些方法可能是静态函数。</span><span class="sxs-lookup"><span data-stu-id="10312-111">Some of these methods can be static functions.</span></span> <span data-ttu-id="10312-112">编译该程序时会生成一个名为程序集的文件以及一个清单，程序集包含用 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] 中间语言 (MSIL) 编译的代码，清单则包含对依赖程序集的所有引用。</span><span class="sxs-lookup"><span data-stu-id="10312-112">The compilation of the program produces a file called an assembly that contains the compiled code in the [!INCLUDE[msCoName](../../../includes/msconame-md.md)] intermediate language (MSIL), and a manifest that contains all references to dependent assemblies.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="10312-113">程序集是 CLR 体系结构中的关键元素。</span><span class="sxs-lookup"><span data-stu-id="10312-113">Assemblies are a vital element in the architecture of the CLR.</span></span> <span data-ttu-id="10312-114">它们是 .NET Framework 中对应用程序代码进行打包、部署和版本化的单位。</span><span class="sxs-lookup"><span data-stu-id="10312-114">They are the units of packaging, deployment, and versioning of application code in the .NET Framework.</span></span> <span data-ttu-id="10312-115">通过使用程序集，可以在数据库内部署应用程序代码并以统一方式管理、备份和还原完整的数据库应用程序。</span><span class="sxs-lookup"><span data-stu-id="10312-115">Using assemblies, you can deploy application code inside the database and provide a uniform way to administer, back up, and restore complete database applications.</span></span>  
  
 <span data-ttu-id="10312-116">程序集清单包含有关程序集的元数据，描述在程序中定义的所有结构、字段、属性、类、继承关系、函数和方法。</span><span class="sxs-lookup"><span data-stu-id="10312-116">The assembly manifest contains metadata about the assembly, describing all of the structures, fields, properties, classes, inheritance relationships, functions, and methods defined in the program.</span></span> <span data-ttu-id="10312-117">该清单确定程序集标识，指定组成程序集实现的文件，指定组成程序集的类型和资源，列举对其他程序集的编译时依赖项，并指定确保程序集正常运行所需的权限集。</span><span class="sxs-lookup"><span data-stu-id="10312-117">The manifest establishes the assembly identity, specifies the files that make up the assembly implementation, specifies the types and resources that make up the assembly, itemizes the compile-time dependencies on other assemblies, and specifies the set of permissions required for the assembly to run properly.</span></span> <span data-ttu-id="10312-118">在运行时使用此信息来解析引用，强制执行版本绑定策略，并验证已加载的程序集的完整性。</span><span class="sxs-lookup"><span data-stu-id="10312-118">This information is used at run time to resolve references, enforce version binding policy, and validate the integrity of loaded assemblies.</span></span>  
  
 <span data-ttu-id="10312-119">.NET Framework 支持自定义属性，这些属性使用应用程序可以在元数据中捕获的其他信息来对类、属性、函数和方法进行批注。</span><span class="sxs-lookup"><span data-stu-id="10312-119">The .NET Framework supports custom attributes for annotating classes, properties, functions, and methods with additional information the application may capture in metadata.</span></span> <span data-ttu-id="10312-120">所有 .NET Framework 编译器不需要解释就可以使用这些批注并将它们作为程序集元数据存储。</span><span class="sxs-lookup"><span data-stu-id="10312-120">All .NET Framework compilers consume these annotations without interpretation and store them as assembly metadata.</span></span> <span data-ttu-id="10312-121">可以像检查任何其他元数据那样检查这些批注。</span><span class="sxs-lookup"><span data-stu-id="10312-121">These annotations can be examined in the same way as any other metadata.</span></span>  
  
 <span data-ttu-id="10312-122">托管代码是在 CLR 中执行而非直接由操作系统执行的 MSIL。</span><span class="sxs-lookup"><span data-stu-id="10312-122">Managed code is MSIL executed in the CLR, rather than directly by the operating system.</span></span> <span data-ttu-id="10312-123">托管代码应用程序可以获得 CLR 服务，例如自动垃圾收集、运行时类型检查和安全支持等。</span><span class="sxs-lookup"><span data-stu-id="10312-123">Managed code applications acquire CLR services, such as automatic garbage collection, run-time type checking, and security support.</span></span> <span data-ttu-id="10312-124">这些服务有助于提供与平台和语言无关的托管代码应用程序行为。</span><span class="sxs-lookup"><span data-stu-id="10312-124">These services help provide uniform platform- and language-independent behavior of managed code applications.</span></span>  
  
## <a name="design-goals-of-clr-integration"></a><span data-ttu-id="10312-125">CLR 集成的设计目标</span><span class="sxs-lookup"><span data-stu-id="10312-125">Design Goals of CLR Integration</span></span>  
 <span data-ttu-id="10312-126">用户代码在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中的 CLR 宿主环境（称为 CLR 集成）内运行时，应力求实现以下设计目标：</span><span class="sxs-lookup"><span data-stu-id="10312-126">When user code runs inside the CLR-hosted environment in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] (called CLR integration), the following design goals apply:</span></span>  
  
###### <a name="reliability-safety"></a><span data-ttu-id="10312-127">可靠性（安全性）</span><span class="sxs-lookup"><span data-stu-id="10312-127">Reliability (Safety)</span></span>  
 <span data-ttu-id="10312-128">不应允许用户代码执行损害数据库引擎进程完整性的操作，例如弹出请求用户响应的消息框或退出进程。</span><span class="sxs-lookup"><span data-stu-id="10312-128">User code should not be allowed to perform operations that compromise the integrity of the Database Engine process, such as popping a message box requesting a user response or exiting the process.</span></span> <span data-ttu-id="10312-129">用户代码应不能覆盖数据库引擎内存缓冲区或内部数据结构。</span><span class="sxs-lookup"><span data-stu-id="10312-129">User code should not be able to overwrite Database Engine memory buffers or internal data structures.</span></span>  
  
###### <a name="scalability"></a><span data-ttu-id="10312-130">可伸缩性</span><span class="sxs-lookup"><span data-stu-id="10312-130">Scalability</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="10312-131">和 CLR 具有用于计划和内存管理的不同内部模型。</span><span class="sxs-lookup"><span data-stu-id="10312-131">and the CLR have different internal models for scheduling and memory management.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="10312-132">支持协作、非抢先的线程模型，在此模型中，线程将定期或在等待锁或 I/O 时主动生成执行。</span><span class="sxs-lookup"><span data-stu-id="10312-132">supports a cooperative, non-preemptive threading model in which the threads voluntarily yield execution periodically, or when they are waiting on locks or I/O.</span></span> <span data-ttu-id="10312-133">CLR 则支持抢先的线程化模型。</span><span class="sxs-lookup"><span data-stu-id="10312-133">The CLR supports a preemptive threading model.</span></span> <span data-ttu-id="10312-134">如果在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 内运行的用户代码可以直接调用操作系统线程化基元，就不能很好地与 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 任务计划程序集成，可能降低系统的可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="10312-134">If user code running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can directly call the operating system threading primitives, then it does not integrate well into the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] task scheduler and can degrade the scalability of the system.</span></span> <span data-ttu-id="10312-135">CLR 不区分虚拟内存和物理内存，但是 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 直接管理物理内存并要求在可配置的限制范围内使用物理内存。</span><span class="sxs-lookup"><span data-stu-id="10312-135">The CLR does not distinguish between virtual and physical memory, but [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] directly manages physical memory and is required to use physical memory within a configurable limit.</span></span>  
  
 <span data-ttu-id="10312-136">不同的线程化、计划和内存管理的模型给需要支持成千上万的并发用户会话的关系数据库管理系统 (RDBMS) 带来了集成挑战。</span><span class="sxs-lookup"><span data-stu-id="10312-136">The different models for threading, scheduling, and memory management present an integration challenge for a relational database management system (RDBMS) that scales to support thousands of concurrent user sessions.</span></span> <span data-ttu-id="10312-137">体系结构应确保直接调用线程化、内存和同步基元的应用程序编程接口 (API) 的用户代码不损害系统的可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="10312-137">The architecture should ensure that the scalability of the system is not compromised by user code calling application programming interfaces (APIs) for threading, memory, and synchronization primitives directly.</span></span>  
  
###### <a name="security"></a><span data-ttu-id="10312-138">安全性</span><span class="sxs-lookup"><span data-stu-id="10312-138">Security</span></span>  
 <span data-ttu-id="10312-139">在数据库中运行的用户代码在访问诸如表和列的数据库对象时，必须遵守 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 身份验证和授权规则。</span><span class="sxs-lookup"><span data-stu-id="10312-139">User code running in the database must follow [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] authentication and authorization rules when accessing database objects such as tables and columns.</span></span> <span data-ttu-id="10312-140">此外，数据库管理员应能从在数据库中运行的用户代码控制对操作系统资源的访问，如文件和网络访问。</span><span class="sxs-lookup"><span data-stu-id="10312-140">In addition, database administrators should be able to control access to operating system resources, such as files and network access, from user code running in the database.</span></span> <span data-ttu-id="10312-141">这对于托管编程语言很重要，因为与诸如 Transact-SQL 之类的非托管语言不同，托管编程语言提供访问这类资源的 API。</span><span class="sxs-lookup"><span data-stu-id="10312-141">This becomes important as managed programming languages (unlike non-managed languages such as Transact-SQL) provide APIs to access such resources.</span></span> <span data-ttu-id="10312-142">系统必须为用户代码提供安全的方法来访问[!INCLUDE[ssDE](../../../includes/ssde-md.md)]进程之外的计算机资源。</span><span class="sxs-lookup"><span data-stu-id="10312-142">The system must provide a secure way for user code to access machine resources outside the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] process.</span></span> <span data-ttu-id="10312-143">有关详细信息，请参阅 [CLR Integration Security](security/clr-integration-security.md)。</span><span class="sxs-lookup"><span data-stu-id="10312-143">For more information, see [CLR Integration Security](security/clr-integration-security.md).</span></span>  
  
###### <a name="performance"></a><span data-ttu-id="10312-144">性能</span><span class="sxs-lookup"><span data-stu-id="10312-144">Performance</span></span>  
 <span data-ttu-id="10312-145">在[!INCLUDE[ssDE](../../../includes/ssde-md.md)]中运行的托管用户代码与在服务器外运行的同一代码相比，应具有同等的计算性能。</span><span class="sxs-lookup"><span data-stu-id="10312-145">Managed user code running in the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] should have computational performance comparable to the same code run outside the server.</span></span> <span data-ttu-id="10312-146">从托管用户代码进行数据库访问没有本机 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 快。</span><span class="sxs-lookup"><span data-stu-id="10312-146">Database access from managed user code is not as fast as native [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="10312-147">有关详细信息，请参阅[CLR 集成的性能](clr-integration-architecture-performance.md)。</span><span class="sxs-lookup"><span data-stu-id="10312-147">For more information, see [Performance of CLR Integration](clr-integration-architecture-performance.md).</span></span>  
  
## <a name="clr-services"></a><span data-ttu-id="10312-148">CLR Services</span><span class="sxs-lookup"><span data-stu-id="10312-148">CLR Services</span></span>  
 <span data-ttu-id="10312-149">CLR 提供很多服务来帮助实现 CLR 与 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 集成的设计目标。</span><span class="sxs-lookup"><span data-stu-id="10312-149">The CLR provides a number of services to help achieve the design goals of CLR integration with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
###### <a name="type-safety-verification"></a><span data-ttu-id="10312-150">类型安全验证</span><span class="sxs-lookup"><span data-stu-id="10312-150">Type safety verification</span></span>  
 <span data-ttu-id="10312-151">类型安全代码是仅以定义完善的方式访问内存结构的代码。</span><span class="sxs-lookup"><span data-stu-id="10312-151">Type-safe code is code that accesses memory structures only in well-defined ways.</span></span> <span data-ttu-id="10312-152">例如，给定有效的对象引用，类型安全代码可以按对应于实际字段成员的固定偏移量来访问内存。</span><span class="sxs-lookup"><span data-stu-id="10312-152">For example, given a valid object reference, type-safe code can access memory at fixed offsets corresponding to actual field members.</span></span> <span data-ttu-id="10312-153">但是，如果代码以任意偏移量访问内存，该偏移量可能超出也可能不超出属于该对象的内存范围，则它就不是类型安全的代码。</span><span class="sxs-lookup"><span data-stu-id="10312-153">However, if the code accesses memory at arbitrary offsets inside or outside the range of memory that belongs to the object, then it is not type-safe.</span></span> <span data-ttu-id="10312-154">在 CLR 中加载程序集时，在使用实时 (JIT) 编译方式编译 MSIL 之前，运行时执行验证阶段，该阶段检查代码以确定其类型是否安全。</span><span class="sxs-lookup"><span data-stu-id="10312-154">When assemblies are loaded in the CLR, prior to the MSIL being compiled using just-in-time (JIT) compilation, the runtime performs a verification phase that examines code to determine its type-safety.</span></span> <span data-ttu-id="10312-155">成功通过此验证的代码称为可验证的类型安全代码。</span><span class="sxs-lookup"><span data-stu-id="10312-155">Code that successfully passes this verification is called verifiably type-safe code.</span></span>  
  
###### <a name="application-domains"></a><span data-ttu-id="10312-156">应用程序域</span><span class="sxs-lookup"><span data-stu-id="10312-156">Application domains</span></span>  
 <span data-ttu-id="10312-157">CLR 支持应用程序域作为主机进程内的执行区的概念，在其中可以加载和执行托管代码程序集。</span><span class="sxs-lookup"><span data-stu-id="10312-157">The CLR supports the notion of application domains as execution zones within a host process where managed code assemblies can be loaded and executed.</span></span> <span data-ttu-id="10312-158">应用程序域边界提供程序集之间的隔离。</span><span class="sxs-lookup"><span data-stu-id="10312-158">The application domain boundary provides isolation between assemblies.</span></span> <span data-ttu-id="10312-159">根据静态变量和数据成员的可见性以及是否可以动态调用代码对这些程序集进行隔离。</span><span class="sxs-lookup"><span data-stu-id="10312-159">The assemblies are isolated in terms of visibility of static variables and data members and the ability to call code dynamically.</span></span> <span data-ttu-id="10312-160">应用程序域也提供加载和卸载代码的机制。</span><span class="sxs-lookup"><span data-stu-id="10312-160">Application domains are also the mechanism for loading and unloading code.</span></span> <span data-ttu-id="10312-161">只能通过卸载应用程序域，从内存中卸载代码。</span><span class="sxs-lookup"><span data-stu-id="10312-161">Code can be unloaded from memory only by unloading the application domain.</span></span> <span data-ttu-id="10312-162">有关详细信息，请参阅[应用程序域和 CLR 集成安全性](../../database-engine/dev-guide/application-domains-and-clr-integration-security.md)。</span><span class="sxs-lookup"><span data-stu-id="10312-162">For more information, see [Application Domains and CLR Integration Security](../../database-engine/dev-guide/application-domains-and-clr-integration-security.md).</span></span>  
  
###### <a name="code-access-security-cas"></a><span data-ttu-id="10312-163">代码访问安全性 (CAS)</span><span class="sxs-lookup"><span data-stu-id="10312-163">Code Access Security (CAS)</span></span>  
 <span data-ttu-id="10312-164">CLR 安全系统通过给代码分配权限，提供了一种控制托管代码可以执行何种操作的方法。</span><span class="sxs-lookup"><span data-stu-id="10312-164">The CLR security system provides a way to control what kinds of operations managed code can perform by assigning permissions to code.</span></span> <span data-ttu-id="10312-165">基于代码标识（例如，程序集的签名或代码的来源）分配代码访问权限。</span><span class="sxs-lookup"><span data-stu-id="10312-165">Code access permissions are assigned based on code identity (for example, the signature of the assembly or the origin of the code).</span></span>  
  
 <span data-ttu-id="10312-166">CLR 提供了一种可由计算机管理员设置的计算机范围的策略。</span><span class="sxs-lookup"><span data-stu-id="10312-166">The CLR provides for a computer-wide policy that can be set by the computer administrator.</span></span> <span data-ttu-id="10312-167">此策略为在计算机上运行的所有托管代码定义权限授予方式。</span><span class="sxs-lookup"><span data-stu-id="10312-167">This policy defines the permission grants for any managed code running on the machine.</span></span> <span data-ttu-id="10312-168">此外，还存在可由宿主（如 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]）使用的宿主级安全策略以指定托管代码的其他限制。</span><span class="sxs-lookup"><span data-stu-id="10312-168">In addition, there is a host-level security policy that can be used by hosts such as [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to specify additional restrictions on managed code.</span></span>  
  
 <span data-ttu-id="10312-169">如果 .NET Framework 中的托管 API 公开针对由代码访问权限保护的资源的操作，该 API 在访问资源前将需要该权限。</span><span class="sxs-lookup"><span data-stu-id="10312-169">If a managed API in the .NET Framework exposes operations on resources that are protected by a code access permission, the API will demand that permission before accessing the resource.</span></span> <span data-ttu-id="10312-170">这将导致 CLR 安全系统触发对调用堆栈中的每个代码单元（程序集）的全面检查。</span><span class="sxs-lookup"><span data-stu-id="10312-170">This demand causes the CLR security system to trigger a comprehensive check of every unit of code (assembly) in the call stack.</span></span> <span data-ttu-id="10312-171">只有整个调用链具有权限时，才能授予对资源的访问权限。</span><span class="sxs-lookup"><span data-stu-id="10312-171">Only if the entire call chain has permission will access to the resource be granted.</span></span>  
  
 <span data-ttu-id="10312-172">请注意在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 的 CLR 宿主环境内不支持使用 Reflection.Emit API 动态生成托管代码。</span><span class="sxs-lookup"><span data-stu-id="10312-172">Note that the ability to generate managed code dynamically, using the Reflection.Emit API, is not supported inside the CLR-hosted environment in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="10312-173">此类代码将不具有 CAS 运行权限，因此在运行时会失败。</span><span class="sxs-lookup"><span data-stu-id="10312-173">Such code would not have the CAS permissions to run and would therefore fail at run time.</span></span> <span data-ttu-id="10312-174">有关详细信息，请参阅[CLR 集成代码访问安全性](security/clr-integration-code-access-security.md)。</span><span class="sxs-lookup"><span data-stu-id="10312-174">For more information, see [CLR Integration Code Access Security](security/clr-integration-code-access-security.md).</span></span>  
  
###### <a name="host-protection-attributes-hpas"></a><span data-ttu-id="10312-175">宿主保护属性 (HPA)</span><span class="sxs-lookup"><span data-stu-id="10312-175">Host Protection Attributes (HPAs)</span></span>  
 <span data-ttu-id="10312-176">CLR 提供一种机制，用于使用宿主 CLR 可能所需的特定属性对属于 .NET Framework 的托管 API 进行批注。</span><span class="sxs-lookup"><span data-stu-id="10312-176">The CLR provides a mechanism to annotate managed APIs that are part of the .NET Framework with certain attributes that may be of interest to a host of the CLR.</span></span> <span data-ttu-id="10312-177">这类属性的示例包括：</span><span class="sxs-lookup"><span data-stu-id="10312-177">Examples of such attributes include:</span></span>  
  
-   <span data-ttu-id="10312-178">SharedState，它指示 API 是否公开创建或管理共享状态（例如，静态类字段）的功能。</span><span class="sxs-lookup"><span data-stu-id="10312-178">SharedState, which indicates whether the API exposes the ability to create or manage shared state (for example, static class fields).</span></span>  
  
-   <span data-ttu-id="10312-179">Synchronization，它指示 API 是否公开在线程之间执行同步的功能。</span><span class="sxs-lookup"><span data-stu-id="10312-179">Synchronization, which indicates whether the API exposes the ability to perform synchronization between threads.</span></span>  
  
-   <span data-ttu-id="10312-180">ExternalProcessMgmt，它指示 API 是否公开控制主机进程的方法。</span><span class="sxs-lookup"><span data-stu-id="10312-180">ExternalProcessMgmt, which indicates whether the API exposes a way to control the host process.</span></span>  
  
 <span data-ttu-id="10312-181">在给定这些属性的基础上，宿主可指定在宿主环境下不允许的 HPA 的列表（如 SharedState 属性）。</span><span class="sxs-lookup"><span data-stu-id="10312-181">Given these attributes, the host can specify a list of HPAs, such as the SharedState attribute, that should be disallowed in the hosted environment.</span></span> <span data-ttu-id="10312-182">在这种情况下，CLR 拒绝用户代码调用某些 API，这些 API 由禁止列表中的 HPA 批注。</span><span class="sxs-lookup"><span data-stu-id="10312-182">In this case, the CLR denies attempts by user code to call APIs that are annotated by the HPAs in the prohibited list.</span></span> <span data-ttu-id="10312-183">有关详细信息，请参阅[宿主保护属性和 CLR 集成编程](../clr-integration-security-host-protection-attributes/host-protection-attributes-and-clr-integration-programming.md)。</span><span class="sxs-lookup"><span data-stu-id="10312-183">For more information, see [Host Protection Attributes and CLR Integration Programming](../clr-integration-security-host-protection-attributes/host-protection-attributes-and-clr-integration-programming.md).</span></span>  
  
## <a name="how-sql-server-and-the-clr-work-together"></a><span data-ttu-id="10312-184">SQL Server 如何与 CLR 协同工作</span><span class="sxs-lookup"><span data-stu-id="10312-184">How SQL Server and the CLR Work Together</span></span>  
 <span data-ttu-id="10312-185">本节介绍 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 如何集成 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 和 CLR 的线程化、计划、同步和内存管理模型。</span><span class="sxs-lookup"><span data-stu-id="10312-185">This section discusses how [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integrates the threading, scheduling, synchronization, and memory management models of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR.</span></span> <span data-ttu-id="10312-186">具体而言，本节将在可伸缩性、可靠性和安全性目标方面来介绍集成。</span><span class="sxs-lookup"><span data-stu-id="10312-186">In particular, this section examines the integration in light of scalability, reliability, and security goals.</span></span> <span data-ttu-id="10312-187">当 CLR 驻留在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 内部时，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 实质上是充当 CLR 的操作系统。</span><span class="sxs-lookup"><span data-stu-id="10312-187">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] essentially acts as the operating system for the CLR when it is hosted inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="10312-188">CLR 调用由 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 实现的用于线程化、计划、同步和内存管理的底层例程。</span><span class="sxs-lookup"><span data-stu-id="10312-188">The CLR calls low-level routines implemented by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for threading, scheduling, synchronization, and memory management.</span></span> <span data-ttu-id="10312-189">这些基元与 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 引擎的其余部分使用的基元相同。</span><span class="sxs-lookup"><span data-stu-id="10312-189">These are the same primitives that the rest of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] engine uses.</span></span> <span data-ttu-id="10312-190">这种方法确保了系统的可伸缩性、可靠性和安全性。</span><span class="sxs-lookup"><span data-stu-id="10312-190">This approach provides several scalability, reliability, and security benefits.</span></span>  
  
###### <a name="scalability-common-threading-scheduling-and-synchronization"></a><span data-ttu-id="10312-191">可伸缩性：公共线程化、计划和同步</span><span class="sxs-lookup"><span data-stu-id="10312-191">Scalability: Common threading, scheduling, and synchronization</span></span>  
 <span data-ttu-id="10312-192">CLR 调用 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 用于创建线程的 API，以便运行用户代码以及供自己内部使用。</span><span class="sxs-lookup"><span data-stu-id="10312-192">CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] APIs for creating threads, both for running user code and for its own internal use.</span></span> <span data-ttu-id="10312-193">为了在多个线程间同步，CLR 调用 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 同步对象。</span><span class="sxs-lookup"><span data-stu-id="10312-193">In order to synchronize between multiple threads, the CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] synchronization objects.</span></span> <span data-ttu-id="10312-194">这使得 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 计划程序在线程等待某同步对象时可以计划其他任务。</span><span class="sxs-lookup"><span data-stu-id="10312-194">This allows the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler to schedule other tasks when a thread is waiting on a synchronization object.</span></span> <span data-ttu-id="10312-195">例如，在 CLR 启动垃圾收集时，所有线程均要等待垃圾收集完成。</span><span class="sxs-lookup"><span data-stu-id="10312-195">For example, when the CLR initiates garbage collection, all of its threads wait for garbage collection to finish.</span></span> <span data-ttu-id="10312-196">因为 CLR 线程和它们要等待的同步对象对于 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 计划程序是已知的，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 可以安排运行不涉及 CLR 的其他数据库任务的线程。</span><span class="sxs-lookup"><span data-stu-id="10312-196">Because the CLR threads and the synchronization objects they are waiting on are known to the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can schedule threads that are running other database tasks not involving the CLR.</span></span> <span data-ttu-id="10312-197">这也使得 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 可以检测由 CLR 同步对象所持有的锁造成的死锁并采用传统技术消除死锁。</span><span class="sxs-lookup"><span data-stu-id="10312-197">This also enables [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to detect deadlocks that involve locks taken by CLR synchronization objects and employ traditional techniques for deadlock removal.</span></span>  
  
 <span data-ttu-id="10312-198">托管代码在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中以抢先方式运行。</span><span class="sxs-lookup"><span data-stu-id="10312-198">Managed code runs preemptively in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="10312-199">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 计划程序可以检测和停止在较长时间内仍未生成的线程。</span><span class="sxs-lookup"><span data-stu-id="10312-199">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler has the ability to detect and stop threads that have not yielded for a significant amount of time.</span></span> <span data-ttu-id="10312-200">将 CLR 线程挂钩到 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 线程这个功能暗示 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 计划程序可以标识 CLR 中“逃逸”的线程并管理其优先级。</span><span class="sxs-lookup"><span data-stu-id="10312-200">The ability to hook CLR threads to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] threads implies that the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler can identify "runaway" threads in the CLR and manage their priority.</span></span> <span data-ttu-id="10312-201">挂起此类逃逸线程并将它们放回队列中。</span><span class="sxs-lookup"><span data-stu-id="10312-201">Such runaway threads are suspended and put back in the queue.</span></span> <span data-ttu-id="10312-202">在一段规定的时间内不允许运行重复标识为逃逸线程的线程，以便执行其他工作线程。</span><span class="sxs-lookup"><span data-stu-id="10312-202">Threads that are repeatedly identified as runaway threads are not allowed to run for a given period of time so that other executing workers can run.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="10312-203">将自动生成访问数据或分配足够内存来触发垃圾收集的长时间运行的托管代码。</span><span class="sxs-lookup"><span data-stu-id="10312-203">Long-running managed code that accesses data or allocates enough memory to trigger garbage collection will yield automatically.</span></span> <span data-ttu-id="10312-204">对于不访问数据或分配足够内存来触发垃圾收集的长时间运行的托管代码，应通过调用 .NET Framework 的 System.Thread.Sleep() 函数显式生成它。</span><span class="sxs-lookup"><span data-stu-id="10312-204">Long-running managed code that does not access data or allocate enough managed memory to trigger garbage collection should explicitly yield by calling the System.Thread.Sleep() function of the .NET Framework.</span></span>  
  
###### <a name="scalability-common-memory-management"></a><span data-ttu-id="10312-205">可伸缩性：公共内存管理</span><span class="sxs-lookup"><span data-stu-id="10312-205">Scalability: Common memory management</span></span>  
 <span data-ttu-id="10312-206">CLR 调用 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 用于分配和取消分配内存的基元。</span><span class="sxs-lookup"><span data-stu-id="10312-206">The CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] primitives for allocating and de-allocating its memory.</span></span> <span data-ttu-id="10312-207">由于在系统使用的内存总量中考虑了 CLR 使用的内存，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 可以确保不超过配置的内存限制，并确保 CLR 和 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 不会彼此争用内存。</span><span class="sxs-lookup"><span data-stu-id="10312-207">Because the memory used by the CLR is accounted for in the total memory usage of the system, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can stay within its configured memory limits and ensure the CLR and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] are not competing with each other for memory.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="10312-208">在系统内存受限制时还可以拒绝 CLR 内存请求，并且在其他任务需要内存时可以请求 CLR 减少内存使用量。</span><span class="sxs-lookup"><span data-stu-id="10312-208">can also reject CLR memory requests when system memory is constrained, and ask CLR to reduce its memory use when other tasks need memory.</span></span>  
  
###### <a name="reliability-application-domains-and-unrecoverable-exceptions"></a><span data-ttu-id="10312-209">可靠性：应用程序域和无法恢复的异常</span><span class="sxs-lookup"><span data-stu-id="10312-209">Reliability: Application domains and unrecoverable exceptions</span></span>  
 <span data-ttu-id="10312-210">.NET Framework API 中的托管代码遇到严重异常（如内存不足或堆栈溢出）时，并不是总能从这类故障中恢复并确保实现的一致和正确的语义。</span><span class="sxs-lookup"><span data-stu-id="10312-210">When managed code in the .NET Framework APIs encounters critical exceptions, such as out-of-memory or stack overflow, it is not always possible to recover from such failures and ensure consistent and correct semantics for their implementation.</span></span> <span data-ttu-id="10312-211">这些 API 会引发线程中止异常来应对这类故障。</span><span class="sxs-lookup"><span data-stu-id="10312-211">These APIs raise a thread abort exception in response to these failures.</span></span>  
  
 <span data-ttu-id="10312-212">在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中驻留时，按以下方式处理这类线程中止：CLR 在发生线程中止的应用程序域中检测所有共享状态。</span><span class="sxs-lookup"><span data-stu-id="10312-212">When hosted in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], such thread aborts are handled as follows: the CLR detects any shared state in the application domain in which the thread abort occurs.</span></span> <span data-ttu-id="10312-213">CLR 通过检查同步对象的存在来做到这点。</span><span class="sxs-lookup"><span data-stu-id="10312-213">The CLR does this by checking for the presence of synchronization objects.</span></span> <span data-ttu-id="10312-214">如果应用程序域中存在共享状态，则卸载应用程序域本身。</span><span class="sxs-lookup"><span data-stu-id="10312-214">If there is shared state in the application domain, then the application domain itself is unloaded.</span></span> <span data-ttu-id="10312-215">卸载应用程序域将停止当前在该应用程序域中运行的数据库事务。</span><span class="sxs-lookup"><span data-stu-id="10312-215">The unloading of the application domain stops database transactions that are currently running in that application domain.</span></span> <span data-ttu-id="10312-216">由于共享状态的存在可能将这类严重异常的影响扩大到触发异常的用户会话之外的其他用户会话，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 和 CLR 采取了一些措施来减少共享状态出现的可能性。</span><span class="sxs-lookup"><span data-stu-id="10312-216">Because the presence of shared state can widen the impact of such critical exceptions to user sessions other than the one triggering the exception, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR have taken steps to reduce the likelihood of shared state.</span></span> <span data-ttu-id="10312-217">有关详细信息，请参阅 .NET Framework 文档。</span><span class="sxs-lookup"><span data-stu-id="10312-217">For more information, see the .NET Framework documentation.</span></span>  
  
###### <a name="security-permission-sets"></a><span data-ttu-id="10312-218">安全性：权限集</span><span class="sxs-lookup"><span data-stu-id="10312-218">Security: Permission sets</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="10312-219">允许用户指定部署到数据库中的代码的可靠性和安全性要求。</span><span class="sxs-lookup"><span data-stu-id="10312-219">allows users to specify the reliability and security requirements for code deployed into the database.</span></span> <span data-ttu-id="10312-220">当程序集上载到数据库中时，程序集作者可为该程序集指定以下三个权限集中的一个：SAFE、EXTERNAL_ACCESS 和 UNSAFE。</span><span class="sxs-lookup"><span data-stu-id="10312-220">When assemblies are uploaded into the database, the author of the assembly can specify one of three permission sets for that assembly: SAFE, EXTERNAL_ACCESS and UNSAFE.</span></span>  
  
|||||  
|-|-|-|-|  
|<span data-ttu-id="10312-221">权限集</span><span class="sxs-lookup"><span data-stu-id="10312-221">Permission set</span></span>|<span data-ttu-id="10312-222">SAFE</span><span class="sxs-lookup"><span data-stu-id="10312-222">SAFE</span></span>|<span data-ttu-id="10312-223">EXTERNAL_ACCESS</span><span class="sxs-lookup"><span data-stu-id="10312-223">EXTERNAL_ACCESS</span></span>|<span data-ttu-id="10312-224">UNSAFE</span><span class="sxs-lookup"><span data-stu-id="10312-224">UNSAFE</span></span>|  
|<span data-ttu-id="10312-225">代码访问安全性</span><span class="sxs-lookup"><span data-stu-id="10312-225">Code Access Security</span></span>|<span data-ttu-id="10312-226">仅执行</span><span class="sxs-lookup"><span data-stu-id="10312-226">Execute only</span></span>|<span data-ttu-id="10312-227">执行和访问外部资源</span><span class="sxs-lookup"><span data-stu-id="10312-227">Execute + access to external resources</span></span>|<span data-ttu-id="10312-228">非受限</span><span class="sxs-lookup"><span data-stu-id="10312-228">Unrestricted</span></span>|  
|<span data-ttu-id="10312-229">编程模型限制</span><span class="sxs-lookup"><span data-stu-id="10312-229">Programming model restrictions</span></span>|<span data-ttu-id="10312-230">是</span><span class="sxs-lookup"><span data-stu-id="10312-230">Yes</span></span>|<span data-ttu-id="10312-231">是</span><span class="sxs-lookup"><span data-stu-id="10312-231">Yes</span></span>|<span data-ttu-id="10312-232">无限制</span><span class="sxs-lookup"><span data-stu-id="10312-232">No restrictions</span></span>|  
|<span data-ttu-id="10312-233">可验证性要求</span><span class="sxs-lookup"><span data-stu-id="10312-233">Verifiability requirement</span></span>|<span data-ttu-id="10312-234">是</span><span class="sxs-lookup"><span data-stu-id="10312-234">Yes</span></span>|<span data-ttu-id="10312-235">是</span><span class="sxs-lookup"><span data-stu-id="10312-235">Yes</span></span>|<span data-ttu-id="10312-236">否</span><span class="sxs-lookup"><span data-stu-id="10312-236">No</span></span>|  
|<span data-ttu-id="10312-237">调用本机代码的能力</span><span class="sxs-lookup"><span data-stu-id="10312-237">Ability to call native code</span></span>|<span data-ttu-id="10312-238">否</span><span class="sxs-lookup"><span data-stu-id="10312-238">No</span></span>|<span data-ttu-id="10312-239">否</span><span class="sxs-lookup"><span data-stu-id="10312-239">No</span></span>|<span data-ttu-id="10312-240">是</span><span class="sxs-lookup"><span data-stu-id="10312-240">Yes</span></span>|  
  
 <span data-ttu-id="10312-241">SAFE 是最可靠和安全的模式，并且在允许的编程模型方面也具有相关的限制。</span><span class="sxs-lookup"><span data-stu-id="10312-241">SAFE is the most reliable and secure mode with associated restrictions in terms of the allowed programming model.</span></span> <span data-ttu-id="10312-242">给 SAFE 程序集授予了足够的权限，以便运行、执行计算以及访问本地数据库。</span><span class="sxs-lookup"><span data-stu-id="10312-242">SAFE assemblies are given enough permission to run, perform computations, and have access to the local database.</span></span> <span data-ttu-id="10312-243">SAFE 程序集需要具有可验证的类型安全性，并且不允许调用非托管代码。</span><span class="sxs-lookup"><span data-stu-id="10312-243">SAFE assemblies need to be verifiably type safe and are not allowed to call unmanaged code.</span></span>  
  
 <span data-ttu-id="10312-244">UNSAFE 用于仅能由数据库管理员创建的高度受信任的代码。</span><span class="sxs-lookup"><span data-stu-id="10312-244">UNSAFE is for highly trusted code that can only be created by database administrators.</span></span> <span data-ttu-id="10312-245">这种受信任代码没有代码访问安全性限制，并且可以调用非托管（本机）代码。</span><span class="sxs-lookup"><span data-stu-id="10312-245">This trusted code has no code access security restrictions, and it can call unmanaged (native) code.</span></span>  
  
 <span data-ttu-id="10312-246">EXTERNAL_ACCESS 提供了一个中间安全选项，允许代码访问数据库外部的资源，而且仍然具有与 SAFE 相同的可靠性。</span><span class="sxs-lookup"><span data-stu-id="10312-246">EXTERNAL_ACCESS provides an intermediate security option, allowing code to access resources external to the database but still having the reliability guarantees of SAFE.</span></span>  
  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="10312-247">使用宿主级 CAS 策略层设置宿主策略，该宿主策略根据存储在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 目录中的权限集授予三个权限集之一。</span><span class="sxs-lookup"><span data-stu-id="10312-247">uses the host-level CAS policy layer to set up a host policy that grants one of the three sets of permissions based on the permission set stored in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] catalogs.</span></span> <span data-ttu-id="10312-248">在数据库内运行的托管代码始终获取这些代码访问权限集中的一个。</span><span class="sxs-lookup"><span data-stu-id="10312-248">Managed code running inside the database always gets one of these code access permission sets.</span></span>  
  
### <a name="programming-model-restrictions"></a><span data-ttu-id="10312-249">编程模型限制</span><span class="sxs-lookup"><span data-stu-id="10312-249">Programming Model Restrictions</span></span>  
 <span data-ttu-id="10312-250">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中托管代码的编程模型涉及编写这样的函数、过程和类型：它们一般不需要使用跨多个调用保持的状态或在多个用户会话之间共享状态。</span><span class="sxs-lookup"><span data-stu-id="10312-250">The programming model for managed code in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] involves writing functions, procedures, and types which typically do not require the use of state held across multiple invocations or the sharing of state across multiple user sessions.</span></span> <span data-ttu-id="10312-251">而且，如前文所述，共享状态的存在可导致能够影响应用程序的可伸缩性和可靠性的严重异常。</span><span class="sxs-lookup"><span data-stu-id="10312-251">Further, as described earlier, the presence of shared state can cause critical exceptions that impact the scalability and the reliability of the application.</span></span>  
  
 <span data-ttu-id="10312-252">出于上述考虑，我们劝阻大家不要使用在 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 中使用的类的静态变量和静态数据成员。</span><span class="sxs-lookup"><span data-stu-id="10312-252">Given these considerations, we discourage the use of static variables and static data members of classes used in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="10312-253">对于 SAFE 和 EXTERNAL_ACCESS 程序集，[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 在执行 CREATE ASSEMBLY 时检查程序集的元数据，并在发现使用了静态数据成员和变量时使此类程序集的创建失败。</span><span class="sxs-lookup"><span data-stu-id="10312-253">For SAFE and EXTERNAL_ACCESS assemblies, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] examines the metadata of the assembly at CREATE ASSEMBLY time and fails the creation of such assemblies if it finds the use of static data members and variables.</span></span>  
  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="10312-254">还不允许调用使用 `SharedState`、`Synchronization` 和 `ExternalProcessMgmt` 宿主保护属性批注的 .NET Framework API。</span><span class="sxs-lookup"><span data-stu-id="10312-254">also disallows calls to .NET Framework APIs that are annotated with the `SharedState`, `Synchronization` and `ExternalProcessMgmt` host protection attributes.</span></span> <span data-ttu-id="10312-255">这将防止 SAFE 和 EXTERNAL_ACCESS 程序集调用能够启用共享状态、执行同步和影响 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 进程的完整性的任何 API。</span><span class="sxs-lookup"><span data-stu-id="10312-255">This prevents SAFE and EXTERNAL_ACCESS assemblies from calling any APIs that enable sharing state, performing synchronization, and affecting the integrity of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] process.</span></span> <span data-ttu-id="10312-256">有关详细信息，请参阅[CLR 集成编程模型限制](database-objects/clr-integration-programming-model-restrictions.md)。</span><span class="sxs-lookup"><span data-stu-id="10312-256">For more information, see [CLR Integration Programming Model Restrictions](database-objects/clr-integration-programming-model-restrictions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="10312-257">另请参阅</span><span class="sxs-lookup"><span data-stu-id="10312-257">See Also</span></span>  
 <span data-ttu-id="10312-258">[CLR 集成安全性](security/clr-integration-security.md) </span><span class="sxs-lookup"><span data-stu-id="10312-258">[CLR Integration Security](security/clr-integration-security.md) </span></span>  
 [<span data-ttu-id="10312-259">CLR 集成的性能</span><span class="sxs-lookup"><span data-stu-id="10312-259">Performance of CLR Integration</span></span>](clr-integration-architecture-performance.md)  
  
  
