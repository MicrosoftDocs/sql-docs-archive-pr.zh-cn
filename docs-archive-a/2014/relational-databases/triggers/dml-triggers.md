---
title: DML 触发器 | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- triggers [SQL Server], about triggers
- DML triggers, about DML triggers
- triggers [SQL Server]
ms.assetid: 298eafca-e01f-4707-8c29-c75546fcd6b0
author: rothja
ms.author: jroth
ms.openlocfilehash: 7fb2e5e85c9479726fe38e02721186a0723a2ec8
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87590633"
---
# <a name="dml-triggers"></a><span data-ttu-id="6efb1-102">DML 触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-102">DML Triggers</span></span>
  <span data-ttu-id="6efb1-103">DML 触发器为特殊类型的存储过程，可在发生数据操作语言 (DML) 事件时自动生效，以便影响触发器中定义的表或视图。</span><span class="sxs-lookup"><span data-stu-id="6efb1-103">DML triggers is a special type of stored procedure that automatically takes effect when a data manipulation language (DML) event takes place that affects the table or view defined in the trigger.</span></span> <span data-ttu-id="6efb1-104">DML 事件包括 INSERT、UPDATE 或 DELETE 语句。</span><span class="sxs-lookup"><span data-stu-id="6efb1-104">DML events include INSERT, UPDATE, or DELETE statements.</span></span> <span data-ttu-id="6efb1-105">DML 触发器可用于强制业务规则和数据完整性、查询其他表并包括复杂的 [!INCLUDE[tsql](../../includes/tsql-md.md)] 语句。</span><span class="sxs-lookup"><span data-stu-id="6efb1-105">DML triggers can be used to enforce business rules and data integrity, query other tables, and include complex [!INCLUDE[tsql](../../includes/tsql-md.md)] statements.</span></span> <span data-ttu-id="6efb1-106">将触发器和触发它的语句作为可在触发器内回滚的单个事务对待。</span><span class="sxs-lookup"><span data-stu-id="6efb1-106">The trigger and the statement that fires it are treated as a single transaction, which can be rolled back from within the trigger.</span></span> <span data-ttu-id="6efb1-107">如果检测到错误（例如，磁盘空间不足），则整个事务即自动回滚。</span><span class="sxs-lookup"><span data-stu-id="6efb1-107">If a severe error is detected (for example, insufficient disk space), the entire transaction automatically rolls back.</span></span>  
  
## <a name="dml-trigger-benefits"></a><span data-ttu-id="6efb1-108">DML 触发器的优点</span><span class="sxs-lookup"><span data-stu-id="6efb1-108">DML Trigger Benefits</span></span>  
 <span data-ttu-id="6efb1-109">DML 触发器类似于约束，因为可以强制实体完整性或域完整性。</span><span class="sxs-lookup"><span data-stu-id="6efb1-109">DML triggers are similar to constraints in that they can enforce entity integrity or domain integrity.</span></span> <span data-ttu-id="6efb1-110">一般情况下，实体完整性总应在最低级别上通过索引进行强制，这些索引应是 PRIMARY KEY 和 UNIQUE 约束的一部分，或者是独立于约束而创建的。</span><span class="sxs-lookup"><span data-stu-id="6efb1-110">In general, entity integrity should always be enforced at the lowest level by indexes that are part of PRIMARY KEY and UNIQUE constraints or are created independently of constraints.</span></span> <span data-ttu-id="6efb1-111">域完整性应通过 CHECK 约束进行强制，而引用完整性 (RI) 则应通过 FOREIGN KEY 约束进行强制。</span><span class="sxs-lookup"><span data-stu-id="6efb1-111">Domain integrity should be enforced through CHECK constraints, and referential integrity (RI) should be enforced through FOREIGN KEY constraints.</span></span> <span data-ttu-id="6efb1-112">当约束支持的功能无法满足应用程序的功能要求时，DML 触发器非常有用。</span><span class="sxs-lookup"><span data-stu-id="6efb1-112">DML triggers are most useful when the features supported by constraints cannot meet the functional needs of the application.</span></span>  
  
 <span data-ttu-id="6efb1-113">下面的列表比较 DML 触发器和约束，并在 DML 触发器优于约束时进行标识。</span><span class="sxs-lookup"><span data-stu-id="6efb1-113">The following list compares DML triggers with constraints and identifies when DML triggers have benefits over .</span></span>  
  
-   <span data-ttu-id="6efb1-114">DML 触发器可以将更改通过级联方式传播给数据库中的相关表；不过，使用级联引用完整性约束可以更有效地执行这些更改。</span><span class="sxs-lookup"><span data-stu-id="6efb1-114">DML triggers can cascade changes through related tables in the database; however, these changes can be executed more efficiently using cascading referential integrity constraints.</span></span> <span data-ttu-id="6efb1-115">除非 REFERENCES 子句定义了级联引用操作，否则 FOREIGN KEY 约束只能用与另一列中的值完全匹配的值来验证列值。</span><span class="sxs-lookup"><span data-stu-id="6efb1-115">FOREIGN KEY constraints can validate a column value only with an exact match to a value in another column, unless the REFERENCES clause defines a cascading referential action.</span></span>  
  
-   <span data-ttu-id="6efb1-116">DML 触发器可以防止恶意或错误的 INSERT、UPDATE 以及 DELETE 操作，并强制执行比 CHECK 约束定义的限制更为复杂的其他限制。</span><span class="sxs-lookup"><span data-stu-id="6efb1-116">They can guard against malicious or incorrect INSERT, UPDATE, and DELETE operations and enforce other restrictions that are more complex than those defined with CHECK constraints.</span></span>  
  
     <span data-ttu-id="6efb1-117">与 CHECK 约束不同，DML 触发器可以引用其他表中的列。</span><span class="sxs-lookup"><span data-stu-id="6efb1-117">Unlike CHECK constraints, DML triggers can reference columns in other tables.</span></span> <span data-ttu-id="6efb1-118">例如，触发器可以使用另一个表中的 SELECT 比较插入或更新的数据，以及执行其他操作，如修改数据或显示用户定义错误信息。</span><span class="sxs-lookup"><span data-stu-id="6efb1-118">For example, a trigger can use a SELECT from another table to compare to the inserted or updated data and to perform additional actions, such as modify the data or display a user-defined error message.</span></span>  
  
-   <span data-ttu-id="6efb1-119">DML 触发器可以评估数据修改前后表的状态，并根据该差异采取措施。</span><span class="sxs-lookup"><span data-stu-id="6efb1-119">They can evaluate the state of a table before and after a data modification and take actions based on that difference.</span></span>  
  
-   <span data-ttu-id="6efb1-120">一个表中的多个同类 DML 触发器（INSERT、UPDATE 或 DELETE）允许采取多个不同的操作来响应同一个修改语句。</span><span class="sxs-lookup"><span data-stu-id="6efb1-120">Multiple DML triggers of the same type (INSERT, UPDATE, or DELETE) on a table allow multiple, different actions to take place in response to the same modification statement.</span></span>  
  
-   <span data-ttu-id="6efb1-121">约束只能通过标准化的系统错误消息来传递错误消息。</span><span class="sxs-lookup"><span data-stu-id="6efb1-121">Constraints can communicate about errors only through standardized system error messages.</span></span> <span data-ttu-id="6efb1-122">如果应用程序需要（或能受益于）使用自定义消息和较为复杂的错误处理，则必须使用触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-122">If your application requires, or can benefit from, customized messages and more complex error handling, you must use a trigger.</span></span>  
  
-   <span data-ttu-id="6efb1-123">DML 触发器可以禁止或回滚违反引用完整性的更改，从而取消所尝试的数据修改。</span><span class="sxs-lookup"><span data-stu-id="6efb1-123">DML triggers can disallow or roll back changes that violate referential integrity, thereby canceling the attempted data modification.</span></span> <span data-ttu-id="6efb1-124">当更改外键且新值与其主键不匹配时，这样的触发器将生效。</span><span class="sxs-lookup"><span data-stu-id="6efb1-124">Such a trigger might go into effect when you change a foreign key and the new value does not match its primary key.</span></span> <span data-ttu-id="6efb1-125">但是，FOREIGN KEY 约束通常用于此目的。</span><span class="sxs-lookup"><span data-stu-id="6efb1-125">However, FOREIGN KEY constraints are usually used for this purpose.</span></span>  
  
-   <span data-ttu-id="6efb1-126">如果触发器表上存在约束，则在 INSTEAD OF 触发器执行后但在 AFTER 触发器执行前检查这些约束。</span><span class="sxs-lookup"><span data-stu-id="6efb1-126">If constraints exist on the trigger table, they are checked after the INSTEAD OF trigger execution but prior to the AFTER trigger execution.</span></span> <span data-ttu-id="6efb1-127">如果违反了约束，则回滚 INSTEAD OF 触发器操作并且不执行 AFTER 触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-127">If the constraints are violated, the INSTEAD OF trigger actions are rolled back and the AFTER trigger is not executed.</span></span>  
  
## <a name="types-of-dml-triggers"></a><span data-ttu-id="6efb1-128">DML 触发器的类型</span><span class="sxs-lookup"><span data-stu-id="6efb1-128">Types of DML Triggers</span></span>  
 <span data-ttu-id="6efb1-129">AFTER 触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-129">AFTER trigger</span></span>  
 <span data-ttu-id="6efb1-130">在执行 INSERT、UPDATE、MERGE 或 DELETE 语句的操作之后执行 AFTER 触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-130">AFTER triggers are executed after the action of the INSERT, UPDATE, MERGE, or DELETE statement is performed.</span></span> <span data-ttu-id="6efb1-131">如果违反了约束，则永远不会执行 AFTER 触发器；因此，这些触发器不能用于任何可能防止违反约束的处理。</span><span class="sxs-lookup"><span data-stu-id="6efb1-131">AFTER triggers are never executed if a constraint violation occurs; therefore, these triggers cannot be used for any processing that might prevent constraint violations.</span></span> <span data-ttu-id="6efb1-132">对于在 MERGE 语句中指定的每个 INSERT、UPDATE 或 DELETE 操作，将为每个 DML 操作触发相应的触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-132">For every INSERT, UPDATE, or DELETE action specified in a MERGE statement, the corresponding trigger is fired for each DML operation.</span></span>  
  
 <span data-ttu-id="6efb1-133">INSTEAD OF 触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-133">INSTEAD OF trigger</span></span>  
 <span data-ttu-id="6efb1-134">INSTEAD OF 触发器替代下列触发语句的标准操作。</span><span class="sxs-lookup"><span data-stu-id="6efb1-134">INSTEAD OF triggers override the standard actions of the triggering statement.</span></span> <span data-ttu-id="6efb1-135">因此，触发器可用于对一个或多个列执行错误或值检查，然后在插入、更新或删除行之前执行其他操作。</span><span class="sxs-lookup"><span data-stu-id="6efb1-135">Therefore, they can be used to perform error or value checking on one or more columns and the perform additional actions before insert, updating or deleting the row or rows.</span></span> <span data-ttu-id="6efb1-136">例如，当在工资表中小时工资列的更新值超过指定值时，可以将触发器定义为产生错误消息并回滚该事务，或在将记录插入工资表中之前将新记录插入到审核记录。</span><span class="sxs-lookup"><span data-stu-id="6efb1-136">For example, when the value being updated in an hourly wage column in a payroll table exceeds a specified value, a trigger can be defined to either produce an error message and roll back the transaction, or insert a new record into an audit trail before inserting the record into the payroll table.</span></span> <span data-ttu-id="6efb1-137">INSTEAD OF 触发器的主要优点是可以使不能更新的视图支持更新。</span><span class="sxs-lookup"><span data-stu-id="6efb1-137">The primary advantage of INSTEAD OF triggers is that they enable views that would not be updatable to support updates.</span></span> <span data-ttu-id="6efb1-138">例如，基于多个基表的视图必须使用 INSTEAD OF 触发器来支持引用多个表中数据的插入、更新和删除操作。</span><span class="sxs-lookup"><span data-stu-id="6efb1-138">For example, a view based on multiple base tables must use an INSTEAD OF trigger to support inserts, updates, and deletes that reference data in more than one table.</span></span> <span data-ttu-id="6efb1-139">INSTEAD OF 触发器的另一个优点是使您得以编写这样的逻辑代码：在允许批处理的其他部分成功的同时拒绝批处理中的某些部分。</span><span class="sxs-lookup"><span data-stu-id="6efb1-139">Another advantage of INSTEAD OF triggers is that they enable you to code logic that can reject parts of a batch while letting other parts of a batch to succeed.</span></span>  
  
 <span data-ttu-id="6efb1-140">下表对 AFTER 触发器和 INSTEAD OF 触发器的功能进行了比较。</span><span class="sxs-lookup"><span data-stu-id="6efb1-140">This table compares the functionality of the AFTER and INSTEAD OF triggers.</span></span>  
  
|<span data-ttu-id="6efb1-141">函数</span><span class="sxs-lookup"><span data-stu-id="6efb1-141">Function</span></span>|<span data-ttu-id="6efb1-142">AFTER 触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-142">AFTER trigger</span></span>|<span data-ttu-id="6efb1-143">INSTEAD OF 触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-143">INSTEAD OF trigger</span></span>|  
|--------------|-------------------|------------------------|  
|<span data-ttu-id="6efb1-144">适用范围</span><span class="sxs-lookup"><span data-stu-id="6efb1-144">Applicability</span></span>|<span data-ttu-id="6efb1-145">表</span><span class="sxs-lookup"><span data-stu-id="6efb1-145">Tables</span></span>|<span data-ttu-id="6efb1-146">表和视图</span><span class="sxs-lookup"><span data-stu-id="6efb1-146">Tables and views</span></span>|  
|<span data-ttu-id="6efb1-147">每个表或视图包含触发器的数量</span><span class="sxs-lookup"><span data-stu-id="6efb1-147">Quantity per table or view</span></span>|<span data-ttu-id="6efb1-148">每个触发操作（UPDATE、DELETE 和 INSERT）包含多个触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-148">Multiple per triggering action (UPDATE, DELETE, and INSERT)</span></span>|<span data-ttu-id="6efb1-149">每个触发操作（UPDATE、DELETE 和 INSERT）包含一个触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-149">One per triggering action (UPDATE, DELETE, and INSERT)</span></span>|  
|<span data-ttu-id="6efb1-150">级联引用</span><span class="sxs-lookup"><span data-stu-id="6efb1-150">Cascading references</span></span>|<span data-ttu-id="6efb1-151">无任何限制条件</span><span class="sxs-lookup"><span data-stu-id="6efb1-151">No restrictions apply</span></span>|<span data-ttu-id="6efb1-152">不允许在作为级联引用完整性约束目标的表上使用 INSTEAD OF UPDATE 和 DELETE 触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-152">INSTEAD OF UPDATE and DELETE triggers are not allowed on tables that are targets of cascaded referential integrity constraints.</span></span>|  
|<span data-ttu-id="6efb1-153">执行</span><span class="sxs-lookup"><span data-stu-id="6efb1-153">Execution</span></span>|<span data-ttu-id="6efb1-154">晚于：</span><span class="sxs-lookup"><span data-stu-id="6efb1-154">After:</span></span><br /><br /> <span data-ttu-id="6efb1-155">约束处理</span><span class="sxs-lookup"><span data-stu-id="6efb1-155">Constraint processing</span></span><br /><span data-ttu-id="6efb1-156">声明性引用操作</span><span class="sxs-lookup"><span data-stu-id="6efb1-156">Declarative referential actions</span></span><br /><span data-ttu-id="6efb1-157">创建**插入的** 和 **删除的** 表</span><span class="sxs-lookup"><span data-stu-id="6efb1-157">**inserted** and **deleted** tables creation</span></span><br /><span data-ttu-id="6efb1-158">触发操作</span><span class="sxs-lookup"><span data-stu-id="6efb1-158">The triggering action</span></span>|<span data-ttu-id="6efb1-159">之前：约束处理</span><span class="sxs-lookup"><span data-stu-id="6efb1-159">Before: Constraint processing</span></span><br /><br /> <span data-ttu-id="6efb1-160">代替：触发操作</span><span class="sxs-lookup"><span data-stu-id="6efb1-160">In place of:  The triggering action</span></span><br /><br /> <span data-ttu-id="6efb1-161">之后：创建  **插入的** 和 **删除的** 表</span><span class="sxs-lookup"><span data-stu-id="6efb1-161">After:  **inserted** and **deleted** tables creation</span></span>|  
|<span data-ttu-id="6efb1-162">执行顺序</span><span class="sxs-lookup"><span data-stu-id="6efb1-162">Order of execution</span></span>|<span data-ttu-id="6efb1-163">可指定第一个和最后一个执行</span><span class="sxs-lookup"><span data-stu-id="6efb1-163">First and last execution may be specified</span></span>|<span data-ttu-id="6efb1-164">不适用</span><span class="sxs-lookup"><span data-stu-id="6efb1-164">Not applicable</span></span>|  
|<span data-ttu-id="6efb1-165">`varchar(max)``nvarchar(max)` `varbinary(max)` **插入**和**删除**的表中的、和列引用</span><span class="sxs-lookup"><span data-stu-id="6efb1-165">`varchar(max)`, `nvarchar(max)`, and `varbinary(max)` column references in **inserted** and **deleted** tables</span></span>|<span data-ttu-id="6efb1-166">允许</span><span class="sxs-lookup"><span data-stu-id="6efb1-166">Allowed</span></span>|<span data-ttu-id="6efb1-167">允许</span><span class="sxs-lookup"><span data-stu-id="6efb1-167">Allowed</span></span>|  
|<span data-ttu-id="6efb1-168">`text``ntext` `image` **插入**和**删除**的表中的、和列引用</span><span class="sxs-lookup"><span data-stu-id="6efb1-168">`text`, `ntext`, and `image` column references in **inserted** and **deleted** tables</span></span>|<span data-ttu-id="6efb1-169">不允许</span><span class="sxs-lookup"><span data-stu-id="6efb1-169">Not allowed</span></span>|<span data-ttu-id="6efb1-170">允许</span><span class="sxs-lookup"><span data-stu-id="6efb1-170">Allowed</span></span>|  
  
 <span data-ttu-id="6efb1-171">CLR 触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-171">CLR Triggers</span></span>  
 <span data-ttu-id="6efb1-172">CLR 触发器可以是 AFTER 触发器或 INSTEAD OF 触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-172">A CLR Trigger can be either an AFTER or INSTEAD OF trigger.</span></span> <span data-ttu-id="6efb1-173">CLR 触发器还可以是 DDL 触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-173">A CLR trigger can also be a DDL trigger.</span></span> <span data-ttu-id="6efb1-174">CLR 触发器将执行在托管代码（在 .NET Framework 中创建并在 [!INCLUDE[tsql](../../includes/tsql-md.md)] 中上载的程序集的成员）中编写的方法，而不用执行 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]存储过程。</span><span class="sxs-lookup"><span data-stu-id="6efb1-174">Instead of executing a [!INCLUDE[tsql](../../includes/tsql-md.md)] stored procedure, a CLR trigger executes one or more methods written in managed code that are members of an assembly created in the .NET Framework and uploaded in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="6efb1-175">Related Tasks</span><span class="sxs-lookup"><span data-stu-id="6efb1-175">Related Tasks</span></span>  
  
|<span data-ttu-id="6efb1-176">任务</span><span class="sxs-lookup"><span data-stu-id="6efb1-176">Task</span></span>|<span data-ttu-id="6efb1-177">主题</span><span class="sxs-lookup"><span data-stu-id="6efb1-177">Topic</span></span>|  
|----------|-----------|  
|<span data-ttu-id="6efb1-178">说明如何创建 DML 触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-178">Describes how to create a DML trigger.</span></span>|[<span data-ttu-id="6efb1-179">创建 DML 触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-179">Create DML Triggers</span></span>](create-dml-triggers.md)|  
|<span data-ttu-id="6efb1-180">说明如何创建 CLR 触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-180">Describes how to create a CLR trigger.</span></span>|[<span data-ttu-id="6efb1-181">创建 CLR 触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-181">Create CLR Triggers</span></span>](create-clr-triggers.md)|  
|<span data-ttu-id="6efb1-182">说明如何创建 DML 触发器，以处理单行和多行数据修改。</span><span class="sxs-lookup"><span data-stu-id="6efb1-182">Describes how to create a DML trigger to handle both single-row and multi-row data modifications.</span></span>|[<span data-ttu-id="6efb1-183">创建 DML 触发器以处理多行数据</span><span class="sxs-lookup"><span data-stu-id="6efb1-183">Create DML Triggers to Handle Multiple Rows of Data</span></span>](create-dml-triggers-to-handle-multiple-rows-of-data.md)|  
|<span data-ttu-id="6efb1-184">说明如何嵌套触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-184">Describes how to nest triggers.</span></span>|[<span data-ttu-id="6efb1-185">创建嵌套触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-185">Create Nested Triggers</span></span>](create-nested-triggers.md)|  
|<span data-ttu-id="6efb1-186">说明如何指定激发 AFTER 触发器的顺序。</span><span class="sxs-lookup"><span data-stu-id="6efb1-186">Describes how to specify the order in which AFTER triggers are fired.</span></span>|[<span data-ttu-id="6efb1-187">指定第一个和最后一个触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-187">Specify First and Last Triggers</span></span>](specify-first-and-last-triggers.md)|  
|<span data-ttu-id="6efb1-188">说明如何在触发器代码中使用特殊的插入和删除表。</span><span class="sxs-lookup"><span data-stu-id="6efb1-188">Describes how to use the special inserted and delete tables in trigger code.</span></span>|[<span data-ttu-id="6efb1-189">使用插入的和删除的表</span><span class="sxs-lookup"><span data-stu-id="6efb1-189">Use the inserted and deleted Tables</span></span>](use-the-inserted-and-deleted-tables.md)|  
|<span data-ttu-id="6efb1-190">说明如何修改或重命名 DML 触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-190">Describes how to modify or rename a DML trigger.</span></span>|[<span data-ttu-id="6efb1-191">修改或重命名 DML 触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-191">Modify or Rename DML Triggers</span></span>](modify-or-rename-dml-triggers.md)|  
|<span data-ttu-id="6efb1-192">说明如何查看有关 DML 触发器的信息。</span><span class="sxs-lookup"><span data-stu-id="6efb1-192">Describes how to view information about DML triggers.</span></span>|[<span data-ttu-id="6efb1-193">获取有关 DML 触发器的信息</span><span class="sxs-lookup"><span data-stu-id="6efb1-193">Get Information About DML Triggers</span></span>](get-information-about-dml-triggers.md)|  
|<span data-ttu-id="6efb1-194">说明如何删除或禁用 DML 触发器。</span><span class="sxs-lookup"><span data-stu-id="6efb1-194">Describes how to delete or disable DML triggers.</span></span>|[<span data-ttu-id="6efb1-195">删除或禁用 DML 触发器</span><span class="sxs-lookup"><span data-stu-id="6efb1-195">Delete or Disable DML Triggers</span></span>](delete-or-disable-dml-triggers.md)|  
|<span data-ttu-id="6efb1-196">说明如何管理触发器安全性。</span><span class="sxs-lookup"><span data-stu-id="6efb1-196">Describes how to manage trigger security.</span></span>|[<span data-ttu-id="6efb1-197">管理触发器安全性</span><span class="sxs-lookup"><span data-stu-id="6efb1-197">Manage Trigger Security</span></span>](manage-trigger-security.md)|  
  
## <a name="see-also"></a><span data-ttu-id="6efb1-198">另请参阅</span><span class="sxs-lookup"><span data-stu-id="6efb1-198">See Also</span></span>  
 <span data-ttu-id="6efb1-199">[CREATE TRIGGER (Transact-SQL)](/sql/t-sql/statements/create-trigger-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="6efb1-199">[CREATE TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-trigger-transact-sql) </span></span>  
 <span data-ttu-id="6efb1-200">[ALTER TRIGGER (Transact-SQL)](/sql/t-sql/statements/alter-trigger-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="6efb1-200">[ALTER TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-trigger-transact-sql) </span></span>  
 <span data-ttu-id="6efb1-201">[DROP TRIGGER (Transact-SQL)](/sql/t-sql/statements/drop-trigger-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="6efb1-201">[DROP TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-trigger-transact-sql) </span></span>  
 <span data-ttu-id="6efb1-202">[DISABLE TRIGGER (Transact-SQL)](/sql/t-sql/statements/disable-trigger-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="6efb1-202">[DISABLE TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/disable-trigger-transact-sql) </span></span>  
 [<span data-ttu-id="6efb1-203">触发器函数 (Transact-SQL)</span><span class="sxs-lookup"><span data-stu-id="6efb1-203">Trigger Functions &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/functions/trigger-functions-transact-sql)  
  
  
