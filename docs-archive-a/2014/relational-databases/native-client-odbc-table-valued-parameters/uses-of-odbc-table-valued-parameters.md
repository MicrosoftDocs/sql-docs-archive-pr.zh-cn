---
title: ODBC 表值参数的使用 |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- table-valued parameters (ODBC), scenarios
- ODBC, table-valued parameters
ms.assetid: f1b73932-4570-4a8a-baa0-0f229d9c32ee
author: rothja
ms.author: jroth
ms.openlocfilehash: 2b128246f7c4ed9a9cec5e28698c743877f9873d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87693281"
---
# <a name="uses-of-odbc-table-valued-parameters"></a><span data-ttu-id="30359-102">ODBC 表值参数的用法</span><span class="sxs-lookup"><span data-stu-id="30359-102">Uses of ODBC Table-Valued Parameters</span></span>
  <span data-ttu-id="30359-103">本主题介绍将表值参数用于 ODBC 时的主要用户情况：</span><span class="sxs-lookup"><span data-stu-id="30359-103">This topic discusses the primary user scenarios for using table-valued parameters with ODBC:</span></span>  
  
-   <span data-ttu-id="30359-104">完全绑定多行缓冲区情况下的表值参数（在所有值都位于内存中时将数据作为 TVP 发送）</span><span class="sxs-lookup"><span data-stu-id="30359-104">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
  
-   <span data-ttu-id="30359-105">行流式处理情况下的表值参数（使用执行时数据将数据作为 TVP 发送）</span><span class="sxs-lookup"><span data-stu-id="30359-105">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
  
-   <span data-ttu-id="30359-106">从系统目录中检索表值参数元数据</span><span class="sxs-lookup"><span data-stu-id="30359-106">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
  
-   <span data-ttu-id="30359-107">检索准备的语句的表值参数元数据</span><span class="sxs-lookup"><span data-stu-id="30359-107">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
  
## <a name="table-valued-parameter-with-fully-bound-multirow-buffers-send-data-as-a-tvp-with-all-values-in-memory"></a><span data-ttu-id="30359-108">完全绑定多行缓冲区情况下的表值参数（在所有值都位于内存中时将数据作为 TVP 发送）</span><span class="sxs-lookup"><span data-stu-id="30359-108">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
 <span data-ttu-id="30359-109">用于完全绑定多行缓冲区时，所有参数值都位于内存中。</span><span class="sxs-lookup"><span data-stu-id="30359-109">When used with fully bound multirow buffers, all parameter values are available in memory.</span></span> <span data-ttu-id="30359-110">这是 OLTP 事务（举例来说）的典型情况，在这种情况下，可以将表值参数封装到单个存储过程中。</span><span class="sxs-lookup"><span data-stu-id="30359-110">This is typical, for example, of an OLTP transaction, in which table-valued parameters can be packaged into a single stored procedure.</span></span> <span data-ttu-id="30359-111">如果不使用表值参数，这通常需要动态生成复杂的多语句批处理，或者执行多个针对服务器的调用。</span><span class="sxs-lookup"><span data-stu-id="30359-111">Without table-valued parameters, this would involve either generating a complex multi-statement batch dynamically, or making multiple calls to the server.</span></span>  
  
 <span data-ttu-id="30359-112">表值参数本身通过使用[SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328)以及其他参数进行绑定。</span><span class="sxs-lookup"><span data-stu-id="30359-112">The table-valued parameter itself is bound by using [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) along with the other parameters.</span></span> <span data-ttu-id="30359-113">绑定所有参数后，应用程序将在每个表值参数上设置参数焦点属性 SQL_SOPT_SS_PARAM_FOCUS，并对表值参数的列调用 SQLBindParameter。</span><span class="sxs-lookup"><span data-stu-id="30359-113">After all parameters have been bound, the application sets the parameter focus attribute, SQL_SOPT_SS_PARAM_FOCUS, on each table-valued parameter and calls SQLBindParameter for the columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="30359-114">表值参数的服务器类型是特定于 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 的新增类型 SQL_SS_TABLE。</span><span class="sxs-lookup"><span data-stu-id="30359-114">The server type for a table-valued parameter is a new [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-specific type, SQL_SS_TABLE.</span></span> <span data-ttu-id="30359-115">SQL_SS_TABLE 的绑定 C 类型必须始终为 SQL_C_DEFAULT。</span><span class="sxs-lookup"><span data-stu-id="30359-115">The binding C type for SQL_SS_TABLE must always be SQL_C_DEFAULT.</span></span> <span data-ttu-id="30359-116">不为表值参数绑定参数传输任何数据；该参数用于传递表元数据，并且控制如何传递表值参数各构成列中的数据。</span><span class="sxs-lookup"><span data-stu-id="30359-116">No data is transferred for the table-valued parameter bound parameter; it is used to pass table metadata and to control how to pass data in the constituent columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="30359-117">表值参数的长度设置为要发送到服务器的行数。</span><span class="sxs-lookup"><span data-stu-id="30359-117">The length of the table-valued parameter is set to the number of rows being sent to the server.</span></span> <span data-ttu-id="30359-118">表值参数的 SQLBindParameter 的*ColumnSize*参数指定可以发送的最大行数;这是列缓冲区的数组大小。</span><span class="sxs-lookup"><span data-stu-id="30359-118">The *ColumnSize* parameter of SQLBindParameter for a table-valued parameter specifies the maximum number of rows that can be sent; this is the array size of the column buffers.</span></span> <span data-ttu-id="30359-119">*ParameterValuePtr*是 SQLBindParameter 中表值参数的参数缓冲区。</span><span class="sxs-lookup"><span data-stu-id="30359-119">*ParameterValuePtr* is the parameter buffer,for a table-valued parameter in SQLBindParameter.</span></span> <span data-ttu-id="30359-120">*ParameterValuePtr*及其关联的*BufferLength*用于在需要时传递表值参数的类型名称。</span><span class="sxs-lookup"><span data-stu-id="30359-120">*ParameterValuePtr* and its associated *BufferLength* are used to pass the type name of the table-valued parameter when required.</span></span> <span data-ttu-id="30359-121">类型名称不是存储过程调用必需的，但却是 SQL 语句所必需的。</span><span class="sxs-lookup"><span data-stu-id="30359-121">The type name is not required for stored procedure calls, but it is required for SQL statements.</span></span>  
  
 <span data-ttu-id="30359-122">如果在对 SQLBindParameter 的调用上指定了表值参数类型名称，则它必须始终指定为 Unicode 值，即使是在作为 ANSI 应用程序生成的应用程序中。</span><span class="sxs-lookup"><span data-stu-id="30359-122">When a table-valued parameter type name is specified on a call to SQLBindParameter, it must always be specified as a Unicode value, even in applications that are built as ANSI applications.</span></span> <span data-ttu-id="30359-123">使用 SQLSetDescField 指定表值参数类型名称时，可以使用符合生成应用程序的方式的文本。</span><span class="sxs-lookup"><span data-stu-id="30359-123">When you specify a table-valued parameter type name by using SQLSetDescField, you can use a literal that conforms to the way the application is built.</span></span> <span data-ttu-id="30359-124">ODBC 驱动程序管理器将执行任何所需的 Unicode 转换。</span><span class="sxs-lookup"><span data-stu-id="30359-124">The ODBC Driver Manager will perform any required Unicode conversion.</span></span>  
  
 <span data-ttu-id="30359-125">可以通过使用 SQLGetDescRec、SQLSetDescRec、SQLGetDescField 和 SQLSetDescField，单独并显式操作表值参数和表值参数列的元数据。</span><span class="sxs-lookup"><span data-stu-id="30359-125">Metadata for table-valued parameters and table-valued parameter columns can be manipulated individually and explicitly by using SQLGetDescRec, SQLSetDescRec, SQLGetDescField, and SQLSetDescField.</span></span> <span data-ttu-id="30359-126">但在大多数情况下，重载 SQLBindParameter 通常更方便，无需显式说明符访问。</span><span class="sxs-lookup"><span data-stu-id="30359-126">However, overloading SQLBindParameter is usually more convenient and does not require explicit descriptor access in most cases.</span></span> <span data-ttu-id="30359-127">此方法与其他数据类型的 SQLBindParameter 的定义一致，不同之处在于对于表值参数，受影响的描述符字段略有不同。</span><span class="sxs-lookup"><span data-stu-id="30359-127">This approach is consistent with the definition of SQLBindParameter for other data types, except that for a table-valued parameter the affected descriptor fields are slightly different.</span></span>  
  
 <span data-ttu-id="30359-128">有时，应用程序将表值参数用于动态 SQL，此时必须提供该表值参数的类型名称。</span><span class="sxs-lookup"><span data-stu-id="30359-128">Sometimes, an application uses a table-valued parameter with dynamic SQL and the type name of the table-valued parameter must be supplied.</span></span> <span data-ttu-id="30359-129">如果是这种情况，并且未在连接的当前默认架构中定义表值参数，则必须使用 SQLSetDescField 设置 SQL_CA_SS_TYPE_CATALOG_NAME 和 SQL_CA_SS_TYPE_SCHEMA_NAME。</span><span class="sxs-lookup"><span data-stu-id="30359-129">If this is the case and the table-valued parameter is not defined in the current default schema for the connection, SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME must be set by using SQLSetDescField.</span></span> <span data-ttu-id="30359-130">由于表类型定义和表值参数必须位于同一数据库中，在应用程序使用表值参数时不能设置 SQL_CA_SS_TYPE_CATALOG_NAME。</span><span class="sxs-lookup"><span data-stu-id="30359-130">Because table type definitions and table-valued parameters must be in the same database, SQL_CA_SS_TYPE_CATALOG_NAME must not be set if the application uses table-valued parameters.</span></span> <span data-ttu-id="30359-131">否则，SQLSetDescField 将报告错误。</span><span class="sxs-lookup"><span data-stu-id="30359-131">Otherwise, SQLSetDescField will report an error.</span></span>  
  
 <span data-ttu-id="30359-132">此方案的示例代码位于在 `demo_fixed_TVP_binding` [ODBC&#41;&#40;使用表值参数](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)的过程中。</span><span class="sxs-lookup"><span data-stu-id="30359-132">Sample code for this scenario is in the procedure `demo_fixed_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="table-valued-parameter-with-row-streaming-send-data-as-a-tvp-using-data-at-execution"></a><span data-ttu-id="30359-133">行流式处理情况下的表值参数（使用执行时数据将数据作为 TVP 发送）</span><span class="sxs-lookup"><span data-stu-id="30359-133">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
 <span data-ttu-id="30359-134">在此情况下，应用程序在驱动程序请求行时向其提供行，并且这些行流向服务器。</span><span class="sxs-lookup"><span data-stu-id="30359-134">In this scenario, the application supplies rows to the driver as it requests them and they are streamed to the server.</span></span> <span data-ttu-id="30359-135">这样就无需将所有行缓存在内存中。</span><span class="sxs-lookup"><span data-stu-id="30359-135">This avoids having to buffer all rows in memory.</span></span> <span data-ttu-id="30359-136">这是大容量插入/更新时的典型情况。</span><span class="sxs-lookup"><span data-stu-id="30359-136">This is representative of bulk insert/update scenarios.</span></span> <span data-ttu-id="30359-137">表值参数提供了介于参数数组和大容量复制之间的某个性能点。</span><span class="sxs-lookup"><span data-stu-id="30359-137">Table-valued parameters provide a performance point somewhere between parameter arrays and bulk copy.</span></span> <span data-ttu-id="30359-138">也就是说：表值参数可以像参数数组那样易于编程，但它们在服务器端提供更高的灵活性。</span><span class="sxs-lookup"><span data-stu-id="30359-138">That is, table-valued parameters are about as easy to program as parameter arrays, but they provide greater flexibility at the server.</span></span>  
  
 <span data-ttu-id="30359-139">表值参数及其列按上一节“完全绑定多行缓冲区情况下的表值参数”所述进行绑定，但是表值参数本身的长度指示器设置为 SQL_DATA_AT_EXEC。</span><span class="sxs-lookup"><span data-stu-id="30359-139">The table-valued parameter and its columns are bound as discussed in the previous section, Table-Valued Parameter with Fully Bound Multirow Buffers, but the length indicator of the table-valued parameter itself is set to SQL_DATA_AT_EXEC.</span></span> <span data-ttu-id="30359-140">驱动程序以通常的方式对 SQLExecute 或 SQLExecuteDirect 进行响应，这是执行时数据参数的方式，即通过返回 SQL_NEED_DATA。</span><span class="sxs-lookup"><span data-stu-id="30359-140">The driver responds to SQLExecute or SQLExecuteDirect in the usual way for data-at-execution parameters-that is, by returning SQL_NEED_DATA.</span></span> <span data-ttu-id="30359-141">当驱动程序准备好接收表值参数的数据时，SQLParamData 将返回 SQLBindParameter 中*ParameterValuePtr*的值。</span><span class="sxs-lookup"><span data-stu-id="30359-141">When the driver is ready to accept data for a table-valued parameter, SQLParamData returns the value of *ParameterValuePtr* in SQLBindParameter.</span></span>  
  
 <span data-ttu-id="30359-142">应用程序将 SQLPutData 用于表值参数，以指示表值参数构成列的数据可用性。</span><span class="sxs-lookup"><span data-stu-id="30359-142">An application uses SQLPutData for a table-valued parameter to indicate the availability of data for table-valued parameter constituent columns.</span></span> <span data-ttu-id="30359-143">当为表值参数调用 SQLPutData 时， *DataPtr*必须始终为 null，并且*StrLen_or_Ind*必须为0或小于或等于 (*ColumnSize*参数为 SQLBindParameter) 指定的数组值的数组大小。</span><span class="sxs-lookup"><span data-stu-id="30359-143">When SQLPutData is called for a table-valued parameter, *DataPtr* must always be null and *StrLen_or_Ind* must be either 0 or a number less than or equal to the array size specified for table-valued parameter buffers (the *ColumnSize* parameter of SQLBindParameter).</span></span> <span data-ttu-id="30359-144">0 表示表值参数没有更多的行，驱动程序将继续处理下一个实际过程参数。</span><span class="sxs-lookup"><span data-stu-id="30359-144">0 signifies that there are no more rows for the table-valued parameter, and the driver will proceed to process to the next actual procedure parameter.</span></span> <span data-ttu-id="30359-145">当*StrLen_or_Ind*不为0时，驱动程序将以与非表值参数绑定参数相同的方式处理表值参数构成列：每个表值参数列可以指定其实际数据长度（SQL_NULL_DATA），也可以在执行时通过其长度/指示器缓冲区指定数据。</span><span class="sxs-lookup"><span data-stu-id="30359-145">When *StrLen_or_Ind* is not 0, the driver will process the table-valued parameter constituent columns in the same way as non-table-valued parameter bound parameters: Each table-valued parameter column can specify its actual data length, SQL_NULL_DATA, or it can specify data at execution via its length/indicator buffer.</span></span> <span data-ttu-id="30359-146">如果要将字符或二进制值传递到块中，可以通过重复调用 SQLPutData 来传递表值参数列值。</span><span class="sxs-lookup"><span data-stu-id="30359-146">Table-valued parameter column values can be passed by repeated calls to SQLPutData as usual when a character or binary value is to be passed in pieces.</span></span>  
  
 <span data-ttu-id="30359-147">处理完所有表值参数列后，驱动程序将返回到表值参数以处理更多的表值参数数据行。</span><span class="sxs-lookup"><span data-stu-id="30359-147">When all table-valued parameter columns have been processed, the driver returns to the table-valued parameter to process further rows of table-valued parameter data.</span></span> <span data-ttu-id="30359-148">因此，对于执行时数据表值参数，驱动程序不遵循通常的顺序扫描绑定参数的方式。</span><span class="sxs-lookup"><span data-stu-id="30359-148">Therefore, for data-at-execution table-valued parameters, the driver does not follow the usual sequential scan of bound parameters.</span></span> <span data-ttu-id="30359-149">在*StrLen_Or_IndPtr*等于0的情况下调用 SQLPutData 之前，将轮询绑定表值参数，此时驱动程序将跳过表值参数列并移至下一个实际的存储过程参数。</span><span class="sxs-lookup"><span data-stu-id="30359-149">A bound table-valued parameter will be polled until SQLPutData is called with *StrLen_Or_IndPtr* equal to 0, at which time the driver skips table-valued parameter columns and moves to the next actual stored procedure parameter.</span></span>  <span data-ttu-id="30359-150">当 SQLPutData 传递的指示器值大于或等于1时，驱动程序将按顺序处理表值参数列和行，直到它具有所有绑定行和列的值。</span><span class="sxs-lookup"><span data-stu-id="30359-150">When SQLPutData passes an indicator value greater than or equal to 1, the driver processes table-valued parameter columns and rows sequentially until it has values for all bound rows and columns.</span></span> <span data-ttu-id="30359-151">然后驱动程序返回到表值参数。</span><span class="sxs-lookup"><span data-stu-id="30359-151">Then the driver returns to the table-valued parameter.</span></span> <span data-ttu-id="30359-152">在从 SQLParamData 接收表值参数的标记和对表值参数调用 SQLPutData (hstmt，NULL，n) 时，应用程序必须为要传递给服务器的下一行或多行设置表值参数构成列数据和指示器缓冲区内容。</span><span class="sxs-lookup"><span data-stu-id="30359-152">Between receiving the token for the table-valued parameter from SQLParamData and calling SQLPutData(hstmt, NULL, n) for a table-valued parameter, the application must set table-valued parameter constituent column data and indicator buffer contents for the next row or rows to be passed to the server.</span></span>  
  
 <span data-ttu-id="30359-153">此方案的示例代码在将 `demo_variable_TVP_binding` [表值参数用于 ODBC&#41;&#40;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)中。</span><span class="sxs-lookup"><span data-stu-id="30359-153">Sample code for this scenario is in the routine `demo_variable_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-from-the-system-catalog"></a><span data-ttu-id="30359-154">从系统目录中检索表值参数元数据</span><span class="sxs-lookup"><span data-stu-id="30359-154">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
 <span data-ttu-id="30359-155">当应用程序为具有表值参数参数的过程调用 SQLProcedureColumns 时，DATA_TYPE 作为 SQL_SS_TABLE 返回，TYPE_NAME 是表值参数的表类型的名称。</span><span class="sxs-lookup"><span data-stu-id="30359-155">When an application calls SQLProcedureColumns for a procedure that has table-valued parameter parameters, DATA_TYPE is returned as SQL_SS_TABLE and TYPE_NAME is the name of the table type for the table-valued parameter.</span></span> <span data-ttu-id="30359-156">将两个附加列添加到 SQLProcedureColumns 返回的结果集： SS_TYPE_CATALOG_NAME 返回定义表值参数的表类型的目录的名称，SS_TYPE_SCHEMA_NAME 返回架构的名称，其中定义了表值参数的表类型。</span><span class="sxs-lookup"><span data-stu-id="30359-156">Two additional columns are added to the result set returned by SQLProcedureColumns: SS_TYPE_CATALOG_NAME returns the name of the catalog where the table type of the table-value parameter is defined, and SS_TYPE_SCHEMA_NAME returns the name of the schema where the where the table type of the table-value parameter is defined.</span></span> <span data-ttu-id="30359-157">与 ODBC 规范一致，SS_TYPE_CATALOG_NAME 和 SS_TYPE_SCHEMA_NAME 出现在以前版本的中添加的所有驱动程序特定列之前 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 以及 odbc 本身所强制的所有列之后。</span><span class="sxs-lookup"><span data-stu-id="30359-157">In conformance with the ODBC specification, SS_TYPE_CATALOG_NAME and SS_TYPE_SCHEMA_NAME appear before all driver specific columns that were added in previous versions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], and after all columns mandated by ODBC itself.</span></span>  
  
 <span data-ttu-id="30359-158">不仅将为表值参数填充这些新列，还将为 CLR 用户定义类型参数填充这些新列。</span><span class="sxs-lookup"><span data-stu-id="30359-158">The new columns will be populated not only for table-valued parameters, but also for CLR user-defined type parameters.</span></span> <span data-ttu-id="30359-159">仍将填充 UDT 参数的现有架构和目录列，但是为数据类型提供所需的常见架构和目录列将简化未来的应用程序开发。</span><span class="sxs-lookup"><span data-stu-id="30359-159">The existing schema and catalog columns of UDT parameters will still be populated, but having common schema and catalog columns for data types that require them will simplify application development in the future.</span></span> <span data-ttu-id="30359-160">（请注意，XML 架构集合稍有不同，未包括在此更改中。）</span><span class="sxs-lookup"><span data-stu-id="30359-160">(Note that XML schema collections are somewhat different and are not included in this change.)</span></span>  
  
 <span data-ttu-id="30359-161">应用程序使用 SQLTables 来确定表类型的名称，其方式与持久表、系统表和视图的名称相同。</span><span class="sxs-lookup"><span data-stu-id="30359-161">An application uses SQLTables to determine the names of table types the same way it does for persistent tables, system tables, and views.</span></span> <span data-ttu-id="30359-162">引入了一个新的表类型 TABLE TYPE，该类型支持应用程序标识与表值参数关联的表类型。</span><span class="sxs-lookup"><span data-stu-id="30359-162">A new table type, TABLE TYPE, is introduced to enable an application to identify table types associated with table-valued parameters.</span></span> <span data-ttu-id="30359-163">表类型和常规表使用不同的命名空间。</span><span class="sxs-lookup"><span data-stu-id="30359-163">Table types and regular tables use different namespaces.</span></span> <span data-ttu-id="30359-164">这意味着可以对表类型和实际表使用相同的名称。</span><span class="sxs-lookup"><span data-stu-id="30359-164">This means that you can use the same name for both a table type and an actual table.</span></span> <span data-ttu-id="30359-165">为处理同名情况，引入了一个新的语句属性 SQL_SOPT_SS_NAME_SCOPE。</span><span class="sxs-lookup"><span data-stu-id="30359-165">To handle this, a new statement attribute, SQL_SOPT_SS_NAME_SCOPE, has been introduced.</span></span> <span data-ttu-id="30359-166">此属性指定采用表名作为参数的 SQLTables 和其他目录函数是否应将表名解释为实际表的名称或表类型的名称。</span><span class="sxs-lookup"><span data-stu-id="30359-166">This attribute specifies whether SQLTables and other catalog functions that take a table name as a parameter should interpret the table name as the name of an actual table or the name of a table type.</span></span>  
  
 <span data-ttu-id="30359-167">应用程序使用 SQLColumns 来确定表类型的列，其方式与持久表的列相同，但必须首先将 SQL_SOPT_SS_NAME_SCOPE 设置为指示它使用的是表类型而不是实际表。</span><span class="sxs-lookup"><span data-stu-id="30359-167">An application uses SQLColumns to determine the columns for a table type in the same way it does for persistent tables, but must first set SQL_SOPT_SS_NAME_SCOPE to indicate that it is working with table types rather than actual tables.</span></span> <span data-ttu-id="30359-168">SQLPrimaryKeys 也可与表类型一起使用，SQL_SOPT_SS_NAME_SCOPE。</span><span class="sxs-lookup"><span data-stu-id="30359-168">SQLPrimaryKeys can also be used with table types, again using SQL_SOPT_SS_NAME_SCOPE.</span></span>  
  
 <span data-ttu-id="30359-169">此方案的示例代码在将 `demo_metadata_from_catalog_APIs` [表值参数用于 ODBC&#41;&#40;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)中。</span><span class="sxs-lookup"><span data-stu-id="30359-169">Sample code for this scenario is in the routine `demo_metadata_from_catalog_APIs` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-for-a-prepared-statement"></a><span data-ttu-id="30359-170">检索准备的语句的表值参数元数据</span><span class="sxs-lookup"><span data-stu-id="30359-170">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
 <span data-ttu-id="30359-171">在此方案中，应用程序使用 SQLNumParameters 和 SQLDescribeParam 检索表值参数的元数据。</span><span class="sxs-lookup"><span data-stu-id="30359-171">In this scenario, an application uses SQLNumParameters and SQLDescribeParam to retrieve metadata for table-valued parameters.</span></span>  
  
 <span data-ttu-id="30359-172">IPD 字段 SQL_CA_SS_TYPE_NAME 用于检索表值参数的类型名称。</span><span class="sxs-lookup"><span data-stu-id="30359-172">The IPD field SQL_CA_SS_TYPE_NAME is used to retrieve the type name for the table-valued parameter.</span></span> <span data-ttu-id="30359-173">IPD 字段 SQL_CA_SS_TYPE_SCHEMA_NAME 和 SQL_CA_SS_TYPE_CATALOG_NAME 分别用于检索表值参数的目录和架构。</span><span class="sxs-lookup"><span data-stu-id="30359-173">The IPD fields SQL_CA_SS_TYPE_SCHEMA_NAME and SQL_CA_SS_TYPE_CATALOG_NAME are used to retrieve its catalog and schema, respectively.</span></span>  
  
 <span data-ttu-id="30359-174">表类型定义和表值参数必须位于同一数据库中。</span><span class="sxs-lookup"><span data-stu-id="30359-174">Table type definitions and table-valued parameters must be in the same database.</span></span> <span data-ttu-id="30359-175">如果应用程序在使用表值参数时设置 SQL_CA_SS_TYPE_CATALOG_NAME，SQLSetDescField 将报告错误。</span><span class="sxs-lookup"><span data-stu-id="30359-175">SQLSetDescField will report an error if an application sets SQL_CA_SS_TYPE_CATALOG_NAME when using table-valued parameters.</span></span>  
  
 <span data-ttu-id="30359-176">SQL_CA_SS_TYPE_CATALOG_NAME 和 SQL_CA_SS_TYPE_SCHEMA_NAME 还可以用于检索与 CLR 用户定义类型参数关联的目录和架构。</span><span class="sxs-lookup"><span data-stu-id="30359-176">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME can also be used to retrieve the catalog and schema associated with CLR user-defined type parameters.</span></span> <span data-ttu-id="30359-177">SQL_CA_SS_TYPE_CATALOG_NAME 和 SQL_CA_SS_TYPE_SCHEMA_NAME 是 CLR UDT 类型的现有类型特定目录架构属性的替代属性。</span><span class="sxs-lookup"><span data-stu-id="30359-177">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME are alternatives to the existing type specific catalog schema attributes for CLR UDT types.</span></span>  
  
 <span data-ttu-id="30359-178">在此方案中，应用程序使用 SQLColumns 检索表值参数的列元数据，因为 SQLDescribeParam 不返回表值参数列的元数据。</span><span class="sxs-lookup"><span data-stu-id="30359-178">An application uses SQLColumns to retrieve column metadata for a table-valued parameter in this scenario, too, because SQLDescribeParam does not return metadata for the columns of a table-valued parameter column.</span></span>  
  
 <span data-ttu-id="30359-179">此用例的示例代码位于 `demo_metadata_from_prepared_statement` [&#40;ODBC&#41;中使用表值参数](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)的例程中。</span><span class="sxs-lookup"><span data-stu-id="30359-179">Sample code for this use case is in the routine `demo_metadata_from_prepared_statement` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="30359-180">另请参阅</span><span class="sxs-lookup"><span data-stu-id="30359-180">See Also</span></span>  
 [<span data-ttu-id="30359-181">ODBC&#41;&#40;表值参数</span><span class="sxs-lookup"><span data-stu-id="30359-181">Table-Valued Parameters &#40;ODBC&#41;</span></span>](table-valued-parameters-odbc.md)  
  
  
