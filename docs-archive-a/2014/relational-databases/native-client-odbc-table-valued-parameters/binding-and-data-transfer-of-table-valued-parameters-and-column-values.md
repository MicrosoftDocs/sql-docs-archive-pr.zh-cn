---
title: 表值参数和列值的绑定和数据传输 |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- table-valued parameters (ODBC), binding and data transfer
ms.assetid: 0a2ea462-d613-42b6-870f-c7fa086a6b42
author: rothja
ms.author: jroth
ms.openlocfilehash: 2e9e30e22a69b2d500990cc1481506b4edbda99b
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87589559"
---
# <a name="binding-and-data-transfer-of-table-valued-parameters-and-column-values"></a><span data-ttu-id="d0435-102">表值参数和列值的绑定及数据传输</span><span class="sxs-lookup"><span data-stu-id="d0435-102">Binding and Data Transfer of Table-Valued Parameters and Column Values</span></span>
  <span data-ttu-id="d0435-103">与其他参数类似，表值参数在传递到服务器之前必须进行绑定。</span><span class="sxs-lookup"><span data-stu-id="d0435-103">Table-valued parameters, like other parameters, must be bound before they are passed to the server.</span></span> <span data-ttu-id="d0435-104">应用程序绑定表值参数的方式与绑定其他参数的方式相同：通过使用 SQLBindParameter 或对 SQLSetDescField 或 SQLSetDescRec 的等效调用。</span><span class="sxs-lookup"><span data-stu-id="d0435-104">The application binds table-valued parameters the same way it binds other parameters: by using SQLBindParameter or equivalent calls to SQLSetDescField or SQLSetDescRec.</span></span> <span data-ttu-id="d0435-105">表值参数的服务器数据类型为 SQL_SS_TABLE。</span><span class="sxs-lookup"><span data-stu-id="d0435-105">The server data type for a table-valued parameter is SQL_SS_TABLE.</span></span> <span data-ttu-id="d0435-106">C 类型可以指定为 SQL_C_DEFAULT 或 SQL_C_BINARY。</span><span class="sxs-lookup"><span data-stu-id="d0435-106">The C type can be specified either as SQL_C_DEFAULT or SQL_C_BINARY.</span></span>  
  
 <span data-ttu-id="d0435-107">在 [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)] 或更高版本中，只支持输入表值参数。</span><span class="sxs-lookup"><span data-stu-id="d0435-107">In [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)] or later, only input table-valued parameters are supported.</span></span> <span data-ttu-id="d0435-108">因此，任何将 SQL_DESC_PARAMETER_TYPE 设置为 SQL_PARAM_INPUT 之外的值的尝试，都将返回具有 SQLSTATE = HY105 和消息“参数类型无效”的 SQL_ERROR。</span><span class="sxs-lookup"><span data-stu-id="d0435-108">Therefore, any attempt to set SQL_DESC_PARAMETER_TYPE to a value other than SQL_PARAM_INPUT will return SQL_ERROR with SQLSTATE = HY105 and the message "Invalid parameter type".</span></span>  
  
 <span data-ttu-id="d0435-109">可使用属性 SQL_CA_SS_COL_HAS_DEFAULT_VALUE 为整个表值参数列分配默认值。</span><span class="sxs-lookup"><span data-stu-id="d0435-109">Entire table-valued parameter columns can be assigned default values by using the attribute SQL_CA_SS_COL_HAS_DEFAULT_VALUE.</span></span> <span data-ttu-id="d0435-110">但是，不能使用 SQLBindParameter 中*StrLen_or_IndPtr*的 SQL_DEFAULT_PARAM 为单独的表值参数列值分配默认值。</span><span class="sxs-lookup"><span data-stu-id="d0435-110">Individual table-valued parameter column values, however, cannot be assigned default values by using SQL_DEFAULT_PARAM in *StrLen_or_IndPtr* with SQLBindParameter.</span></span> <span data-ttu-id="d0435-111">不能将表值参数设置为默认值，方法是使用*StrLen_or_IndPtr* with SQLBindParameter 中的 SQL_DEFAULT_PARAM。</span><span class="sxs-lookup"><span data-stu-id="d0435-111">Table-valued parameters as a whole cannot be set to a default value by using SQL_DEFAULT_PARAM in *StrLen_or_IndPtr* with SQLBindParameter.</span></span> <span data-ttu-id="d0435-112">如果未遵循这些规则，则 SQLExecute 或 SQLExecDirect 将返回 SQL_ERROR。</span><span class="sxs-lookup"><span data-stu-id="d0435-112">If these rules are not followed, SQLExecute or SQLExecDirect will return SQL_ERROR.</span></span> <span data-ttu-id="d0435-113">将生成一条诊断记录，其中 SQLSTATE = 07S01 和消息 "参数的默认参数使用无效 \<p> "，其中 \<p> 是查询语句中的 TVP 序号。</span><span class="sxs-lookup"><span data-stu-id="d0435-113">A diagnostic record will be generated with SQLSTATE=07S01 and the message "Invalid use of default parameter for parameter \<p>", where \<p> is the ordinal of the TVP in the query statement.</span></span>  
  
 <span data-ttu-id="d0435-114">绑定表值参数之后，应用程序随后必须绑定每个表值参数列。</span><span class="sxs-lookup"><span data-stu-id="d0435-114">After binding the table-valued parameter, the application must then bind each table-valued parameter column.</span></span> <span data-ttu-id="d0435-115">为此，应用程序首先调用 SQLSetStmtAttr，将 SQL_SOPT_SS_PARAM_FOCUS 设置为表值参数的序号。</span><span class="sxs-lookup"><span data-stu-id="d0435-115">To do this, the application first calls SQLSetStmtAttr to set SQL_SOPT_SS_PARAM_FOCUS to the ordinal of a table-valued parameter.</span></span> <span data-ttu-id="d0435-116">然后，应用程序通过调用以下例程来绑定表值参数的列： SQLBindParameter、SQLSetDescRec 和 SQLSetDescField。</span><span class="sxs-lookup"><span data-stu-id="d0435-116">Then the application binds the columns of the table-valued parameter by calls to the following routines: SQLBindParameter, SQLSetDescRec, and SQLSetDescField.</span></span> <span data-ttu-id="d0435-117">如果将 SQL_SOPT_SS_PARAM_FOCUS 设置为0，则会在操作常规顶级参数时还原 SQLBindParameter、SQLSetDescRec 和 SQLSetDescField 的常见影响。</span><span class="sxs-lookup"><span data-stu-id="d0435-117">Setting SQL_SOPT_SS_PARAM_FOCUS to 0 restores the usual effect of SQLBindParameter, SQLSetDescRec, and SQLSetDescField in operating on regular top-level parameters.</span></span>  
  
 <span data-ttu-id="d0435-118">对于表值参数本身而言，并未发送或接收实际数据，但对于表值参数的每个构成列而言，发送和接收了数据。</span><span class="sxs-lookup"><span data-stu-id="d0435-118">No actual data is sent or received for the table-valued parameter itself, but data is sent and received for each of its constituent columns.</span></span> <span data-ttu-id="d0435-119">由于表值参数是一个伪列，因此 SQLBindParameter 的参数用于引用不同于其他数据类型的属性，如下所示：</span><span class="sxs-lookup"><span data-stu-id="d0435-119">Because the table-valued parameter is a pseudo column, the parameters for SQLBindParameter are used to refer to different attributes than other data types, as follows:</span></span>  
  
|<span data-ttu-id="d0435-120">参数</span><span class="sxs-lookup"><span data-stu-id="d0435-120">Parameter</span></span>|<span data-ttu-id="d0435-121">非表值参数类型的相关属性，包括列</span><span class="sxs-lookup"><span data-stu-id="d0435-121">Related attribute for non-table-valued parameter types, including columns</span></span>|<span data-ttu-id="d0435-122">表值参数的相关属性</span><span class="sxs-lookup"><span data-stu-id="d0435-122">Related attribute for table-valued parameters</span></span>|  
|---------------|--------------------------------------------------------------------------------|----------------------------------------------------|  
|<span data-ttu-id="d0435-123">InputOutputType </span><span class="sxs-lookup"><span data-stu-id="d0435-123">*InputOutputType*</span></span>|<span data-ttu-id="d0435-124">IPD 中的 SQL_DESC_PARAMETER_TYPE。</span><span class="sxs-lookup"><span data-stu-id="d0435-124">SQL_DESC_PARAMETER_TYPE in IPD.</span></span><br /><br /> <span data-ttu-id="d0435-125">对于表值参数列，此属性设置必须与表值参数自身的设置相同。</span><span class="sxs-lookup"><span data-stu-id="d0435-125">For table-valued parameter columns, this must be the same as the setting for the table-valued parameter itself.</span></span>|<span data-ttu-id="d0435-126">IPD 中的 SQL_DESC_PARAMETER_TYPE。</span><span class="sxs-lookup"><span data-stu-id="d0435-126">SQL_DESC_PARAMETER_TYPE in IPD.</span></span><br /><br /> <span data-ttu-id="d0435-127">此属性必须为 SQL_PARAM_INPUT。</span><span class="sxs-lookup"><span data-stu-id="d0435-127">This must be SQL_PARAM_INPUT.</span></span>|  
|<span data-ttu-id="d0435-128">*ValueType*</span><span class="sxs-lookup"><span data-stu-id="d0435-128">*ValueType*</span></span>|<span data-ttu-id="d0435-129">APD 中的 SQL_DESC_TYPE、SQL_DESC_CONCISE_TYPE。</span><span class="sxs-lookup"><span data-stu-id="d0435-129">SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE in APD.</span></span>|<span data-ttu-id="d0435-130">APD 中的 SQL_DESC_TYPE、SQL_DESC_CONCISE_TYPE。</span><span class="sxs-lookup"><span data-stu-id="d0435-130">SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE in APD.</span></span><br /><br /> <span data-ttu-id="d0435-131">此属性必须为 SQL_C_DEFAULT 或 SQL_C_BINARY。</span><span class="sxs-lookup"><span data-stu-id="d0435-131">This must be SQL_C_DEFAULT or SQL_C_BINARY.</span></span>|  
|<span data-ttu-id="d0435-132">*ParameterType*</span><span class="sxs-lookup"><span data-stu-id="d0435-132">*ParameterType*</span></span>|<span data-ttu-id="d0435-133">IPD 中的 SQL_DESC_TYPE、SQL_DESC_CONCISE_TYPE。</span><span class="sxs-lookup"><span data-stu-id="d0435-133">SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE in IPD.</span></span>|<span data-ttu-id="d0435-134">IPD 中的 SQL_DESC_TYPE、SQL_DESC_CONCISE_TYPE。</span><span class="sxs-lookup"><span data-stu-id="d0435-134">SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE in IPD.</span></span><br /><br /> <span data-ttu-id="d0435-135">此属性必须为 SQL_SS_TABLE。</span><span class="sxs-lookup"><span data-stu-id="d0435-135">This must be SQL_SS_TABLE.</span></span>|  
|<span data-ttu-id="d0435-136">ColumnSize </span><span class="sxs-lookup"><span data-stu-id="d0435-136">*ColumnSize*</span></span>|<span data-ttu-id="d0435-137">IPD 中的 SQL_DESC_LENGTH 或 SQL_DESC_PRECISION。</span><span class="sxs-lookup"><span data-stu-id="d0435-137">SQL_DESC_LENGTH or SQL_DESC_PRECISION in IPD.</span></span><br /><br /> <span data-ttu-id="d0435-138">这取决于*ParameterType*的值。</span><span class="sxs-lookup"><span data-stu-id="d0435-138">This depends on the value of *ParameterType*.</span></span>|<span data-ttu-id="d0435-139">SQL_DESC_ARRAY_SIZE</span><span class="sxs-lookup"><span data-stu-id="d0435-139">SQL_DESC_ARRAY_SIZE</span></span><br /><br /> <span data-ttu-id="d0435-140">当参数焦点设置为表值参数时，也可以使用 SQL_ATTR_PARAM_SET_SIZE 进行设置。</span><span class="sxs-lookup"><span data-stu-id="d0435-140">Can also be set using SQL_ATTR_PARAM_SET_SIZE when the parameter focus is set to the table-valued parameter.</span></span><br /><br /> <span data-ttu-id="d0435-141">对于表值参数，此属性为表值参数列缓冲区内的行数。</span><span class="sxs-lookup"><span data-stu-id="d0435-141">For a table-valued parameter, this is the number of rows in the table-valued parameter column buffers.</span></span>|  
|<span data-ttu-id="d0435-142">DecimalDigits </span><span class="sxs-lookup"><span data-stu-id="d0435-142">*DecimalDigits*</span></span>|<span data-ttu-id="d0435-143">IPD 中的 SQL_DESC_PRECISION 或 SQL_DESC_SCALE。</span><span class="sxs-lookup"><span data-stu-id="d0435-143">SQL_DESC_PRECISION or SQL_DESC_SCALE in IPD.</span></span>|<span data-ttu-id="d0435-144">未使用。</span><span class="sxs-lookup"><span data-stu-id="d0435-144">Unused.</span></span> <span data-ttu-id="d0435-145">此属性必须为 0。</span><span class="sxs-lookup"><span data-stu-id="d0435-145">This must be 0.</span></span><br /><br /> <span data-ttu-id="d0435-146">如果此参数不是0，则 SQLBindParameter 将返回 SQL_ERROR，并将生成包含 SQLSTATE = HY104 和消息 "precision 或 scale 无效" 的诊断记录。</span><span class="sxs-lookup"><span data-stu-id="d0435-146">If this parameter is not 0, SQLBindParameter will return SQL_ERROR, and a diagnostic record will be generated with SQLSTATE= HY104 and the message "Invalid precision or scale".</span></span>|  
|<span data-ttu-id="d0435-147">*ParameterValuePtr*</span><span class="sxs-lookup"><span data-stu-id="d0435-147">*ParameterValuePtr*</span></span>|<span data-ttu-id="d0435-148">APD 中的 SQL_DESC_DATA_PTR。</span><span class="sxs-lookup"><span data-stu-id="d0435-148">SQL_DESC_DATA_PTR in APD.</span></span>|<span data-ttu-id="d0435-149">SQL_CA_SS_TYPE_NAME。</span><span class="sxs-lookup"><span data-stu-id="d0435-149">SQL_CA_SS_TYPE_NAME.</span></span><br /><br /> <span data-ttu-id="d0435-150">此属性对于存储过程调用为可选的，并且如果不需要可以指定为 NULL。</span><span class="sxs-lookup"><span data-stu-id="d0435-150">This is optional for stored procedure calls, and NULL can be specified if it is not required.</span></span> <span data-ttu-id="d0435-151">对于非过程调用的 SQL 语句，必须指定此属性。</span><span class="sxs-lookup"><span data-stu-id="d0435-151">It must be specified for SQL statements that are not procedure calls.</span></span><br /><br /> <span data-ttu-id="d0435-152">在使用可变行绑定时，此参数还可作为应用程序用于标识该表值参数的唯一值。</span><span class="sxs-lookup"><span data-stu-id="d0435-152">This parameter also serves as a unique value that the application can use to identify this table-valued parameter when variable row binding is used.</span></span> <span data-ttu-id="d0435-153">有关详细信息，请参阅本主题后面的“可变表值参数行绑定”部分。</span><span class="sxs-lookup"><span data-stu-id="d0435-153">For more information, see the "Variable Table-Valued Parameter Row Binding" section, later in this topic.</span></span><br /><br /> <span data-ttu-id="d0435-154">如果在对 SQLBindParameter 的调用上指定了表值参数类型名称，则它必须指定为 Unicode 值，即使是在作为 ANSI 应用程序生成的应用程序中。</span><span class="sxs-lookup"><span data-stu-id="d0435-154">When a table-valued parameter type name is specified on a call to SQLBindParameter, it must be specified as a Unicode value, even in applications that are built as ANSI applications.</span></span> <span data-ttu-id="d0435-155">用于参数*StrLen_or_IndPtr*的值应为 SQL_NTS 或名称的字符串长度乘以 SIZEOF (WCHAR) 。</span><span class="sxs-lookup"><span data-stu-id="d0435-155">The value used for the parameter *StrLen_or_IndPtr* should be either SQL_NTS or the string length of the name multiplied by sizeof(WCHAR).</span></span>|  
|<span data-ttu-id="d0435-156">*BufferLength*</span><span class="sxs-lookup"><span data-stu-id="d0435-156">*BufferLength*</span></span>|<span data-ttu-id="d0435-157">APD 中的 SQL_DESC_OCTET_LENGTH。</span><span class="sxs-lookup"><span data-stu-id="d0435-157">SQL_DESC_OCTET_LENGTH in APD.</span></span>|<span data-ttu-id="d0435-158">表值参数类型名称的长度（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d0435-158">The length of the table-valued parameter type name in bytes.</span></span><br /><br /> <span data-ttu-id="d0435-159">如果类型名称为以 NULL 值结束，则它可以是 SQL_NTS；如果不需要表值参数类型名称，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d0435-159">This can be SQL_NTS if the type name is null terminated, or 0 if the table-valued parameter type name is not required.</span></span>|  
|<span data-ttu-id="d0435-160">*StrLen_or_IndPtr*</span><span class="sxs-lookup"><span data-stu-id="d0435-160">*StrLen_or_IndPtr*</span></span>|<span data-ttu-id="d0435-161">APD 中的 SQL_DESC_OCTET_LENGTH_PTR。</span><span class="sxs-lookup"><span data-stu-id="d0435-161">SQL_DESC_OCTET_LENGTH_PTR in APD.</span></span>|<span data-ttu-id="d0435-162">APD 中的 SQL_DESC_OCTET_LENGTH_PTR。</span><span class="sxs-lookup"><span data-stu-id="d0435-162">SQL_DESC_OCTET_LENGTH_PTR in APD.</span></span><br /><br /> <span data-ttu-id="d0435-163">对于表值参数，此属性为行计数，而非数据长度。</span><span class="sxs-lookup"><span data-stu-id="d0435-163">For table-valued parameters, this is a row count rather than a data length.</span></span>|  
  
 <span data-ttu-id="d0435-164">表值参数支持两种数据传输模式：固定行绑定和可变行绑定。</span><span class="sxs-lookup"><span data-stu-id="d0435-164">Two data transfer modes are supported for table-valued parameters: fixed row binding and variable row binding.</span></span>  
  
## <a name="fixed-table-valued-parameter-row-binding"></a><span data-ttu-id="d0435-165">固定表值参数行绑定</span><span class="sxs-lookup"><span data-stu-id="d0435-165">Fixed Table-Valued Parameter Row Binding</span></span>  
 <span data-ttu-id="d0435-166">在固定行绑定模式中，应用程序会分配足以容纳所有可能的输入列值的缓冲区（或缓冲区数组）。</span><span class="sxs-lookup"><span data-stu-id="d0435-166">For fixed row binding, an application allocates buffers (or buffer arrays) large enough for all possible input column values.</span></span> <span data-ttu-id="d0435-167">应用程序执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="d0435-167">The application does the following:</span></span>  
  
1.  <span data-ttu-id="d0435-168">使用 SQLBindParameter、SQLSetDescRec 或 SQLSetDescField 调用来绑定所有参数。</span><span class="sxs-lookup"><span data-stu-id="d0435-168">Binds all parameters by using SQLBindParameter, SQLSetDescRec, or SQLSetDescField calls.</span></span>  
  
    1.  <span data-ttu-id="d0435-169">将 SQL_DESC_ARRAY_SIZE 设置为每个表值参数所能传输的最大行数。</span><span class="sxs-lookup"><span data-stu-id="d0435-169">Sets SQL_DESC_ARRAY_SIZE to the maximum number of rows that can be transferred for each table-valued parameter.</span></span> <span data-ttu-id="d0435-170">这可以在 SQLBindParameter 调用中完成。</span><span class="sxs-lookup"><span data-stu-id="d0435-170">This can be done in the SQLBindParameter call.</span></span>  
  
2.  <span data-ttu-id="d0435-171">调用 SQLSetStmtAttr，将 SQL_SOPT_SS_PARAM_FOCUS 设置为每个表值参数的序号。</span><span class="sxs-lookup"><span data-stu-id="d0435-171">Calls SQLSetStmtAttr to set SQL_SOPT_SS_PARAM_FOCUS to the ordinal of each table-valued parameter.</span></span>  
  
    1.  <span data-ttu-id="d0435-172">对于每个表值参数，使用 SQLBindParameter、SQLSetDescRec 或 SQLSetDescField 调用来绑定表值参数列。</span><span class="sxs-lookup"><span data-stu-id="d0435-172">For each table-valued parameter, binds table-valued parameter columns by using SQLBindParameter, SQLSetDescRec, or SQLSetDescField calls.</span></span>  
  
    2.  <span data-ttu-id="d0435-173">对于将具有默认值的每个表值参数列，调用 SQLSetDescField 将 SQL_CA_SS_COL_HAS_DEFAULT_VALUE 设置为1。</span><span class="sxs-lookup"><span data-stu-id="d0435-173">For each table-valued parameter column that is to have default values, calls SQLSetDescField to set SQL_CA_SS_COL_HAS_DEFAULT_VALUE to 1.</span></span>  
  
3.  <span data-ttu-id="d0435-174">调用 SQLSetStmtAttr，将 SQL_SOPT_SS_PARAM_FOCUS 设置为0。</span><span class="sxs-lookup"><span data-stu-id="d0435-174">Calls SQLSetStmtAttr to set SQL_SOPT_SS_PARAM_FOCUS to 0.</span></span> <span data-ttu-id="d0435-175">此操作必须在调用 SQLExecute 或 SQLExecDirect 之前完成。</span><span class="sxs-lookup"><span data-stu-id="d0435-175">This must be done before SQLExecute or SQLExecDirect is called.</span></span> <span data-ttu-id="d0435-176">否则，将返回 SQL_ERROR，且生成具有 SQLSTATE=HY024 和消息“属性值 SQL_SOPT_SS_PARAM_FOCUS 无效(执行时必须为零)”的诊断记录。</span><span class="sxs-lookup"><span data-stu-id="d0435-176">Otherwise, SQL_ERROR is be returned and a diagnostic record is generated with SQLSTATE=HY024 and the message "Invalid attribute value, SQL_SOPT_SS_PARAM_FOCUS (must be zero at execution time)".</span></span>  
  
4.  <span data-ttu-id="d0435-177">将*StrLen_or_IndPtr*或 SQL_DESC_OCTET_LENGTH_PTR 设置为无行的表值参数 SQL_DEFAULT_PARAM，或在下一次调用 SQLExecute 或 SQLExecDirect 时，如果表值参数包含行，则为要传输的行数。</span><span class="sxs-lookup"><span data-stu-id="d0435-177">Sets *StrLen_or_IndPtr* or SQL_DESC_OCTET_LENGTH_PTR to SQL_DEFAULT_PARAM for a table-valued parameter with no rows, or the number of rows to be transferred on the next call of SQLExecute or SQLExecDirect if the table-valued parameter has rows.</span></span> <span data-ttu-id="d0435-178">不能将*StrLen_or_IndPtr*或 SQL_DESC_OCTET_LENGTH_PTR 设置为表值参数的 SQL_NULL_DATA，因为表值参数不可为 null (但表值参数构成列可以为 null) 。</span><span class="sxs-lookup"><span data-stu-id="d0435-178">*StrLen_or_IndPtr* or SQL_DESC_OCTET_LENGTH_PTR cannot be set to SQL_NULL_DATA for a table-valued parameter as table-valued parameters are not nullable (though table-valued parameter constituent columns may be nullable).</span></span> <span data-ttu-id="d0435-179">如果将此值设置为无效值，则 SQLExecute 或 SQLExecDirect 将返回 SQL_ERROR，并生成包含 SQLSTATE = HY090 和消息 "参数的字符串或缓冲区长度无效" 的诊断记录 \<p> ，其中 p 是参数号。</span><span class="sxs-lookup"><span data-stu-id="d0435-179">If this is set to an invalid value, SQLExecute or SQLExecDirect returns SQL_ERROR, and a diagnostic record is generated with SQLSTATE=HY090 and the message "Invalid string or buffer length for parameter \<p>", where p is the parameter number.</span></span>  
  
5.  <span data-ttu-id="d0435-180">调用 SQLExecute 或 SQLExecDirect。</span><span class="sxs-lookup"><span data-stu-id="d0435-180">Calls SQLExecute or SQLExecDirect.</span></span>  
  
 <span data-ttu-id="d0435-181">如果将*StrLen_or_IndPtr*设置为 SQL_LEN_DATA_AT_EXEC (*长度*) 或列 SQL_DATA_AT_EXEC，则输入表值参数列的值可以进行传入。</span><span class="sxs-lookup"><span data-stu-id="d0435-181">Input table-valued parameter column values can be passed in pieces if *StrLen_or_IndPtr* is set to SQL_LEN_DATA_AT_EXEC(*length*) or SQL_DATA_AT_EXEC for the column.</span></span> <span data-ttu-id="d0435-182">这类似于使用参数数组时的分块传递值。</span><span class="sxs-lookup"><span data-stu-id="d0435-182">This is similar to passing values in pieces when arrays of parameters are used.</span></span> <span data-ttu-id="d0435-183">与所有执行时数据参数一样，SQLParamData 不指示驱动程序要向哪个数组行请求数据;应用程序必须对此进行处理。</span><span class="sxs-lookup"><span data-stu-id="d0435-183">As with all data-at-execution parameters, SQLParamData does not indicate which row of the array the driver is requesting data for; the application must take care of this.</span></span> <span data-ttu-id="d0435-184">应用程序不能对驱动程序将请求值的顺序做出任何假设。</span><span class="sxs-lookup"><span data-stu-id="d0435-184">The application cannot make any assumptions about the order in which the driver will request values.</span></span>  
  
## <a name="variable-table-valued-parameter-row-binding"></a><span data-ttu-id="d0435-185">可变表值参数行绑定</span><span class="sxs-lookup"><span data-stu-id="d0435-185">Variable Table-Valued Parameter Row Binding</span></span>  
 <span data-ttu-id="d0435-186">在可变行绑定模式中，行在执行时进行批量传输，且应用程序根据需要将行传递给驱动程序。</span><span class="sxs-lookup"><span data-stu-id="d0435-186">For variable row binding, rows are transferred in batches at execution time and the application passes rows to the driver on demand.</span></span> <span data-ttu-id="d0435-187">这类似于单个参数值的执行时数据。</span><span class="sxs-lookup"><span data-stu-id="d0435-187">This is similar to data-at-execution for individual parameter values.</span></span> <span data-ttu-id="d0435-188">对于可变行绑定，应用程序执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="d0435-188">For variable row binding, the application does the following:</span></span>  
  
1.  <span data-ttu-id="d0435-189">按照上一部分“固定表值参数行绑定”中的步骤 1 到 3 所述，绑定参数和表值参数列。</span><span class="sxs-lookup"><span data-stu-id="d0435-189">Binds parameters and table-valued parameter columns as described in steps 1 to 3 of the previous section, "Fixed Table-Valued Parameter Row Binding".</span></span>  
  
2.  <span data-ttu-id="d0435-190">为要在执行时传递到 SQL_DATA_AT_EXEC 的任何表值参数设置*StrLen_or_IndPtr*或 SQL_DESC_OCTET_LENGTH_PTR。</span><span class="sxs-lookup"><span data-stu-id="d0435-190">Sets *StrLen_or_IndPtr* or SQL_DESC_OCTET_LENGTH_PTR for any table-valued parameters that are to be passed at execution time to SQL_DATA_AT_EXEC.</span></span> <span data-ttu-id="d0435-191">如果未设置这两个参数，则将按照上一部分中所述步骤处理参数。</span><span class="sxs-lookup"><span data-stu-id="d0435-191">If neither is set, the parameter will be processed as described in the previous section.</span></span>  
  
3.  <span data-ttu-id="d0435-192">调用 SQLExecute 或 SQLExecDirect。</span><span class="sxs-lookup"><span data-stu-id="d0435-192">Calls SQLExecute or SQLExecDirect.</span></span> <span data-ttu-id="d0435-193">如果有任何 SQL_PARAM_INPUT 或 SQL_PARAM_INPUT_OUTPUT 参数处理为执行时数据参数，则调用将返回 SQL_NEED_DATA。</span><span class="sxs-lookup"><span data-stu-id="d0435-193">This will return SQL_NEED_DATA if there are any SQL_PARAM_INPUT or SQL_PARAM_INPUT_OUTPUT parameters to be handled as data-at-execution parameters.</span></span> <span data-ttu-id="d0435-194">在这种情况下，应用程序执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="d0435-194">In this case, the application does the following:</span></span>  
  
    -   <span data-ttu-id="d0435-195">调用 SQLParamData。</span><span class="sxs-lookup"><span data-stu-id="d0435-195">Calls SQLParamData.</span></span> <span data-ttu-id="d0435-196">这会返回执行时数据参数的*ParameterValuePtr*值和返回代码 SQL_NEED_DATA。</span><span class="sxs-lookup"><span data-stu-id="d0435-196">This returns the *ParameterValuePtr* value for a data-at-execution parameter and a return code of SQL_NEED_DATA.</span></span> <span data-ttu-id="d0435-197">所有参数数据都传递到驱动程序后，SQLParamData 将返回 SQL_SUCCESS、SQL_SUCCESS_WITH_INFO 或 SQL_ERROR。</span><span class="sxs-lookup"><span data-stu-id="d0435-197">When all parameter data has been passed to the driver, SQLParamData returns SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, or SQL_ERROR.</span></span> <span data-ttu-id="d0435-198">对于执行时数据参数， *ParameterValuePtr*与描述符字段 SQL_DESC_DATA_PTR 相同，可将其视为一个标记，用于唯一标识需要其值的参数。</span><span class="sxs-lookup"><span data-stu-id="d0435-198">For data-at-execution parameters, *ParameterValuePtr*, which is the same as the descriptor field SQL_DESC_DATA_PTR, can be regarded as a token to uniquely identify a parameter for which a value is required.</span></span> <span data-ttu-id="d0435-199">此“标记”在绑定时从应用程序传递给驱动程序，在执行时传递回应用程序。</span><span class="sxs-lookup"><span data-stu-id="d0435-199">This "token" is passed from the application to the driver at bind time, then passed back to the application at execution time.</span></span>  
  
4.  <span data-ttu-id="d0435-200">若要为 null 表值参数发送表值参数行数据，如果表值参数没有任何行，应用程序将调用 SQLPutData 并将*StrLen_or_Ind*设置为 SQL_DEFAULT_PARAM。</span><span class="sxs-lookup"><span data-stu-id="d0435-200">To send table-valued parameter row data for null table-valued parameters, if the table-valued parameter has no rows, an application calls SQLPutData with *StrLen_or_Ind* set to SQL_DEFAULT_PARAM.</span></span>  
  
     <span data-ttu-id="d0435-201">对于非 Null TVP，应用程序会：</span><span class="sxs-lookup"><span data-stu-id="d0435-201">For non-NULL TVPs, an application:</span></span>  
  
    -   <span data-ttu-id="d0435-202">将所有表值参数列*Str_Len_or_Ind*设置为适当的值，并填充不是执行时数据参数的表值参数列的数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="d0435-202">Sets *Str_Len_or_Ind* for all the table-valued parameter columns to appropriate values, and populates data buffers for table-valued parameter columns that are not to be data-at-execution parameters.</span></span> <span data-ttu-id="d0435-203">可以采用类似于将普通参数分块传递给驱动程序的方式，使用表值参数列的执行时数据。</span><span class="sxs-lookup"><span data-stu-id="d0435-203">You can use data-at-execution for table-valued parameter columns in a similar way to that in which ordinary parameters can be passed to the driver in pieces.</span></span>  
  
    -   <span data-ttu-id="d0435-204">调用 SQLPutData，将*Str_Len_or_Ind*设置为要发送到服务器的行数。</span><span class="sxs-lookup"><span data-stu-id="d0435-204">Calls SQLPutData with *Str_Len_or_Ind* set to the number of rows to be sent to the server.</span></span> <span data-ttu-id="d0435-205">范围 0 到 SQL_DESC_ARRAY_SIZE 或 SQL_DEFAULT_PARAM 以外的任何值都将生成错误，并将返回 SQLSTATE HY090 和消息“字符串或缓冲区长度无效”。</span><span class="sxs-lookup"><span data-stu-id="d0435-205">Any value outside the range 0 to SQL_DESC_ARRAY_SIZE or SQL_DEFAULT_PARAM is an error, and will return SQLSTATE HY090, with the message "Invalid string or buffer length".</span></span> <span data-ttu-id="d0435-206">0 表示已发送所有行，已不存在任何表值参数数据（如本列表的第二个项目符号项中所述）。</span><span class="sxs-lookup"><span data-stu-id="d0435-206">0 indicates that all rows have been sent and there is no more data for a table-valued parameter (as noted in the second bullet item in this list).</span></span> <span data-ttu-id="d0435-207">只有在驱动程序第一次请求表值参数数据时，才能使用 SQL_DEFAULT_PARAM（如本列表的第二个项目符号项中所述）。</span><span class="sxs-lookup"><span data-stu-id="d0435-207">SQL_DEFAULT_PARAM can only be used the first time the driver requests data for a table-valued parameter (as described in the first bullet item in this list).</span></span>  
  
5.  <span data-ttu-id="d0435-208">发送完所有行后，将使用*Str_Len_or_Ind*值0对表值参数调用 SQLPutData，然后继续执行上述步骤3a。</span><span class="sxs-lookup"><span data-stu-id="d0435-208">When all rows have been sent, calls SQLPutData for the table-valued parameter with a *Str_Len_or_Ind* value of 0, then proceeds to step 3a above.</span></span>  
  
6.  <span data-ttu-id="d0435-209">再次调用 SQLParamData。</span><span class="sxs-lookup"><span data-stu-id="d0435-209">Calls SQLParamData again.</span></span> <span data-ttu-id="d0435-210">如果表值参数列中有任何执行时数据参数，则这些参数将由 SQLParamData 返回的值*ValuePtrPtr*标识。</span><span class="sxs-lookup"><span data-stu-id="d0435-210">If there are any data-at-execution parameters among the table-valued parameter columns, these will be identified by the value *ValuePtrPtr* returned by SQLParamData.</span></span> <span data-ttu-id="d0435-211">当所有列值都可用时，SQLParamData 将再次返回表值参数的*ParameterValuePtr*值，并且该应用程序将再次开始。</span><span class="sxs-lookup"><span data-stu-id="d0435-211">When all column values are available, SQLParamData will again return the *ParameterValuePtr* value for the table-valued parameter, and the application begins again.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d0435-212">另请参阅</span><span class="sxs-lookup"><span data-stu-id="d0435-212">See Also</span></span>  
 [<span data-ttu-id="d0435-213">ODBC&#41;&#40;表值参数</span><span class="sxs-lookup"><span data-stu-id="d0435-213">Table-Valued Parameters &#40;ODBC&#41;</span></span>](table-valued-parameters-odbc.md)  
  
  
