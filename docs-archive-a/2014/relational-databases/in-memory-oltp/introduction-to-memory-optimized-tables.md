---
title: 内存优化表简介 | Microsoft Docs
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: rothja
ms.author: jroth
ms.openlocfilehash: edcdea9d266cf0ef231b1e16be4da7009372dcd6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87693889"
---
# <a name="introduction-to-memory-optimized-tables"></a><span data-ttu-id="fca8f-102">内存优化表简介</span><span class="sxs-lookup"><span data-stu-id="fca8f-102">Introduction to Memory-Optimized Tables</span></span>
  <span data-ttu-id="fca8f-103">内存优化表是使用 [CREATE TABLE (Transact-SQL)](/sql/t-sql/statements/create-table-transact-sql) 创建的表。</span><span class="sxs-lookup"><span data-stu-id="fca8f-103">Memory-optimized tables are tables, created using [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span></span>  
  
 <span data-ttu-id="fca8f-104">内存优化表驻留在内存中。</span><span class="sxs-lookup"><span data-stu-id="fca8f-104">Memory-optimized tables reside in memory.</span></span> <span data-ttu-id="fca8f-105">从内存读取表中的行和将这些行写入内存。</span><span class="sxs-lookup"><span data-stu-id="fca8f-105">Rows in the table are read from and written to memory.</span></span> <span data-ttu-id="fca8f-106">整个表都驻留在内存中。</span><span class="sxs-lookup"><span data-stu-id="fca8f-106">The entire table resides in memory.</span></span> <span data-ttu-id="fca8f-107">表数据的另一个副本维护在磁盘上，但仅用于持续性目的。</span><span class="sxs-lookup"><span data-stu-id="fca8f-107">A second copy of the table data is maintained on disk, but only for durability purposes.</span></span>  
  
 <span data-ttu-id="fca8f-108">内存中 OLTP 与 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 集成，以便在所有方面（如开发、部署、可管理性和可支持性）提供无缝体验。</span><span class="sxs-lookup"><span data-stu-id="fca8f-108">In-Memory OLTP is integrated with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to provide a seamless experience in all areas such as development, deployment, manageability, and supportability.</span></span> <span data-ttu-id="fca8f-109">数据库可包含内存中对象以及基于磁盘的对象。</span><span class="sxs-lookup"><span data-stu-id="fca8f-109">A database can contain in-memory as well as disk-based objects.</span></span>  
  
 <span data-ttu-id="fca8f-110">内存优化表中的行是版本化的。</span><span class="sxs-lookup"><span data-stu-id="fca8f-110">Rows in memory-optimized tables are versioned.</span></span> <span data-ttu-id="fca8f-111">这意味着表中的每行都可能有多个版本。</span><span class="sxs-lookup"><span data-stu-id="fca8f-111">This means that each row in the table potentially has multiple versions.</span></span> <span data-ttu-id="fca8f-112">所有行版本均维护在同一个表数据结构中。</span><span class="sxs-lookup"><span data-stu-id="fca8f-112">All row versions are maintained in the same table data structure.</span></span> <span data-ttu-id="fca8f-113">行版本控制用于实现对同一行的并发读取和写入。</span><span class="sxs-lookup"><span data-stu-id="fca8f-113">Row versioning is used to allow concurrent reads and writes on the same row.</span></span> <span data-ttu-id="fca8f-114">有关对同一行的并发读取和写入的更多信息，请参阅 [Transactions in Memory-Optimized Tables](memory-optimized-tables.md)。</span><span class="sxs-lookup"><span data-stu-id="fca8f-114">For more information about concurrent reads and writes on the same row, see [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="fca8f-115">下图展示多版本控制。</span><span class="sxs-lookup"><span data-stu-id="fca8f-115">The following figure illustrates multi-versioning.</span></span> <span data-ttu-id="fca8f-116">该图显示了一个包含三行的表，其中，每行都有不同的版本。</span><span class="sxs-lookup"><span data-stu-id="fca8f-116">The figure shows a table with three rows and each row has different versions.</span></span>  
  
 <span data-ttu-id="fca8f-117">![多版本控制。](../../database-engine/media/hekaton-tables-1.gif "多版本控制。")</span><span class="sxs-lookup"><span data-stu-id="fca8f-117">![Multi-versioning.](../../database-engine/media/hekaton-tables-1.gif "Multi-versioning.")</span></span>  
  
 <span data-ttu-id="fca8f-118">该表有三行：r1、r2 和 r3。</span><span class="sxs-lookup"><span data-stu-id="fca8f-118">The table has three rows: r1, r2, and r3.</span></span> <span data-ttu-id="fca8f-119">r1 有三个版本，r2 有两个版本，r3 有四个版本。</span><span class="sxs-lookup"><span data-stu-id="fca8f-119">r1 has three versions, r2 has two versions, and r3 has four versions.</span></span> <span data-ttu-id="fca8f-120">注意，同一行的不同版本不必占用连续的内存位置。</span><span class="sxs-lookup"><span data-stu-id="fca8f-120">Note that different versions of the same row do not necessarily occupy consecutive memory locations.</span></span> <span data-ttu-id="fca8f-121">不同的行版本可分散到整个表数据结构中。</span><span class="sxs-lookup"><span data-stu-id="fca8f-121">The different row versions can be dispersed throughout the table data structure.</span></span>  
  
 <span data-ttu-id="fca8f-122">可将内存优化的表数据结构视为一个行版本集合。</span><span class="sxs-lookup"><span data-stu-id="fca8f-122">The memory-optimized table data structure can be seen as a collection of row versions.</span></span> <span data-ttu-id="fca8f-123">基于磁盘的表中的行以页和区形式组织，各个行借助页码和页偏移量进行寻址，而内存优化表中的行版本则借助 8 字节的内存指针进行寻址。</span><span class="sxs-lookup"><span data-stu-id="fca8f-123">Rows in disk-based tables are organized in pages and extents, and individual rows addressed using page number and page offset, row versions in memory-optimized tables are addressed using 8-byte memory pointers.</span></span>  
  
## <a name="durability"></a><span data-ttu-id="fca8f-124">持久性</span><span class="sxs-lookup"><span data-stu-id="fca8f-124">Durability</span></span>  
 <span data-ttu-id="fca8f-125">默认情况下，内存优化的表是完全持久的，并且如同（传统的）基于磁盘的表上的事务一样，内存优化表上的完全持久的事务是完全原子、一致、隔离和持久 (ACID) 的。</span><span class="sxs-lookup"><span data-stu-id="fca8f-125">Memory-optimized tables are fully durable by default, and, like transactions on (traditional) disk-based tables, fully durable transactions on memory-optimized tables are fully atomic, consistent, isolated, and durable (ACID).</span></span> <span data-ttu-id="fca8f-126">内存优化的表和本机编译的存储过程支持 [!INCLUDE[tsql](../../../includes/tsql-md.md)]的一个子集。</span><span class="sxs-lookup"><span data-stu-id="fca8f-126">Memory-optimized tables and natively compiled stored procedures support a subset of [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="fca8f-127">内存中 OLTP 支持事务持续性延迟的持久表。</span><span class="sxs-lookup"><span data-stu-id="fca8f-127">In-Memory OLTP supports durable tables with transaction durability delayed.</span></span> <span data-ttu-id="fca8f-128">延迟的持久事务在提交事务后不久即保存到磁盘。</span><span class="sxs-lookup"><span data-stu-id="fca8f-128">Delayed durable transactions are saved to disk soon after the transaction has committed.</span></span> <span data-ttu-id="fca8f-129">作为提高性能的代价，在服务器崩溃或故障转移过程中将丢失已提交但未保存到磁盘的事务。</span><span class="sxs-lookup"><span data-stu-id="fca8f-129">In exchange for the increased performance, committed transactions that have not saved to disk are lost in a server crash or failover.</span></span>  
  
 <span data-ttu-id="fca8f-130">除了默认持久的内存优化表之外， [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 还支持非持久的内存优化表，不记录这些表的日志且不在磁盘上保存它们的数据。</span><span class="sxs-lookup"><span data-stu-id="fca8f-130">Besides the default durable memory-optimized tables, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also supports non-durable memory-optimized tables, which are not logged and their data is not persisted on disk.</span></span> <span data-ttu-id="fca8f-131">这意味着这些表上的事务不需要任何磁盘 IO，但如果服务器崩溃或进行故障转移，则无法恢复数据。</span><span class="sxs-lookup"><span data-stu-id="fca8f-131">This means that transactions on these tables do not require any disk IO, but the data will not be recovered if there is a server crash or failover.</span></span>  
  
## <a name="accessing-data-in-memory-optimized-tables"></a><span data-ttu-id="fca8f-132">访问内存优化表中的数据</span><span class="sxs-lookup"><span data-stu-id="fca8f-132">Accessing Data in Memory-Optimized Tables</span></span>  
 <span data-ttu-id="fca8f-133">可通过以下两种方式访问内存优化表中的数据：</span><span class="sxs-lookup"><span data-stu-id="fca8f-133">Data in memory-optimized tables is accessed in two ways:</span></span>  
  
-   <span data-ttu-id="fca8f-134">通过解释型 [!INCLUDE[tsql](../../../includes/tsql-md.md)] （本机编译存储过程之外）。</span><span class="sxs-lookup"><span data-stu-id="fca8f-134">Through interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] (outside of a natively-compiled stored procedure).</span></span> <span data-ttu-id="fca8f-135">这些 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 语句可位于解释型存储过程内，也可以是临时 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 语句。</span><span class="sxs-lookup"><span data-stu-id="fca8f-135">These [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements may be either inside interpreted stored procedures or they may be ad-hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="fca8f-136">通过本机编译的存储过程。</span><span class="sxs-lookup"><span data-stu-id="fca8f-136">Through natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="fca8f-137">可以最高效地从本机编译的存储过程访问内存优化表（[本机编译的存储过程](natively-compiled-stored-procedures.md)）。</span><span class="sxs-lookup"><span data-stu-id="fca8f-137">Memory-optimized tables can be accessed most efficiently from natively compiled stored procedures ([Natively Compiled Stored Procedures](natively-compiled-stored-procedures.md)).</span></span> <span data-ttu-id="fca8f-138">还可以使用（传统的）解释型 [!INCLUDE[tsql](../../../includes/tsql-md.md)]访问内存优化表。</span><span class="sxs-lookup"><span data-stu-id="fca8f-138">Memory-optimized tables can also be accessed with (traditional) interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="fca8f-139">解释型 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 是指在不使用本机编译的存储过程的情况下访问内存优化表。</span><span class="sxs-lookup"><span data-stu-id="fca8f-139">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] refers to accessing memory-optimized tables without a natively compiled stored procedure.</span></span> <span data-ttu-id="fca8f-140">解释型 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 访问的一些示例包括从 DML 触发器、即席 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 批处理、视图和表值函数访问内存优化表。</span><span class="sxs-lookup"><span data-stu-id="fca8f-140">Some examples of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access include accessing a memory-optimized table from a DML trigger, ad hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] batch, view, and table-valued function.</span></span>  
  
 <span data-ttu-id="fca8f-141">下表总结了对各种对象的本机和解释型 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 访问。</span><span class="sxs-lookup"><span data-stu-id="fca8f-141">The following table summarizes native and interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access for various objects.</span></span>  
  
|<span data-ttu-id="fca8f-142">Feature</span><span class="sxs-lookup"><span data-stu-id="fca8f-142">Feature</span></span>|<span data-ttu-id="fca8f-143">使用本机编译的存储过程访问</span><span class="sxs-lookup"><span data-stu-id="fca8f-143">Access Using a Natively Compiled Stored Procedure</span></span>|<span data-ttu-id="fca8f-144">解释型 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 访问</span><span class="sxs-lookup"><span data-stu-id="fca8f-144">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access</span></span>|<span data-ttu-id="fca8f-145">CLR 访问</span><span class="sxs-lookup"><span data-stu-id="fca8f-145">CLR Access</span></span>|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|<span data-ttu-id="fca8f-146">内存优化表</span><span class="sxs-lookup"><span data-stu-id="fca8f-146">Memory-optimized tables</span></span>|<span data-ttu-id="fca8f-147">是</span><span class="sxs-lookup"><span data-stu-id="fca8f-147">Yes</span></span>|<span data-ttu-id="fca8f-148">是</span><span class="sxs-lookup"><span data-stu-id="fca8f-148">Yes</span></span>|<span data-ttu-id="fca8f-149">否 <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="fca8f-149">No <sup>1</sup></span></span>|  
|[<span data-ttu-id="fca8f-150">内存优化表变量</span><span class="sxs-lookup"><span data-stu-id="fca8f-150">Memory-Optimized Table Variables</span></span>](../../database-engine/memory-optimized-table-variables.md)|<span data-ttu-id="fca8f-151">是</span><span class="sxs-lookup"><span data-stu-id="fca8f-151">Yes</span></span>|<span data-ttu-id="fca8f-152">是</span><span class="sxs-lookup"><span data-stu-id="fca8f-152">Yes</span></span>|<span data-ttu-id="fca8f-153">否</span><span class="sxs-lookup"><span data-stu-id="fca8f-153">No</span></span>|  
|[<span data-ttu-id="fca8f-154">本机编译的存储过程</span><span class="sxs-lookup"><span data-stu-id="fca8f-154">Natively Compiled Stored Procedures</span></span>](https://msdn.microsoft.com/library/dn133184.aspx)|<span data-ttu-id="fca8f-155">无法使用 EXECUTE 语句从本机编译的存储过程执行任意存储过程。</span><span class="sxs-lookup"><span data-stu-id="fca8f-155">You cannot use the EXECUTE statement to execute any stored procedure from a natively compiled stored procedure.</span></span>|<span data-ttu-id="fca8f-156">是</span><span class="sxs-lookup"><span data-stu-id="fca8f-156">Yes</span></span>|<span data-ttu-id="fca8f-157">否 <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="fca8f-157">No <sup>1</sup></span></span>|  
  
 <span data-ttu-id="fca8f-158"><sup>1</sup>不能从上下文连接访问内存优化表或本机编译的存储过程， (从 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 执行 CLR 模块) 时的连接。</span><span class="sxs-lookup"><span data-stu-id="fca8f-158"><sup>1</sup> You cannot access a memory-optimized table or natively compiled stored procedure from the context connection (the connection from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] when executing a CLR module).</span></span> <span data-ttu-id="fca8f-159">但是，可以创建和打开能够访问内存优化的表和本机编译的存储过程的其他连接。</span><span class="sxs-lookup"><span data-stu-id="fca8f-159">You can, however, create and open another connection from which you can access memory-optimized tables and natively compiled stored procedures.</span></span> <span data-ttu-id="fca8f-160">有关详细信息，请参阅[常规连接和上下文连接](../clr-integration/data-access/context-connections-vs-regular-connections.md)。</span><span class="sxs-lookup"><span data-stu-id="fca8f-160">For more information, see [Regular vs. Context Connections](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span></span>  
  
## <a name="performance-and-scalability"></a><span data-ttu-id="fca8f-161">性能和可伸缩性</span><span class="sxs-lookup"><span data-stu-id="fca8f-161">Performance and Scalability</span></span>  
 <span data-ttu-id="fca8f-162">以下因素会影响可以通过内存中 OLTP 实现的性能提升：</span><span class="sxs-lookup"><span data-stu-id="fca8f-162">The following factors will affect the performance gains that can be achieved with In-Memory OLTP:</span></span>  
  
 <span data-ttu-id="fca8f-163">沟通</span><span class="sxs-lookup"><span data-stu-id="fca8f-163">Communication</span></span>  
 <span data-ttu-id="fca8f-164">与包含较少调用且每个存储过程中实现的功能较多的应用程序相比，具有许多短存储过程调用的应用程序的性能提升可能较小。</span><span class="sxs-lookup"><span data-stu-id="fca8f-164">An application with many calls to short stored procedures may see a smaller performance gain compared to an application with fewer calls and more functionality implemented in each stored procedure.</span></span>  
  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="fca8f-165">执行</span><span class="sxs-lookup"><span data-stu-id="fca8f-165">Execution</span></span>  
 <span data-ttu-id="fca8f-166">在使用本机编译的存储过程而不是解释的存储过程或查询执行时，内存中 OLTP 实现最佳性能。</span><span class="sxs-lookup"><span data-stu-id="fca8f-166">In-Memory OLTP achieves the best performance when using natively compiled stored procedures rather than interpreted stored procedures or query execution.</span></span> <span data-ttu-id="fca8f-167">存储过程如执行其他存储过程，则无法本机编译前者，但从此类存储过程中访问内存优化的表可存在优点。</span><span class="sxs-lookup"><span data-stu-id="fca8f-167">Stored procedures that execute other stored procedures cannot be natively compiled, but there can be a benefit to accessing memory-optimized tables from such stored procedures.</span></span>  
  
 <span data-ttu-id="fca8f-168">范围扫描与点查找</span><span class="sxs-lookup"><span data-stu-id="fca8f-168">Range Scan vs Point Lookup</span></span>  
 <span data-ttu-id="fca8f-169">内存优化的非聚集索引支持范围扫描和有序扫描。</span><span class="sxs-lookup"><span data-stu-id="fca8f-169">Memory-optimized nonclustered indexes support range scans and ordered scans.</span></span> <span data-ttu-id="fca8f-170">对于点查找，内存优化的哈希索引具有比内存优化的非聚集索引更好的性能。</span><span class="sxs-lookup"><span data-stu-id="fca8f-170">For point lookups, memory-optimized hash indexes have better performance than memory-optimized nonclustered indexes.</span></span> <span data-ttu-id="fca8f-171">内存优化的非聚集索引具有比基于磁盘的索引更好的性能。</span><span class="sxs-lookup"><span data-stu-id="fca8f-171">Memory-optimized nonclustered indexes have better performance than disk-based indexes.</span></span>  
  
 <span data-ttu-id="fca8f-172">索引操作不记入日志并且只存在于内存中。</span><span class="sxs-lookup"><span data-stu-id="fca8f-172">Index operations are not logged and they exist only in memory.</span></span>  
  
 <span data-ttu-id="fca8f-173">并发</span><span class="sxs-lookup"><span data-stu-id="fca8f-173">Concurrency</span></span>  
 <span data-ttu-id="fca8f-174">在性能受引擎级别并发（如闩锁争用或阻塞）影响的应用程序迁移到内存中 OLTP 时，其性能会显著提高。</span><span class="sxs-lookup"><span data-stu-id="fca8f-174">Applications whose performance is affected by engine-level concurrency, such as latch contention or blocking, improves significantly when the application moves to In-Memory OLTP.</span></span>  
  
 <span data-ttu-id="fca8f-175">下表列出了关系数据库中常见的性能和可伸缩性问题以及内存中 OLTP 提高性能的方式。</span><span class="sxs-lookup"><span data-stu-id="fca8f-175">The following table lists the performance and scalability issues that are commonly found in relational databases and how In-Memory OLTP can improve performance.</span></span>  
  
|<span data-ttu-id="fca8f-176">问题</span><span class="sxs-lookup"><span data-stu-id="fca8f-176">Issue</span></span>|<span data-ttu-id="fca8f-177">内存中 OLTP 影响</span><span class="sxs-lookup"><span data-stu-id="fca8f-177">In-Memory OLTP Impact</span></span>|  
|-----------|----------------------------|  
|<span data-ttu-id="fca8f-178">性能</span><span class="sxs-lookup"><span data-stu-id="fca8f-178">Performance</span></span><br /><br /> <span data-ttu-id="fca8f-179">资源（CPU、I/O、网络或内存）使用率较高。</span><span class="sxs-lookup"><span data-stu-id="fca8f-179">High resource (CPU, I/O, network or memory) usage.</span></span>|<span data-ttu-id="fca8f-180">CPU</span><span class="sxs-lookup"><span data-stu-id="fca8f-180">CPU</span></span><br /> <span data-ttu-id="fca8f-181">本机编译的存储过程可大幅降低 CPU 使用率，因为此类存储过程执行 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 语句所需的指令比解释型存储过程少得多。</span><span class="sxs-lookup"><span data-stu-id="fca8f-181">Natively compiled stored procedures can lower CPU usage significantly because they require significantly fewer instructions to execute a [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement compared to interpreted stored procedures.</span></span><br /><br /> <span data-ttu-id="fca8f-182">内存中 OLTP 可以帮助减少扩展工作负荷时的硬件投资，因为一台服务器可提供五到十台服务器的吞吐量。</span><span class="sxs-lookup"><span data-stu-id="fca8f-182">In-Memory OLTP can help reduce the hardware investment in scaled-out workloads because one server can potentially deliver the throughput of five to ten servers.</span></span><br /><br /> <span data-ttu-id="fca8f-183">I/O</span><span class="sxs-lookup"><span data-stu-id="fca8f-183">I/O</span></span><br /> <span data-ttu-id="fca8f-184">如果在处理数据或索引页方面遇到 I/O 瓶颈，则内存中 OLTP 可缓解瓶颈现象。</span><span class="sxs-lookup"><span data-stu-id="fca8f-184">If you encounter an I/O bottleneck from processing to data or index pages, In-Memory OLTP may reduce the bottleneck.</span></span> <span data-ttu-id="fca8f-185">此外，内存中 OLTP 对象的检查点编号是连续的，不会导致 I/O 操作突然增多。</span><span class="sxs-lookup"><span data-stu-id="fca8f-185">Additionally, the checkpointing of In-Memory OLTP objects is continuous and does not lead to sudden increases in I/O operations.</span></span> <span data-ttu-id="fca8f-186">但是，如果对性能至关重要的表的工作集不能容纳于内存中，则内存中 OLTP 不会提高性能，因为它需要数据驻留在内存中。</span><span class="sxs-lookup"><span data-stu-id="fca8f-186">However, if the working set of the performance critical tables does not fit in memory, In-Memory OLTP will not improve performance because it requires data to be memory resident.</span></span> <span data-ttu-id="fca8f-187">如果在日志记录方面遇到 I/O 瓶颈，则内存中 OLTP 可缓解瓶颈现象，因为它进行的日志记录操作较少。</span><span class="sxs-lookup"><span data-stu-id="fca8f-187">If you encounter an I/O bottleneck in logging, In-Memory OLTP can reduce the bottleneck because it does less logging.</span></span> <span data-ttu-id="fca8f-188">如果将一个或多个内存优化的表配置为非持久的表，您可以消除数据的日志记录。</span><span class="sxs-lookup"><span data-stu-id="fca8f-188">If one or more memory-optimized tables are configured as non-durable tables, you can eliminate logging for data.</span></span><br /><br /> <span data-ttu-id="fca8f-189">内存</span><span class="sxs-lookup"><span data-stu-id="fca8f-189">Memory</span></span><br /> <span data-ttu-id="fca8f-190">内存中 OLTP 不会提供任何性能优势。</span><span class="sxs-lookup"><span data-stu-id="fca8f-190">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="fca8f-191">内存中 OLTP 可能会对内存产生额外的压力，因为这些对象需要驻留在内存中。</span><span class="sxs-lookup"><span data-stu-id="fca8f-191">In-Memory OLTP can put extra pressure on memory as the objects need to be memory resident.</span></span><br /><br /> <span data-ttu-id="fca8f-192">网络</span><span class="sxs-lookup"><span data-stu-id="fca8f-192">Network</span></span><br /> <span data-ttu-id="fca8f-193">内存中 OLTP 不会提供任何性能优势。</span><span class="sxs-lookup"><span data-stu-id="fca8f-193">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="fca8f-194">数据需要从数据层传输到应用层。</span><span class="sxs-lookup"><span data-stu-id="fca8f-194">The data needs to be communicated from data tier to application tier.</span></span>|  
|<span data-ttu-id="fca8f-195">可伸缩性</span><span class="sxs-lookup"><span data-stu-id="fca8f-195">Scalability</span></span><br /><br /> <span data-ttu-id="fca8f-196">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 应用程序中的大多数伸缩问题是由并发问题（如锁、闩锁和旋转锁中的争用）引起的。</span><span class="sxs-lookup"><span data-stu-id="fca8f-196">Most scaling issues in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] applications are caused by concurrency issues such as contention in locks, latches, and spinlocks.</span></span>|<span data-ttu-id="fca8f-197">闩锁争用</span><span class="sxs-lookup"><span data-stu-id="fca8f-197">Latch Contention</span></span><br /> <span data-ttu-id="fca8f-198">典型情况是按键顺序并发插入行时索引的最后一页上的争用。</span><span class="sxs-lookup"><span data-stu-id="fca8f-198">A typical scenario is contention on the last page of an index when inserting rows concurrently in key order.</span></span> <span data-ttu-id="fca8f-199">由于内存中 OLTP 在访问数据时不采用闩锁，因此可完全消除与闩锁争用相关的可伸缩性问题。</span><span class="sxs-lookup"><span data-stu-id="fca8f-199">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to latch contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="fca8f-200">旋转锁争用</span><span class="sxs-lookup"><span data-stu-id="fca8f-200">Spinlock Contention</span></span><br /> <span data-ttu-id="fca8f-201">由于内存中 OLTP 在访问数据时不采用闩锁，因此可完全消除与旋转锁争用相关的可伸缩性问题。</span><span class="sxs-lookup"><span data-stu-id="fca8f-201">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to spinlock contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="fca8f-202">与锁定相关的争用</span><span class="sxs-lookup"><span data-stu-id="fca8f-202">Locking Related Contention</span></span><br /> <span data-ttu-id="fca8f-203">如果数据库应用程序遇到读操作与写操作之间的阻塞问题，则内存中 OLTP 可消除这些阻塞问题，因为它使用新的乐观并发控制形式来实现所有事务隔离级别。</span><span class="sxs-lookup"><span data-stu-id="fca8f-203">If your database application encounters blocking issues between read and write operations, In-Memory OLTP removes the blocking issues because it uses a new form of optimistic concurrency control to implement all transaction isolation levels.</span></span> <span data-ttu-id="fca8f-204">内存中 OLTP 不使用 TempDB 来存储行版本。</span><span class="sxs-lookup"><span data-stu-id="fca8f-204">In-Memory OLTP does not use TempDB to store row versions.</span></span><br /><br /> <span data-ttu-id="fca8f-205">如果伸缩问题是由两个写操作之间的冲突（例如，两个并发事务尝试更新相同的行）引起的，则内存中 OLTP 会让其中一个事务成功，而让另一个事务失败。</span><span class="sxs-lookup"><span data-stu-id="fca8f-205">If the scaling issue is caused by conflict between two write operations, such as two concurrent transactions trying to update the same row, In-Memory OLTP lets one transaction succeed and fails the other transaction.</span></span> <span data-ttu-id="fca8f-206">必须显式或隐式重新提交失败的事务，从而重试该事物。</span><span class="sxs-lookup"><span data-stu-id="fca8f-206">The failed transaction must be re-submitted either explicitly or implicitly, re-trying the transaction.</span></span> <span data-ttu-id="fca8f-207">在任一情况下，您都需要对应用程序进行更改。</span><span class="sxs-lookup"><span data-stu-id="fca8f-207">In either case, you need to make changes to the application.</span></span><br /><br /> <span data-ttu-id="fca8f-208">如果应用程序遇到两个写操作之间的频繁冲突，则会减小乐观锁定的值。</span><span class="sxs-lookup"><span data-stu-id="fca8f-208">If your application experiences frequent conflicts between two write operations, the value of optimistic locking is diminished.</span></span> <span data-ttu-id="fca8f-209">该应用程序不适用于内存中 OLTP。</span><span class="sxs-lookup"><span data-stu-id="fca8f-209">The application is not suitable for In-Memory OLTP.</span></span> <span data-ttu-id="fca8f-210">除非冲突是由锁升级引起的，否则大多数 OLTP 应用程序没有写冲突。</span><span class="sxs-lookup"><span data-stu-id="fca8f-210">Most OLTP applications don't have a write conflicts unless the conflict is induced by lock escalation.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="fca8f-211">另请参阅</span><span class="sxs-lookup"><span data-stu-id="fca8f-211">See Also</span></span>  
 [<span data-ttu-id="fca8f-212">内存中 OLTP（内存中优化）</span><span class="sxs-lookup"><span data-stu-id="fca8f-212">In-Memory OLTP &#40;In-Memory Optimization&#41;</span></span>](in-memory-oltp-in-memory-optimization.md)  
  
  
