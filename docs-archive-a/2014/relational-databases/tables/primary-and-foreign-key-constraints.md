---
title: 主键和外键约束 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
helpviewer_keywords:
- foreign keys [SQL Server], cascading referential integrity
- FOREIGN KEY constraints
- foreign keys [SQL Server]
- foreign keys [SQL Server], about foreign key constraints
ms.assetid: 31fbcc9f-2dc5-4bf9-aa50-ed70ec7b5bcd
author: stevestein
ms.author: sstein
ms.openlocfilehash: b6e7b88de880348fabb00cb46d3028716441bc2b
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87589460"
---
# <a name="primary-and-foreign-key-constraints"></a><span data-ttu-id="bf080-102">主键和外键约束</span><span class="sxs-lookup"><span data-stu-id="bf080-102">Primary and Foreign Key Constraints</span></span>
  <span data-ttu-id="bf080-103">主键和外键是两种类型的约束，可用于强制 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 表中的数据完整性。</span><span class="sxs-lookup"><span data-stu-id="bf080-103">Primary keys and foreign keys are two types of constraints that can be used to enforce data integrity in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] tables.</span></span> <span data-ttu-id="bf080-104">这些是重要的数据库对象。</span><span class="sxs-lookup"><span data-stu-id="bf080-104">These are important database objects.</span></span>

 <span data-ttu-id="bf080-105">本主题包含以下各节。</span><span class="sxs-lookup"><span data-stu-id="bf080-105">This topic contains the following sections.</span></span>

 [<span data-ttu-id="bf080-106">主键约束</span><span class="sxs-lookup"><span data-stu-id="bf080-106">Primary Key Constraints</span></span>](../tables/primary-and-foreign-key-constraints.md#PKeys)

 [<span data-ttu-id="bf080-107">Foreign Key Constraints</span><span class="sxs-lookup"><span data-stu-id="bf080-107">Foreign Key Constraints</span></span>](../tables/primary-and-foreign-key-constraints.md#FKeys)

 [<span data-ttu-id="bf080-108">相关任务</span><span class="sxs-lookup"><span data-stu-id="bf080-108">Related Tasks</span></span>](../tables/primary-and-foreign-key-constraints.md#Tasks)

##  <a name="primary-key-constraints"></a><a name="PKeys"></a> <span data-ttu-id="bf080-109">主键约束</span><span class="sxs-lookup"><span data-stu-id="bf080-109">Primary Key Constraints</span></span>
 <span data-ttu-id="bf080-110">表通常具有包含唯一标识表中每一行的值的一列或一组列。</span><span class="sxs-lookup"><span data-stu-id="bf080-110">A table typically has a column or combination of columns that contain values that uniquely identify each row in the table.</span></span> <span data-ttu-id="bf080-111">这样的一列或多列称为表的主键 (PK)，用于强制表的实体完整性。</span><span class="sxs-lookup"><span data-stu-id="bf080-111">This column, or columns, is called the primary key (PK) of the table and enforces the entity integrity of the table.</span></span> <span data-ttu-id="bf080-112">由于主键约束可保证数据的唯一性，因此经常对标识列定义这种约束。</span><span class="sxs-lookup"><span data-stu-id="bf080-112">Because primary key constraints guarantee unique data, they are frequently defined on an identity column.</span></span>

 <span data-ttu-id="bf080-113">如果为表指定了主键约束， [!INCLUDE[ssDE](../../includes/ssde-md.md)] 将通过为主键列自动创建唯一索引来强制数据的唯一性。</span><span class="sxs-lookup"><span data-stu-id="bf080-113">When you specify a primary key constraint for a table, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] enforces data uniqueness by automatically creating a unique index for the primary key columns.</span></span> <span data-ttu-id="bf080-114">当在查询中使用主键时，此索引还允许对数据进行快速访问。</span><span class="sxs-lookup"><span data-stu-id="bf080-114">This index also permits fast access to data when the primary key is used in queries.</span></span> <span data-ttu-id="bf080-115">如果对多列定义了主键约束，则一列中的值可能会重复，但来自主键约束定义中所有列的值的任何组合必须唯一。</span><span class="sxs-lookup"><span data-stu-id="bf080-115">If a primary key constraint is defined on more than one column, values may be duplicated within one column, but each combination of values from all the columns in the primary key constraint definition must be unique.</span></span>

 <span data-ttu-id="bf080-116">如下图所示， **Purchasing.ProductVendor** 表中的 **ProductID** 和 **VendorID** 列构成了针对此表的复合主键约束。</span><span class="sxs-lookup"><span data-stu-id="bf080-116">As shown in the following illustration, the **ProductID** and **VendorID** columns in the **Purchasing.ProductVendor** table form a composite primary key constraint for this table.</span></span> <span data-ttu-id="bf080-117">这确保了 ProductVendor 表中的每个行都具有 ProductID 和 VendorID 的一个唯一组合    。</span><span class="sxs-lookup"><span data-stu-id="bf080-117">This makes sure that every row in the **ProductVendor** table has a unique combination of **ProductID** and **VendorID**.</span></span> <span data-ttu-id="bf080-118">这样可以防止插入重复的行。</span><span class="sxs-lookup"><span data-stu-id="bf080-118">This prevents the insertion of duplicate rows.</span></span>

 <span data-ttu-id="bf080-119">![组合 PRIMARY KEY 约束](../../database-engine/media/fund04.gif "组合 PRIMARY KEY 约束")</span><span class="sxs-lookup"><span data-stu-id="bf080-119">![Composite PRIMARY KEY constraint](../../database-engine/media/fund04.gif "Composite PRIMARY KEY constraint")</span></span>

-   <span data-ttu-id="bf080-120">一个表只能包含一个主键约束。</span><span class="sxs-lookup"><span data-stu-id="bf080-120">A table can contain only one primary key constraint.</span></span>

-   <span data-ttu-id="bf080-121">主键不能超过 16 列且总密钥长度不能超过 900 个字节。</span><span class="sxs-lookup"><span data-stu-id="bf080-121">A primary key cannot exceed 16 columns and a total key length of 900 bytes.</span></span>

-   <span data-ttu-id="bf080-122">由主键约束生成的索引不会使表中的索引数超过 999 个非聚集索引和 1 个聚集索引。</span><span class="sxs-lookup"><span data-stu-id="bf080-122">The index generated by a primary key constraint cannot cause the number of indexes on the table to exceed 999 nonclustered indexes and 1 clustered index.</span></span>

-   <span data-ttu-id="bf080-123">如果没有为主键约束指定聚集或非聚集索引，并且表中没有聚集索引，则使用聚集索引。</span><span class="sxs-lookup"><span data-stu-id="bf080-123">If clustered or nonclustered is not specified for a primary key constraint, clustered is used if there no clustered index on the table.</span></span>

-   <span data-ttu-id="bf080-124">在主键约束中定义的所有列都必须定义为不为 Null。</span><span class="sxs-lookup"><span data-stu-id="bf080-124">All columns defined within a primary key constraint must be defined as not null.</span></span> <span data-ttu-id="bf080-125">如果没有指定为 Null 性，则参与主键约束的所有列的为 Null 性都将设置为不为 Null。</span><span class="sxs-lookup"><span data-stu-id="bf080-125">If nullability is not specified, all columns participating in a primary key constraint have their nullability set to not null.</span></span>

-   <span data-ttu-id="bf080-126">如果在 CLR 用户定义类型的列中定义主键，则该类型的实现必须支持二进制排序。</span><span class="sxs-lookup"><span data-stu-id="bf080-126">If a primary key is defined on a CLR user-defined type column, the implementation of the type must support binary ordering.</span></span>

##  <a name="foreign-key-constraints"></a><a name="FKeys"></a> <span data-ttu-id="bf080-127">Foreign Key Constraints</span><span class="sxs-lookup"><span data-stu-id="bf080-127">Foreign Key Constraints</span></span>
 <span data-ttu-id="bf080-128">外键 (FK) 是用于在两个表中的数据之间建立和加强链接的一列或多列的组合，可控制可在外键表中存储的数据。</span><span class="sxs-lookup"><span data-stu-id="bf080-128">A foreign key (FK) is a column or combination of columns that is used to establish and enforce a link between the data in two tables to control the data that can be stored in the foreign key table.</span></span> <span data-ttu-id="bf080-129">在外键引用中，当包含一个表的主键值的一个或多个列被另一个表中的一个或多个列引用时，就在这两个表之间创建了链接。</span><span class="sxs-lookup"><span data-stu-id="bf080-129">In a foreign key reference, a link is created between two tables when the column or columns that hold the primary key value for one table are referenced by the column or columns in another table.</span></span> <span data-ttu-id="bf080-130">这个列就成为第二个表的外键。</span><span class="sxs-lookup"><span data-stu-id="bf080-130">This column becomes a foreign key in the second table.</span></span>

 <span data-ttu-id="bf080-131">例如，因为销售订单和销售人员之间存在一种逻辑关系，所以 **Sales.SalesOrderHeader** 表含有一个指向 **Sales.SalesPerson** 表的外键链接。</span><span class="sxs-lookup"><span data-stu-id="bf080-131">For example, the **Sales.SalesOrderHeader** table has a foreign key link to the **Sales.SalesPerson** table because there is a logical relationship between sales orders and salespeople.</span></span> <span data-ttu-id="bf080-132">**SalesOrderHeader** 表中的 **SalesPersonID** 列与 **SalesPerson** 表中的主键列相对应。</span><span class="sxs-lookup"><span data-stu-id="bf080-132">The **SalesPersonID** column in the **SalesOrderHeader** table matches the primary key column of the **SalesPerson** table.</span></span> <span data-ttu-id="bf080-133">**SalesOrderHeader** 表中的 **SalesPersonID** 列是指向 **SalesPerson** 表的外键。</span><span class="sxs-lookup"><span data-stu-id="bf080-133">The **SalesPersonID** column in the **SalesOrderHeader** table is the foreign key to the **SalesPerson** table.</span></span> <span data-ttu-id="bf080-134">通过创建此外键关系，如果 **SalesPerson** 表的主键中不存在 SalesPersonID 的值，则 **SalesPersonID** 的值将无法插入到 **SalesOrderHeader** 表。</span><span class="sxs-lookup"><span data-stu-id="bf080-134">By creating this foreign key relationship, a value for **SalesPersonID** cannot be inserted into the **SalesOrderHeader** table if it does not already exist in the **SalesPerson** table.</span></span>

### <a name="indexes-on-foreign-key-constraints"></a><span data-ttu-id="bf080-135">外键约束的索引</span><span class="sxs-lookup"><span data-stu-id="bf080-135">Indexes on Foreign Key Constraints</span></span>
 <span data-ttu-id="bf080-136">与主键约束不同，创建外键约束不会自动创建对应的索引。</span><span class="sxs-lookup"><span data-stu-id="bf080-136">Unlike primary key constraints, creating a foreign key constraint does not automatically create a corresponding index.</span></span> <span data-ttu-id="bf080-137">但是由于以下原因，对外键手动创建索引通常是有用的：</span><span class="sxs-lookup"><span data-stu-id="bf080-137">However, manually creating an index on a foreign key is often useful for the following reasons:</span></span>

-   <span data-ttu-id="bf080-138">当在查询中组合相关表中的数据时，经常在联接条件中使用外键列，方法是将一个表的外键约束中的一列或多列与另一个表中的主键列或唯一键列匹配。</span><span class="sxs-lookup"><span data-stu-id="bf080-138">Foreign key columns are frequently used in join criteria when the data from related tables is combined in queries by matching the column or columns in the foreign key constraint of one table with the primary or unique key column or columns in the other table.</span></span> <span data-ttu-id="bf080-139">索引使 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 可以在外键表中快速查找相关数据。</span><span class="sxs-lookup"><span data-stu-id="bf080-139">An index enables the [!INCLUDE[ssDE](../../includes/ssde-md.md)] to quickly find related data in the foreign key table.</span></span> <span data-ttu-id="bf080-140">但是，创建此索引并不是必需的。</span><span class="sxs-lookup"><span data-stu-id="bf080-140">However, creating this index is not required.</span></span> <span data-ttu-id="bf080-141">即使没有对两个相关表定义主键或外键约束，也可以对来自这两个表中的数据进行组合，但两个表间的外键关系说明已用其键作为条件对其进行了优化，以便组合到查询中。</span><span class="sxs-lookup"><span data-stu-id="bf080-141">Data from two related tables can be combined even if no primary key or foreign key constraints are defined between the tables, but a foreign key relationship between two tables indicates that the two tables have been optimized to be combined in a query that uses the keys as its criteria.</span></span>

-   <span data-ttu-id="bf080-142">对主键约束的更改可由相关表中的外键约束检查。</span><span class="sxs-lookup"><span data-stu-id="bf080-142">Changes to primary key constraints are checked with foreign key constraints in related tables.</span></span>

### <a name="referential-integrity"></a><span data-ttu-id="bf080-143">引用完整性</span><span class="sxs-lookup"><span data-stu-id="bf080-143">Referential Integrity</span></span>
 <span data-ttu-id="bf080-144">尽管外键约束的主要目的是控制可以存储在外键表中的数据，但它还可以控制对主键表中数据的更改。</span><span class="sxs-lookup"><span data-stu-id="bf080-144">Although the main purpose of a foreign key constraint is to control the data that can be stored in the foreign key table, it also controls changes to data in the primary key table.</span></span> <span data-ttu-id="bf080-145">例如，如果在 **Sales.SalesPerson** 表中删除一个销售人员行，而这个销售人员的 ID 由 **Sales.SalesOrderHeader** 表中的销售订单使用，则这两个表之间关联的完整性将被破坏； **SalesOrderHeader** 表中删除的销售人员的销售订单因为与 **SalesPerson** 表中的数据没有链接而变得孤立了。</span><span class="sxs-lookup"><span data-stu-id="bf080-145">For example, if the row for a salesperson is deleted from the **Sales.SalesPerson** table, and the salesperson's ID is used for sales orders in the **Sales.SalesOrderHeader** table, the relational integrity between the two tables is broken; the deleted salesperson's sales orders are orphaned in the **SalesOrderHeader** table without a link to the data in the **SalesPerson** table.</span></span>

 <span data-ttu-id="bf080-146">外键约束防止这种情况发生。</span><span class="sxs-lookup"><span data-stu-id="bf080-146">A foreign key constraint prevents this situation.</span></span> <span data-ttu-id="bf080-147">如果主键表中数据的更改使之与外键表中数据的链接失效，则这种更改将无法实现，从而确保了引用完整性。</span><span class="sxs-lookup"><span data-stu-id="bf080-147">The constraint enforces referential integrity by guaranteeing that changes cannot be made to data in the primary key table if those changes invalidate the link to data in the foreign key table.</span></span> <span data-ttu-id="bf080-148">如果试图删除主键表中的行或更改主键值，而该主键值与另一个表的外键约束中的值相对应，则该操作将失败。</span><span class="sxs-lookup"><span data-stu-id="bf080-148">If an attempt is made to delete the row in a primary key table or to change a primary key value, the action will fail when the deleted or changed primary key value corresponds to a value in the foreign key constraint of another table.</span></span> <span data-ttu-id="bf080-149">若要成功更改或删除外键约束中的行，必须先在外键表中删除或更改外键数据，这会将外键链接到不同的主键数据。</span><span class="sxs-lookup"><span data-stu-id="bf080-149">To successfully change or delete a row in a foreign key constraint, you must first either delete the foreign key data in the foreign key table or change the foreign key data in the foreign key table, which links the foreign key to different primary key data.</span></span>

#### <a name="cascading-referential-integrity"></a><span data-ttu-id="bf080-150">级联引用完整性</span><span class="sxs-lookup"><span data-stu-id="bf080-150">Cascading Referential Integrity</span></span>
 <span data-ttu-id="bf080-151">通过使用级联引用完整性约束，您可以定义当用户试图删除或更新现有外键指向的键时， [!INCLUDE[ssDE](../../includes/ssde-md.md)] 执行的操作。</span><span class="sxs-lookup"><span data-stu-id="bf080-151">By using cascading referential integrity constraints, you can define the actions that the [!INCLUDE[ssDE](../../includes/ssde-md.md)] takes when a user tries to delete or update a key to which existing foreign keys point.</span></span> <span data-ttu-id="bf080-152">可以定义以下级联操作。</span><span class="sxs-lookup"><span data-stu-id="bf080-152">The following cascading actions can be defined.</span></span>

 <span data-ttu-id="bf080-153">无操作将 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 引发错误，并回滚对父表中行的删除或更新操作。</span><span class="sxs-lookup"><span data-stu-id="bf080-153">NO ACTION The [!INCLUDE[ssDE](../../includes/ssde-md.md)] raises an error and the delete or update action on the row in the parent table is rolled back.</span></span>

 <span data-ttu-id="bf080-154">在父表中更新或删除行时，将在引用表中更新或删除层叠对应行。</span><span class="sxs-lookup"><span data-stu-id="bf080-154">CASCADE Corresponding rows are updated or deleted in the referencing table when that row is updated or deleted in the parent table.</span></span> <span data-ttu-id="bf080-155">如果 `timestamp` 列是外键或被引用键的一部分，则不能指定 CASCADE。</span><span class="sxs-lookup"><span data-stu-id="bf080-155">CASCADE cannot be specified if a `timestamp` column is part of either the foreign key or the referenced key.</span></span> <span data-ttu-id="bf080-156">不能为带有 INSTEAD OF DELETE 触发器的表指定 ON DELETE CASCADE。</span><span class="sxs-lookup"><span data-stu-id="bf080-156">ON DELETE CASCADE cannot be specified for a table that has an INSTEAD OF DELETE trigger.</span></span> <span data-ttu-id="bf080-157">对于带有 INSTEAD OF UPDATE 触发器的表，不能指定 ON UPDATE CASCADE。</span><span class="sxs-lookup"><span data-stu-id="bf080-157">ON UPDATE CASCADE cannot be specified for tables that have INSTEAD OF UPDATE triggers.</span></span>

 <span data-ttu-id="bf080-158">设置为 NULL 如果更新或删除了父表中的相应行，则会将构成外键的所有值设置为 NULL。</span><span class="sxs-lookup"><span data-stu-id="bf080-158">SET NULL All the values that make up the foreign key are set to NULL when the corresponding row in the parent table is updated or deleted.</span></span> <span data-ttu-id="bf080-159">若要执行此约束，外键列必须可为空值。</span><span class="sxs-lookup"><span data-stu-id="bf080-159">For this constraint to execute, the foreign key columns must be nullable.</span></span> <span data-ttu-id="bf080-160">无法为带有 INSTEAD OF UPDATE 触发器的表指定。</span><span class="sxs-lookup"><span data-stu-id="bf080-160">Cannot be specified for tables that have INSTEAD OF UPDATE triggers.</span></span>

 <span data-ttu-id="bf080-161">设置默认值如果在父表中更新或删除了父表中的相应行，则会将构成外键的所有值设置为其默认值。</span><span class="sxs-lookup"><span data-stu-id="bf080-161">SET DEFAULT All the values that make up the foreign key are set to their default values if the corresponding row in the parent table is updated or deleted.</span></span> <span data-ttu-id="bf080-162">若要执行此约束，所有外键列都必须有默认定义。</span><span class="sxs-lookup"><span data-stu-id="bf080-162">For this constraint to execute, all foreign key columns must have default definitions.</span></span> <span data-ttu-id="bf080-163">如果某个列可为空值，并且未设置显式的默认值，则将使用 NULL 作为该列的隐式默认值。</span><span class="sxs-lookup"><span data-stu-id="bf080-163">If a column is nullable, and there is no explicit default value set, NULL becomes the implicit default value of the column.</span></span> <span data-ttu-id="bf080-164">无法为带有 INSTEAD OF UPDATE 触发器的表指定。</span><span class="sxs-lookup"><span data-stu-id="bf080-164">Cannot be specified for tables that have INSTEAD OF UPDATE triggers.</span></span>

 <span data-ttu-id="bf080-165">可将 CASCADE、SET NULL、SET DEFAULT 和 NO ACTION 在相互存在引用关系的表上进行组合。</span><span class="sxs-lookup"><span data-stu-id="bf080-165">CASCADE, SET NULL, SET DEFAULT and NO ACTION can be combined on tables that have referential relationships with each other.</span></span> <span data-ttu-id="bf080-166">如果 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 遇到 NO ACTION，它将停止并回滚相关的 CASCADE、SET NULL 和 SET DEFAULT 操作。</span><span class="sxs-lookup"><span data-stu-id="bf080-166">If the [!INCLUDE[ssDE](../../includes/ssde-md.md)] encounters NO ACTION, it stops and rolls back related CASCADE, SET NULL and SET DEFAULT actions.</span></span> <span data-ttu-id="bf080-167">如果 DELETE 语句导致 CASCADE、SET NULL、SET DEFAULT 和 NO ACTION 操作的组合，则在 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 检查所有 NO ACTION 前，将应用所有 CASCADE、SET NULL 和 SET DEFAULT 操作。</span><span class="sxs-lookup"><span data-stu-id="bf080-167">When a DELETE statement causes a combination of CASCADE, SET NULL, SET DEFAULT and NO ACTION actions, all the CASCADE, SET NULL and SET DEFAULT actions are applied before the [!INCLUDE[ssDE](../../includes/ssde-md.md)] checks for any NO ACTION.</span></span>

### <a name="triggers-and-cascading-referential-actions"></a><span data-ttu-id="bf080-168">触发器和级联引用操作</span><span class="sxs-lookup"><span data-stu-id="bf080-168">Triggers and Cascading Referential Actions</span></span>
 <span data-ttu-id="bf080-169">级联引用操作按下列方式激发 AFTER UPDATE 或 AFTER DELETE 触发器：</span><span class="sxs-lookup"><span data-stu-id="bf080-169">Cascading referential actions fire the AFTER UPDATE or AFTER DELETE triggers in the following manner:</span></span>

-   <span data-ttu-id="bf080-170">首先执行由原始 DELETE 或 UPDATE 直接导致的所有级联引用操作。</span><span class="sxs-lookup"><span data-stu-id="bf080-170">All the cascading referential actions directly caused by the original DELETE or UPDATE are performed first.</span></span>

-   <span data-ttu-id="bf080-171">如果为受影响的表定义了任何 AFTER 触发器，则在执行完所有级联操作后激发这些触发器。</span><span class="sxs-lookup"><span data-stu-id="bf080-171">If there are any AFTER triggers defined on the affected tables, these triggers fire after all cascading actions are performed.</span></span> <span data-ttu-id="bf080-172">这些触发器将按与级联操作相反的顺序激发。</span><span class="sxs-lookup"><span data-stu-id="bf080-172">These triggers fire in opposite order of the cascading action.</span></span> <span data-ttu-id="bf080-173">如果单个表中存在多个触发器，它们将按随机顺序激发，除非专门为表指定了第一个或最后一个触发器。</span><span class="sxs-lookup"><span data-stu-id="bf080-173">If there are multiple triggers on a single table, they fire in random order, unless there is a dedicated first or last trigger for the table.</span></span> <span data-ttu-id="bf080-174">此顺序是使用 [sp_settriggerorder](/sql/relational-databases/system-stored-procedures/sp-settriggerorder-transact-sql)指定的。</span><span class="sxs-lookup"><span data-stu-id="bf080-174">This order is as specified by using [sp_settriggerorder](/sql/relational-databases/system-stored-procedures/sp-settriggerorder-transact-sql).</span></span>

-   <span data-ttu-id="bf080-175">如果多个级联链源自作为 UPDATE 或 DELETE 操作的直接目标的表，则这些链激发各自的触发器的顺序是不定的。</span><span class="sxs-lookup"><span data-stu-id="bf080-175">If multiple cascading chains originate from the table that was the direct target of an UPDATE or DELETE action, the order in which these chains fire their respective triggers is unspecified.</span></span> <span data-ttu-id="bf080-176">但是，只有当一条链激发其所有的触发器之后，另一条链才开始激发。</span><span class="sxs-lookup"><span data-stu-id="bf080-176">However, one chain always fires all its triggers before another chain starts firing.</span></span>

-   <span data-ttu-id="bf080-177">不管是否影响任何行，作为 UPDATE 或 DELETE 操作的直接目标的表上的 AFTER 触发器都会激发。</span><span class="sxs-lookup"><span data-stu-id="bf080-177">An AFTER trigger on the table that is the direct target of an UPDATE or DELETE action fires regardless of whether any rows are affected.</span></span> <span data-ttu-id="bf080-178">在这种情况下，级联操作不会影响其他表。</span><span class="sxs-lookup"><span data-stu-id="bf080-178">There are no other tables affected by cascading in this case.</span></span>

-   <span data-ttu-id="bf080-179">如果上面的任一触发器对其他表执行 UPDATE 或 DELETE 操作，这些操作将启动辅助级联链。</span><span class="sxs-lookup"><span data-stu-id="bf080-179">If any one of the previous triggers perform UPDATE or DELETE operations on other tables, these actions can start secondary cascading chains.</span></span> <span data-ttu-id="bf080-180">在激发所有主链上的所有触发器后，会分别为每个 UPDATE 或 DELETE 操作处理这些辅助链。</span><span class="sxs-lookup"><span data-stu-id="bf080-180">These secondary chains are processed for each UPDATE or DELETE operation at a time after all triggers on all primary chains fire.</span></span> <span data-ttu-id="bf080-181">可能会为后续的 UPDATE 或 DELETE 操作递归重复此过程。</span><span class="sxs-lookup"><span data-stu-id="bf080-181">This process may be recursively repeated for subsequent UPDATE or DELETE operations.</span></span>

-   <span data-ttu-id="bf080-182">在触发器内执行 CREATE、ALTER、DELETE 或其他数据定义语言 (DDL) 操作可能会导致 DDL 触发器激发。</span><span class="sxs-lookup"><span data-stu-id="bf080-182">Performing CREATE, ALTER, DELETE, or other data definition language (DDL) operations inside the triggers may cause DDL triggers to fire.</span></span> <span data-ttu-id="bf080-183">之后，就可能会执行启动其他级联链和触发器的 DELETE 或 UPDATE 操作。</span><span class="sxs-lookup"><span data-stu-id="bf080-183">This may subsequently perform DELETE or UPDATE operations that start additional cascading chains and triggers.</span></span>

-   <span data-ttu-id="bf080-184">如果任何特定的级联引用操作链中产生错误，都将引发错误并且不会在该链中激发任何 AFTER 触发器，而创建该链的 DELETE 或 UPDATE 操作将回滚。</span><span class="sxs-lookup"><span data-stu-id="bf080-184">If an error is generated inside any particular cascading referential action chain, an error is raised, no AFTER triggers are fired in that chain, and the DELETE or UPDATE operation that created the chain is rolled back.</span></span>

-   <span data-ttu-id="bf080-185">具有 INSTEAD OF 触发器的表不能同时具有指定级联操作的 REFERENCES 子句。</span><span class="sxs-lookup"><span data-stu-id="bf080-185">A table that has an INSTEAD OF trigger cannot also have a REFERENCES clause that specifies a cascading action.</span></span> <span data-ttu-id="bf080-186">但是，级联操作目标表的 AFTER 触发器可对另一个表或视图执行 INSERT、UPDATE 或 DELETE 语句，这将激发为该对象定义的 INSTEAD OF 触发器。</span><span class="sxs-lookup"><span data-stu-id="bf080-186">However, an AFTER trigger on a table targeted by a cascading action can execute an INSERT, UPDATE, or DELETE statement on another table or view that fires an INSTEAD OF trigger defined on that object.</span></span>

##  <a name="related-tasks"></a><a name="Tasks"></a> <span data-ttu-id="bf080-187">相关任务</span><span class="sxs-lookup"><span data-stu-id="bf080-187">Related Tasks</span></span>
 <span data-ttu-id="bf080-188">下表列出了与主键和外键约束关联的常见任务。</span><span class="sxs-lookup"><span data-stu-id="bf080-188">The following table lists the common tasks associated with primary key and foreign key constraints.</span></span>

|<span data-ttu-id="bf080-189">任务</span><span class="sxs-lookup"><span data-stu-id="bf080-189">Task</span></span>|<span data-ttu-id="bf080-190">主题</span><span class="sxs-lookup"><span data-stu-id="bf080-190">Topic</span></span>|
|----------|-----------|
|<span data-ttu-id="bf080-191">说明如何创建主键。</span><span class="sxs-lookup"><span data-stu-id="bf080-191">Describes how to create a primary key.</span></span>|[<span data-ttu-id="bf080-192">创建主键</span><span class="sxs-lookup"><span data-stu-id="bf080-192">Create Primary Keys</span></span>](../tables/create-primary-keys.md)|
|<span data-ttu-id="bf080-193">说明如何删除主键。</span><span class="sxs-lookup"><span data-stu-id="bf080-193">Describes how to delete a primary key.</span></span>|[<span data-ttu-id="bf080-194">删除主键</span><span class="sxs-lookup"><span data-stu-id="bf080-194">Delete Primary Keys</span></span>](../tables/delete-primary-keys.md)|
|<span data-ttu-id="bf080-195">说明如何修改主键。</span><span class="sxs-lookup"><span data-stu-id="bf080-195">Describes how to modify a primary key.</span></span>|[<span data-ttu-id="bf080-196">修改主键</span><span class="sxs-lookup"><span data-stu-id="bf080-196">Modify Primary Keys</span></span>](../tables/modify-primary-keys.md)|
|<span data-ttu-id="bf080-197">说明如何创建外键关系</span><span class="sxs-lookup"><span data-stu-id="bf080-197">Describes how to create foreign key relationships</span></span>|[<span data-ttu-id="bf080-198">创建外键关系</span><span class="sxs-lookup"><span data-stu-id="bf080-198">Create Foreign Key Relationships</span></span>](../tables/create-foreign-key-relationships.md)|
|<span data-ttu-id="bf080-199">说明如何修改外键关系。</span><span class="sxs-lookup"><span data-stu-id="bf080-199">Describes how to modify foreign key relationships.</span></span>|[<span data-ttu-id="bf080-200">修改外键关系</span><span class="sxs-lookup"><span data-stu-id="bf080-200">Modify Foreign Key Relationships</span></span>](../tables/modify-foreign-key-relationships.md)|
|<span data-ttu-id="bf080-201">说明如何删除外键关系。</span><span class="sxs-lookup"><span data-stu-id="bf080-201">Describes how to delete foreign key relationships.</span></span>|[<span data-ttu-id="bf080-202">删除外键关系</span><span class="sxs-lookup"><span data-stu-id="bf080-202">Delete Foreign Key Relationships</span></span>](../tables/delete-foreign-key-relationships.md)|
|<span data-ttu-id="bf080-203">说明如何查看外键属性。</span><span class="sxs-lookup"><span data-stu-id="bf080-203">Describes how to view foreign key properties.</span></span>|[<span data-ttu-id="bf080-204">查看外键属性</span><span class="sxs-lookup"><span data-stu-id="bf080-204">View Foreign Key Properties</span></span>](../tables/view-foreign-key-properties.md)|
|<span data-ttu-id="bf080-205">说明如何禁止将外键约束用于复制。</span><span class="sxs-lookup"><span data-stu-id="bf080-205">Describes how to disable foreign key constraints for replication.</span></span>|[<span data-ttu-id="bf080-206">对复制禁用外键约束</span><span class="sxs-lookup"><span data-stu-id="bf080-206">Disable Foreign Key Constraints for Replication</span></span>](../tables/disable-foreign-key-constraints-for-replication.md)|
|<span data-ttu-id="bf080-207">说明如何在 INSERT 或 UPDATE 语句执行过程中禁用外键约束。</span><span class="sxs-lookup"><span data-stu-id="bf080-207">Describes how to disable foreign key constraints during an INSERT or UPDATE statement.</span></span>|[<span data-ttu-id="bf080-208">使用 INSERT 和 UPDATE 语句禁用外键约束</span><span class="sxs-lookup"><span data-stu-id="bf080-208">Disable Foreign Key Constraints with INSERT and UPDATE Statements</span></span>](../tables/disable-foreign-key-constraints-with-insert-and-update-statements.md)|


