---
title: 统计信息 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: performance
ms.topic: conceptual
helpviewer_keywords:
- statistical information [SQL Server], query optimization
- query performance [SQL Server], statistics
- query optimization statistics [SQL Server]
- statistical information [SQL Server], database options
- query optimization statistics [SQL Server], about query optimization statistics
- statistical information [SQL Server], guidelines
- statistical information [SQL Server]
- using statistics [SQL Server]
- statistical information [SQL Server], indexes
- index statistics [SQL Server]
- query optimizer [SQL Server], statistics
- statistics [SQL Server]
ms.assetid: b86a88ba-4f7c-4e19-9fbd-2f8bcd3be14a
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: 0f0950e48245bed53581d2f91b120ab9555aa562
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87590110"
---
# <a name="statistics"></a><span data-ttu-id="c486b-102">统计信息</span><span class="sxs-lookup"><span data-stu-id="c486b-102">Statistics</span></span>
  <span data-ttu-id="c486b-103">查询优化器使用统计信息来创建可提高查询性能的查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-103">The query optimizer uses statistics to create query plans that improve query performance.</span></span> <span data-ttu-id="c486b-104">对于大多数查询，查询优化器已为高质量查询计划生成必要的统计信息；但在少数一些情况下，您需要创建附加的统计信息或修改查询设计以得到最佳结果。</span><span class="sxs-lookup"><span data-stu-id="c486b-104">For most queries, the query optimizer already generates the necessary statistics for a high quality query plan; in a few cases, you need to create additional statistics or modify the query design for best results.</span></span> <span data-ttu-id="c486b-105">本主题讨论用于高效使用查询优化统计信息的统计信息概念并提供指南。</span><span class="sxs-lookup"><span data-stu-id="c486b-105">This topic discusses statistics concepts and provides guidelines for using query optimization statistics effectively.</span></span>  
  
##  <a name="components-and-concepts"></a><a name="DefinitionQOStatistics"></a> <span data-ttu-id="c486b-106">组件和概念</span><span class="sxs-lookup"><span data-stu-id="c486b-106">Components and Concepts</span></span>  
 <span data-ttu-id="c486b-107">统计信息</span><span class="sxs-lookup"><span data-stu-id="c486b-107">Statistics</span></span>  
 <span data-ttu-id="c486b-108">查询优化的统计信息是一些对象，这些对象包含与值在表或索引视图的一列或多列中的分布有关的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-108">Statistics for query optimization are objects that contain statistical information about the distribution of values in one or more columns of a table or indexed view.</span></span> <span data-ttu-id="c486b-109">查询优化器使用这些统计信息来估计查询结果中的*基数*或行数。</span><span class="sxs-lookup"><span data-stu-id="c486b-109">The query optimizer uses these statistics to estimate the *cardinality*, or number of rows, in the query result.</span></span> <span data-ttu-id="c486b-110">通过这些*基数估计*，查询优化器可以创建高质量的查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-110">These *cardinality estimates* enable the query optimizer to create a high-quality query plan.</span></span> <span data-ttu-id="c486b-111">例如，查询优化器可以使用基数估计选择索引查找运算符而不是耗费更多资源的索引扫描运算符，从而提高查询性能。</span><span class="sxs-lookup"><span data-stu-id="c486b-111">For example, the query optimizer could use cardinality estimates to choose the index seek operator instead of the more resource-intensive index scan operator, and in doing so improve query performance.</span></span>  
  
 <span data-ttu-id="c486b-112">每个统计信息对象都在包含一个或多个表列的列表上创建，并且包括显示值在第一列中的分布的直方图。</span><span class="sxs-lookup"><span data-stu-id="c486b-112">Each statistics object is created on a list of one or more table columns and includes a histogram displaying the distribution of values in the first column.</span></span> <span data-ttu-id="c486b-113">在多列上的统计信息对象也存储与各列中的值的相关性有关的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-113">Statistics objects on multiple columns also store statistical information about the correlation of values among the columns.</span></span> <span data-ttu-id="c486b-114">这些相关性统计信息（或 *密度*）根据列值的不同行的数目派生。</span><span class="sxs-lookup"><span data-stu-id="c486b-114">These correlation statistics, or *densities*, are derived from the number of distinct rows of column values.</span></span> <span data-ttu-id="c486b-115">有关统计信息对象的详细信息，请参阅 [DBCC SHOW_STATISTICS (Transact-SQL)](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="c486b-115">For more information about statistics objects, see [DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql).</span></span>  
  
 <span data-ttu-id="c486b-116">筛选的统计信息</span><span class="sxs-lookup"><span data-stu-id="c486b-116">Filtered Statistics</span></span>  
 <span data-ttu-id="c486b-117">筛选统计信息可以提高以下从定义完善的数据子集选择数据的查询的查询性能。</span><span class="sxs-lookup"><span data-stu-id="c486b-117">Filtered statistics can improve query performance for queries that select from well-defined subsets of data.</span></span> <span data-ttu-id="c486b-118">筛选统计信息使用筛选器谓词来选择统计信息中包括的数据子集。</span><span class="sxs-lookup"><span data-stu-id="c486b-118">Filtered statistics use a filter predicate to select the subset of data that is included in the statistics.</span></span> <span data-ttu-id="c486b-119">与全表统计信息相比，设计完美的筛选统计信息可以改进查询执行计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-119">Well-designed filtered statistics can improve the query execution plan compared with full-table statistics.</span></span> <span data-ttu-id="c486b-120">有关筛选器谓词的详细信息，请参阅 [CREATE STATISTICS (Transact-SQL)](/sql/t-sql/statements/create-statistics-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="c486b-120">For more information about the filter predicate, see [CREATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-statistics-transact-sql).</span></span> <span data-ttu-id="c486b-121">有关何时创建筛选的统计信息的详细信息，请参阅本主题中的 [何时创建统计信息](#UpdateStatistics) 部分。</span><span class="sxs-lookup"><span data-stu-id="c486b-121">For more information about when to create filtered statistics, see the [When to Create Statistics](#UpdateStatistics) section in this topic.</span></span> <span data-ttu-id="c486b-122">有关案例研究，请参阅 SQLCAT 网站上的博客文章 [Using Filtered Statistics with Partitioned Tables](https://go.microsoft.com/fwlink/?LinkId=178505)（将筛选的统计信息用于分区表）。</span><span class="sxs-lookup"><span data-stu-id="c486b-122">For a case study, see the blog entry, [Using Filtered Statistics with Partitioned Tables](https://go.microsoft.com/fwlink/?LinkId=178505), on the SQLCAT Web site.</span></span>  
  
 <span data-ttu-id="c486b-123">统计信息选项</span><span class="sxs-lookup"><span data-stu-id="c486b-123">Statistics Options</span></span>  
 <span data-ttu-id="c486b-124">可以设置三个选项来影响何时以及如何创建和更新统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-124">There are three options that you can set that affect when and how statistics are created and updated.</span></span> <span data-ttu-id="c486b-125">这些选项仅在数据库级别设置。</span><span class="sxs-lookup"><span data-stu-id="c486b-125">These options are set at the database level only.</span></span>  
  
 <span data-ttu-id="c486b-126">AUTO_CREATE_STATISTICS 选项</span><span class="sxs-lookup"><span data-stu-id="c486b-126">AUTO_CREATE_STATISTICS Option</span></span>  
 <span data-ttu-id="c486b-127">在自动创建统计信息选项 AUTO_CREATE_STATISTICS 为 ON 时，查询优化器将根据需要在查询谓词中的单独列上创建统计信息，以便改进查询计划的基数估计。</span><span class="sxs-lookup"><span data-stu-id="c486b-127">When the automatic create statistics option, AUTO_CREATE_STATISTICS, is on, the query optimizer creates statistics on individual columns in the query predicate, as necessary, to improve cardinality estimates for the query plan.</span></span> <span data-ttu-id="c486b-128">这些单列统计信息在现有统计信息对象中尚未具有直方图的列上创建。</span><span class="sxs-lookup"><span data-stu-id="c486b-128">These single-column statistics are created on columns that do not already have a histogram in an existing statistics object.</span></span> <span data-ttu-id="c486b-129">AUTO_CREATE_STATISTICS 选项不确定是否为索引创建了统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-129">The AUTO_CREATE_STATISTICS option does not determine whether statistics get created for indexes.</span></span> <span data-ttu-id="c486b-130">此选项也不生成筛选统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-130">This option also does not generate filtered statistics.</span></span> <span data-ttu-id="c486b-131">它严格应用于全表的单列统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-131">It applies strictly to single-column statistics for the full table.</span></span>  
  
 <span data-ttu-id="c486b-132">查询优化器通过使用 AUTO_CREATE_STATISTICS 选项创建统计信息时，统计信息名称以 `_WA`开头。</span><span class="sxs-lookup"><span data-stu-id="c486b-132">When the query optimizer creates statistics as a result of using the AUTO_CREATE_STATISTICS option, the statistics name starts with `_WA`.</span></span> <span data-ttu-id="c486b-133">可以使用下面的查询来确定查询优化器是否为查询谓词列创建了统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-133">You can use the following query to determine if the query optimizer has created statistics for a query predicate column.</span></span>  
  
```  
SELECT OBJECT_NAME(s.object_id) AS object_name,  
    COL_NAME(sc.object_id, sc.column_id) AS column_name,  
    s.name AS statistics_name  
FROM sys.stats AS s JOIN sys.stats_columns AS sc  
    ON s.stats_id = sc.stats_id AND s.object_id = sc.object_id  
WHERE s.name like '_WA%'  
ORDER BY s.name;  
```  
  
 <span data-ttu-id="c486b-134">AUTO_UPDATE_STATISTICS 选项</span><span class="sxs-lookup"><span data-stu-id="c486b-134">AUTO_UPDATE_STATISTICS Option</span></span>  
 <span data-ttu-id="c486b-135">在自动更新统计信息选项 AUTO_UPDATE_STATISTICS 为 ON 时，查询优化器将确定统计信息何时可能过期，然后在查询使用这些统计信息时更新它们。</span><span class="sxs-lookup"><span data-stu-id="c486b-135">When the automatic update statistics option, AUTO_UPDATE_STATISTICS, is on, the query optimizer determines when statistics might be out-of-date and then updates them when they are used by a query.</span></span> <span data-ttu-id="c486b-136">统计信息将在插入、更新、删除或合并操作更改表或索引视图中的数据分布后过期。</span><span class="sxs-lookup"><span data-stu-id="c486b-136">Statistics become out-of-date after insert, update, delete, or merge operations change the data distribution in the table or indexed view.</span></span> <span data-ttu-id="c486b-137">查询优化器通过计算自最后统计信息更新后数据修改的次数并且将这一修改次数与某一阈值进行比较，确定统计信息何时可能过期。</span><span class="sxs-lookup"><span data-stu-id="c486b-137">The query optimizer determines when statistics might be out-of-date by counting the number of data modifications since the last statistics update and comparing the number of modifications to a threshold.</span></span> <span data-ttu-id="c486b-138">该阈值基于表中或索引视图中的行数。</span><span class="sxs-lookup"><span data-stu-id="c486b-138">The threshold is based on the number of rows in the table or indexed view.</span></span>  
  
 <span data-ttu-id="c486b-139">查询优化器在编译查询和执行缓存查询计划前，检查是否存在过期的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-139">The query optimizer checks for out-of-date statistics before compiling a query and before executing a cached query plan.</span></span> <span data-ttu-id="c486b-140">在编译某一查询前，查询优化器使用查询谓词中的列、表和索引视图确定哪些统计信息可能过期。</span><span class="sxs-lookup"><span data-stu-id="c486b-140">Before compiling a query, the query optimizer uses the columns, tables, and indexed views in the query predicate to determine which statistics might be out-of-date.</span></span> <span data-ttu-id="c486b-141">在执行缓存查询计划前， [!INCLUDE[ssDE](../../../includes/ssde-md.md)] 确认该查询计划引用最新的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-141">Before executing a cached query plan, the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] verifies that the query plan references up-to-date statistics.</span></span>  
  
 <span data-ttu-id="c486b-142">AUTO_UPDATE_STATISTICS 选项适用于为索引创建的统计信息对象、查询谓词中的单列以及使用 [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) 语句创建的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-142">The AUTO_UPDATE_STATISTICS option applies to statistics objects created for indexes, single-columns in query predicates, and statistics created with the [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) statement.</span></span> <span data-ttu-id="c486b-143">此选项也适用于筛选的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-143">This option also applies to filtered statistics.</span></span>  
  
 <span data-ttu-id="c486b-144">AUTO_UPDATE_STATISTICS_ASYNC</span><span class="sxs-lookup"><span data-stu-id="c486b-144">AUTO_UPDATE_STATISTICS_ASYNC</span></span>  
 <span data-ttu-id="c486b-145">异步统计信息更新选项 AUTO_UPDATE_STATISTICS_ASYNC 将确定查询优化器是使用同步统计信息更新还是异步统计信息更新。</span><span class="sxs-lookup"><span data-stu-id="c486b-145">The asynchronous statistics update option, AUTO_UPDATE_STATISTICS_ASYNC, determines whether the query optimizer uses synchronous or asynchronous statistics updates.</span></span> <span data-ttu-id="c486b-146">默认情况下，异步统计信息更新选项被关闭，并且查询优化器以同步方式更新统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-146">By default, the asynchronous statistics update option is off, and the query optimizer updates statistics synchronously.</span></span> <span data-ttu-id="c486b-147">AUTO_UPDATE_STATISTICS_ASYNC 选项适用于为索引创建的统计信息对象、查询谓词中的单列以及使用 [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) 语句创建的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-147">The AUTO_UPDATE_STATISTICS_ASYNC option applies to statistics objects created for indexes, single columns in query predicates, and statistics created with the [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) statement.</span></span>  
  
 <span data-ttu-id="c486b-148">统计信息更新可以是同步（默认设置）或异步的。</span><span class="sxs-lookup"><span data-stu-id="c486b-148">Statistics updates can be either synchronous (the default) or asynchronous.</span></span> <span data-ttu-id="c486b-149">对于同步统计信息更新，查询将始终用最新的统计信息编译和执行；在统计信息过期时，查询优化器将在编译和执行查询前等待更新的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-149">With synchronous statistics updates, queries always compile and execute with up-to-date statistics; When statistics are out-of-date, the query optimizer waits for updated statistics before compiling and executing the query.</span></span> <span data-ttu-id="c486b-150">对于异步统计信息更新，查询将用现有的统计信息编译，即使现有统计信息已过期。如果在查询编译时统计信息过期，查询优化器可以选择非最优查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-150">With asynchronous statistics updates, queries compile with existing statistics even if the existing statistics are out-of-date; The query optimizer could choose a suboptimal query plan if statistics are out-of-date when the query compiles.</span></span> <span data-ttu-id="c486b-151">在异步更新完成后编译的查询将从使用更新的统计信息中受益。</span><span class="sxs-lookup"><span data-stu-id="c486b-151">Queries that compile after the asynchronous updates have completed will benefit from using the updated statistics.</span></span>  
  
 <span data-ttu-id="c486b-152">执行更改数据分布的操作（例如截断表或对很大百分比的行执行大容量更新）时，考虑使用同步统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-152">Consider using synchronous statistics when you perform operations that change the distribution of data, such as truncating a table or performing a bulk update of a large percentage of the rows.</span></span> <span data-ttu-id="c486b-153">如果您在完成该操作后未更新统计信息，则使用同步统计信息将确保对更改的数据执行查询前统计信息是最新的。</span><span class="sxs-lookup"><span data-stu-id="c486b-153">If you do not update the statistics after completing the operation, using synchronous statistics will ensure statistics are up-to-date before executing queries on the changed data.</span></span>  
  
 <span data-ttu-id="c486b-154">在以下情况下，考虑使用异步统计信息来实现可预测性更高的查询响应时间：</span><span class="sxs-lookup"><span data-stu-id="c486b-154">Consider using asynchronous statistics to achieve more predictable query response times for the following scenarios:</span></span>  
  
-   <span data-ttu-id="c486b-155">您的应用程序频繁执行相同的查询、类似的查询或类似的缓存查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-155">Your application frequently executes the same query, similar queries, or similar cached query plans.</span></span> <span data-ttu-id="c486b-156">与同步统计信息更新相比，使用异步统计信息更新时您的查询响应时间可能具有更高的可预测性，因为查询优化器可以执行传入的查询而不必等待最新的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-156">Your query response times might be more predictable with asynchronous statistics updates than with synchronous statistics updates because the query optimizer can execute incoming queries without waiting for up-to-date statistics.</span></span> <span data-ttu-id="c486b-157">这避免延迟某些查询，而不延迟其他查询。</span><span class="sxs-lookup"><span data-stu-id="c486b-157">This avoids delaying some queries and not others.</span></span>  
  
-   <span data-ttu-id="c486b-158">您的应用程序遇到了客户端请求超时，这些超时是由于一个或多个查询正在等待更新后的统计信息所导致的。</span><span class="sxs-lookup"><span data-stu-id="c486b-158">Your application has experienced client request time outs caused by one or more queries waiting for updated statistics.</span></span> <span data-ttu-id="c486b-159">在某些情况下，等待同步统计信息可能会导致应用程序因过长超时而失败。</span><span class="sxs-lookup"><span data-stu-id="c486b-159">In some cases, waiting for synchronous statistics could cause applications with aggressive time outs to fail.</span></span>  
  
 <span data-ttu-id="c486b-160">INCREMENTAL STATS</span><span class="sxs-lookup"><span data-stu-id="c486b-160">INCREMENTAL STATS</span></span>  
 <span data-ttu-id="c486b-161">为 ON 时，根据分区统计信息创建统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-161">When ON, the statistics created are per partition statistics.</span></span> <span data-ttu-id="c486b-162">为 OFF 时，删除统计信息树并且 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 重新计算统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-162">When OFF, the statistics tree is dropped and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] re-computes the statistics.</span></span> <span data-ttu-id="c486b-163">默认为 OFF。</span><span class="sxs-lookup"><span data-stu-id="c486b-163">The default is OFF.</span></span> <span data-ttu-id="c486b-164">此设置覆盖数据库级别 INCREMENTAL 属性。</span><span class="sxs-lookup"><span data-stu-id="c486b-164">This setting overrides the database level INCREMENTAL property.</span></span>  
  
 <span data-ttu-id="c486b-165">在将新分区添加到某个大型表时，应更新统计信息以便包括这些新分区。</span><span class="sxs-lookup"><span data-stu-id="c486b-165">When new partitions are added to a large table, statistics should be updated to include the new partitions.</span></span> <span data-ttu-id="c486b-166">但是，浏览整个表（FULLSCAN 或 SAMPLE 选项）所需的时间可能会相当长。</span><span class="sxs-lookup"><span data-stu-id="c486b-166">However the time required to scan the entire table (FULLSCAN or SAMPLE option) might be quite long.</span></span> <span data-ttu-id="c486b-167">此外，因为可能只需针对新分区的统计信息，所以，扫描整个表不是必需的。</span><span class="sxs-lookup"><span data-stu-id="c486b-167">Also, scanning the entire table isn't necessary because only the statistics on the new partitions might be needed.</span></span> <span data-ttu-id="c486b-168">该增量选项将在每个分区的基础上创建和存储统计信息，并且在更新时，只刷新需要新统计信息的那些分区上的统计信息</span><span class="sxs-lookup"><span data-stu-id="c486b-168">The incremental option creates and stores statistics on a per partition basis, and when updated, only refreshes statistics on those partitions that need new statistics</span></span>  
  
 <span data-ttu-id="c486b-169">如果不支持每个分区统计信息，将忽略该选项并生成警告。</span><span class="sxs-lookup"><span data-stu-id="c486b-169">If per partition statistics are not supported the option is ignored and a warning is generated.</span></span> <span data-ttu-id="c486b-170">对于以下统计信息类型，不支持增量统计信息：</span><span class="sxs-lookup"><span data-stu-id="c486b-170">Incremental stats are not supported for following statistics types:</span></span>  
  
-   <span data-ttu-id="c486b-171">使用未与基表的分区对齐的索引创建的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-171">Statistics created with indexes that are not partition-aligned with the base table.</span></span>  
  
-   <span data-ttu-id="c486b-172">对 AlwaysOn 可读辅助数据库创建的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-172">Statistics created on AlwaysOn readable secondary databases.</span></span>  
  
-   <span data-ttu-id="c486b-173">对只读数据库创建的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-173">Statistics created on read-only databases.</span></span>  
  
-   <span data-ttu-id="c486b-174">对筛选的索引创建的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-174">Statistics created on filtered indexes.</span></span>  
  
-   <span data-ttu-id="c486b-175">对视图创建的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-175">Statistics created on views.</span></span>  
  
-   <span data-ttu-id="c486b-176">对内部表创建的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-176">Statistics created on internal tables.</span></span>  
  
-   <span data-ttu-id="c486b-177">使用空间索引或 XML 索引创建的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-177">Statistics created with spatial indexes or XML indexes.</span></span>  
  
||  
|-|  
|<span data-ttu-id="c486b-178">**适用范围**： [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] 到 [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="c486b-178">**Applies to**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] through [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)].</span></span>|  
  
##  <a name="when-to-create-statistics"></a><a name="CreateStatistics"></a><span data-ttu-id="c486b-179">何时创建统计信息</span><span class="sxs-lookup"><span data-stu-id="c486b-179">When to Create Statistics</span></span>  
 <span data-ttu-id="c486b-180">查询优化器已通过以下方式创建统计信息：</span><span class="sxs-lookup"><span data-stu-id="c486b-180">The query optimizer already creates statistics in the following ways:</span></span>  
  
1.  <span data-ttu-id="c486b-181">在创建索引时，查询优化器为表或视图上的索引创建统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-181">The query optimizer creates statistics for indexes on tables or views when the index is created.</span></span> <span data-ttu-id="c486b-182">这些统计信息将创建在索引的键列上。</span><span class="sxs-lookup"><span data-stu-id="c486b-182">These statistics are created on the key columns of the index.</span></span> <span data-ttu-id="c486b-183">如果索引是一个筛选索引，则查询优化器将在为该筛选索引指定的行的同一子集上创建筛选统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-183">If the index is a filtered index, the query optimizer creates filtered statistics on the same subset of rows specified for the filtered index.</span></span> <span data-ttu-id="c486b-184">有关筛选索引的详细信息，请参阅[创建筛选索引](../indexes/create-filtered-indexes.md)和 [CREATE INDEX (Transact-SQL)](/sql/t-sql/statements/create-index-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="c486b-184">For more information about filtered indexes, see [Create Filtered Indexes](../indexes/create-filtered-indexes.md) and [CREATE INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-index-transact-sql).</span></span>  
  
2.  <span data-ttu-id="c486b-185">在 AUTO_CREATE_STATISTICS 为 ON 时，查询优化器为查询谓词中的单列创建统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-185">The query optimizer creates statistics for single columns in query predicates when AUTO_CREATE_STATISTICS is on.</span></span>  
  
 <span data-ttu-id="c486b-186">对于大多数查询，用于创建统计信息的这两个方法就可以确保高质量的查询计划；但在很少的情况下，可以通过使用 [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) 语句创建附加的统计信息来改进查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-186">For most queries, these two methods for creating statistics ensure a high-quality query plan; in a few cases, you can improve query plans by creating additional statistics with the [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) statement.</span></span> <span data-ttu-id="c486b-187">这些附加的统计信息可以捕获查询优化器在为索引或单列创建统计信息时并未考虑的统计关联。</span><span class="sxs-lookup"><span data-stu-id="c486b-187">These additional statistics can capture statistical correlations that the query optimizer does not account for when it creates statistics for indexes or single columns.</span></span> <span data-ttu-id="c486b-188">您的应用程序可能在表数据中具有附加的统计关联，如果在统计信息对象中计入这些关联，可能会令查询优化器改进查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-188">Your application might have additional statistical correlations in the table data that, if calculated into a statistics object, could enable the query optimizer to improve query plans.</span></span> <span data-ttu-id="c486b-189">例如，针对数据行子集的筛选统计信息或针对查询谓词列的多列统计信息可改进查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-189">For example, filtered statistics on a subset of data rows or multicolumn statistics on query predicate columns might improve the query plan.</span></span>  
  
 <span data-ttu-id="c486b-190">在使用 CREATE STATISTICS 语句创建统计信息时，我们建议保持 AUTO_CREATE_STATISTICS 选项为 ON，以便查询优化器继续为查询谓词列定期创建单列统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-190">When creating statistics with the CREATE STATISTICS statement, we recommend keeping the AUTO_CREATE_STATISTICS option on so that the query optimizer continues to routinely create single-column statistics for query predicate columns.</span></span> <span data-ttu-id="c486b-191">有关查询谓词的详细信息，请参阅[搜索条件 (Transact-SQL)](/sql/t-sql/queries/search-condition-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="c486b-191">For more information about query predicates, see [Search Condition &#40;Transact-SQL&#41;](/sql/t-sql/queries/search-condition-transact-sql).</span></span>  
  
 <span data-ttu-id="c486b-192">在以下任何情况适用时，考虑使用 CREATE STATISTICS 语句创建统计信息：</span><span class="sxs-lookup"><span data-stu-id="c486b-192">Consider creating statistics with the CREATE STATISTICS statement when any of the following applies:</span></span>  
  
-   <span data-ttu-id="c486b-193">[!INCLUDE[ssDE](../../../includes/ssde-md.md)] 优化顾问建议创建统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-193">The [!INCLUDE[ssDE](../../../includes/ssde-md.md)] Tuning Advisor suggests creating statistics.</span></span>  
  
-   <span data-ttu-id="c486b-194">查询谓词包含尚不位于相同索引中的多个相关列。</span><span class="sxs-lookup"><span data-stu-id="c486b-194">The query predicate contains multiple correlated columns that are not already in the same index.</span></span>  
  
-   <span data-ttu-id="c486b-195">查询从数据的子集中选择数据。</span><span class="sxs-lookup"><span data-stu-id="c486b-195">The query selects from a subset of data.</span></span>  
  
-   <span data-ttu-id="c486b-196">查询缺少统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-196">The query has missing statistics.</span></span>  
  
### <a name="query-predicate-contains-multiple-correlated-columns"></a><span data-ttu-id="c486b-197">查询谓词包含多个相关列</span><span class="sxs-lookup"><span data-stu-id="c486b-197">Query Predicate Contains Multiple Correlated Columns</span></span>  
 <span data-ttu-id="c486b-198">在某一查询谓词包含具有跨列关系和相关性的多列时，针对多列的统计信息可能会改进查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-198">When a query predicate contains multiple columns that have cross-column relationships and dependencies, statistics on the multiple columns might improve the query plan.</span></span> <span data-ttu-id="c486b-199">针对多列的统计信息包含称作密度的跨列相关统计信息，这些统计信息不可用于单列统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-199">Statistics on multiple columns contain cross-column correlation statistics, called *densities*, that are not available in single-column statistics.</span></span> <span data-ttu-id="c486b-200">在查询结果依赖于多列之间的数据关系时，密度可以改进基数估计。</span><span class="sxs-lookup"><span data-stu-id="c486b-200">Densities can improve cardinality estimates when query results depend on data relationships among multiple columns.</span></span>  
  
 <span data-ttu-id="c486b-201">如果多个列已处于同一索引中，则多列统计信息对象已存在并且不必手动创建它。</span><span class="sxs-lookup"><span data-stu-id="c486b-201">If the columns are already in the same index, the multicolumn statistics object already exists and it is not necessary to create it manually.</span></span> <span data-ttu-id="c486b-202">如果这些列尚未处于同一索引中，则可以通过对多个列创建索引或通过使用 CREATE STATISTICS 语句，创建多列统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-202">If the columns are not already in the same index, you can create multicolumn statistics by creating an index on the columns or by using the CREATE STATISTICS statement.</span></span> <span data-ttu-id="c486b-203">与统计信息对象相比，它要求更多的系统资源来维护索引。</span><span class="sxs-lookup"><span data-stu-id="c486b-203">It requires more system resources to maintain an index than a statistics object.</span></span> <span data-ttu-id="c486b-204">如果应用程序不要求多列索引，您可以通过创建统计信息对象但不创建索引，有效地利用系统资源。</span><span class="sxs-lookup"><span data-stu-id="c486b-204">If the application does not require the multicolumn index, you can economize on system resources by creating the statistics object without creating the index.</span></span>  
  
 <span data-ttu-id="c486b-205">在创建多列统计信息时，统计信息对象定义中列的顺序将影响生成基数估计的密度的效率。</span><span class="sxs-lookup"><span data-stu-id="c486b-205">When creating multicolumn statistics, the order of the columns in the statistics object definition affects the effectiveness of densities for making cardinality estimates.</span></span> <span data-ttu-id="c486b-206">统计信息对象在统计信息对象定义中存储键列的每个前缀的密度。</span><span class="sxs-lookup"><span data-stu-id="c486b-206">The statistics object stores densities for each prefix of key columns in the statistics object definition.</span></span> <span data-ttu-id="c486b-207">有关密度的详细信息，请参阅 [DBCC SHOW_STATISTICS (Transact-SQL)](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="c486b-207">For more information about densities, see [DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql).</span></span>  
  
 <span data-ttu-id="c486b-208">为了创建用于基数估计的密度，查询谓词中的列必须匹配统计信息对象定义中列的前缀之一。</span><span class="sxs-lookup"><span data-stu-id="c486b-208">To create densities that are useful for cardinality estimates, the columns in the query predicate must match one of the prefixes of columns in the statistics object definition.</span></span> <span data-ttu-id="c486b-209">例如，以下内容在列 `LastName`、 `MiddleName`和 `FirstName`上创建多列统计信息对象。</span><span class="sxs-lookup"><span data-stu-id="c486b-209">For example, the following creates a multicolumn statistics object on the columns `LastName`, `MiddleName`, and `FirstName`.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
IF EXISTS (SELECT name FROM sys.stats  
    WHERE name = 'LastFirst'  
    AND object_ID = OBJECT_ID ('Person.Person'))  
DROP STATISTICS Person.Person.LastFirst;  
GO  
CREATE STATISTICS LastFirst ON Person.Person (LastName, MiddleName, FirstName);  
GO  
```  
  
 <span data-ttu-id="c486b-210">在此示例中，统计信息对象 `LastFirst` 具有以下列前缀的密度：(`LastName`)、(`LastName, MiddleName`) 和 (`LastName, MiddleName, FirstName`)。</span><span class="sxs-lookup"><span data-stu-id="c486b-210">In this example, the statistics object `LastFirst` has densities for the following column prefixes: (`LastName`), (`LastName, MiddleName`), and (`LastName, MiddleName, FirstName`).</span></span> <span data-ttu-id="c486b-211">密度不可用于 (`LastName, FirstName`)。</span><span class="sxs-lookup"><span data-stu-id="c486b-211">The density is not available for (`LastName, FirstName`).</span></span> <span data-ttu-id="c486b-212">如果查询使用 `LastName` 和 `FirstName` ，并且没有使用 `MiddleName`，则密度不可用于基数估计。</span><span class="sxs-lookup"><span data-stu-id="c486b-212">If the query uses `LastName` and `FirstName` without using `MiddleName`, the density is not available for cardinality estimates.</span></span>  
  
### <a name="query-selects-from-a-subset-of-data"></a><span data-ttu-id="c486b-213">查询从数据的子集中选择数据</span><span class="sxs-lookup"><span data-stu-id="c486b-213">Query Selects from a Subset of Data</span></span>  
 <span data-ttu-id="c486b-214">在查询优化器为单个列和索引创建统计信息时，它为所有行中的值创建统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-214">When the query optimizer creates statistics for single columns and indexes, it creates the statistics for the values in all rows.</span></span> <span data-ttu-id="c486b-215">在查询从行的某一子集中选择数据时，这一行子集具有唯一的数据分布，筛选统计信息可以改进查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-215">When queries select from a subset of rows, and that subset of rows has a unique data distribution, filtered statistics can improve query plans.</span></span> <span data-ttu-id="c486b-216">可以通过使用 CREATE STATISTICS 语句并在此语句中用 WHERE 子句定义筛选器谓词表达式来创建筛选统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-216">You can create filtered statistics by using the CREATE STATISTICS statement with the WHERE clause to define the filter predicate expression.</span></span>  
  
 <span data-ttu-id="c486b-217">例如，使用 [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)]时，Production.Product 表中的每种产品属于 Production.ProductCategory 表中的以下四种类别之一：Bikes、Components、Clothing 和 Accessories。</span><span class="sxs-lookup"><span data-stu-id="c486b-217">For example, using [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)], each product in the Production.Product table belongs to one of four categories in the Production.ProductCategory table: Bikes, Components, Clothing, and Accessories.</span></span> <span data-ttu-id="c486b-218">上述每个类别在重量方面的数据分布均不同：自行车的重量范围为 13.77 到 30.0，部件的重量范围为 2.12 到 1050.00 且有些部件的重量为 NULL 值，服装的重量全部为 NULL，附件的重量也为 NULL。</span><span class="sxs-lookup"><span data-stu-id="c486b-218">Each of the categories has a different data distribution for weight: bike weights range from 13.77 to 30.0, component weights range from 2.12 to 1050.00 with some NULL values, clothing weights are all NULL, and accessory weights are also NULL.</span></span>  
  
 <span data-ttu-id="c486b-219">使用自行车为例，针对所有自行车重量的筛选统计信息将向查询优化器提供更精确的统计信息，并且与全表统计信息或者针对 Weight 列的不存在的统计信息相比，可以改进查询计划质量。</span><span class="sxs-lookup"><span data-stu-id="c486b-219">Using Bikes as an example, filtered statistics on all bike weights will provide more accurate statistics to the query optimizer and can improve the query plan quality compared with full-table statistics or nonexistent statistics on the Weight column.</span></span> <span data-ttu-id="c486b-220">该自行车重量列很适合于筛选统计信息，但如果重量查找的数目相对较少，则不见得适合于筛选索引。</span><span class="sxs-lookup"><span data-stu-id="c486b-220">The bike weight column is a good candidate for filtered statistics but not necessarily a good candidate for a filtered index if the number of weight lookups is relatively small.</span></span> <span data-ttu-id="c486b-221">筛选索引所提供的在查找方面的性能提升可能抵不上将筛选索引添加到数据库所导致的额外维护和存储成本。</span><span class="sxs-lookup"><span data-stu-id="c486b-221">The performance gain for lookups that a filtered index provides might not outweigh the additional maintenance and storage cost for adding a filtered index to the database.</span></span>  
  
 <span data-ttu-id="c486b-222">以下语句对自行车的所有子类别创建 `BikeWeights` 筛选统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-222">The following statement creates the `BikeWeights` filtered statistics on all of the subcategories for Bikes.</span></span> <span data-ttu-id="c486b-223">筛选的谓词表达式通过使用比较 `Production.ProductSubcategoryID IN (1,2,3)`枚举所有自行车子类别，对自行车进行定义。</span><span class="sxs-lookup"><span data-stu-id="c486b-223">The filtered predicate expression defines bikes by enumerating all of the bike subcategories with the comparison `Production.ProductSubcategoryID IN (1,2,3)`.</span></span> <span data-ttu-id="c486b-224">该谓词无法使用“自行车”类别名称，因为它存储于 Production.ProductCategory 表中，并且筛选表达式中的所有列都必须位于相同的表中。</span><span class="sxs-lookup"><span data-stu-id="c486b-224">The predicate cannot use the Bikes category name because it is stored in the Production.ProductCategory table, and all columns in the filter expression must be in the same table.</span></span>  
  
 [!code-sql[StatisticsDDL#FilteredStats2](../../snippets/tsql/SQL14/tsql/statisticsddl/transact-sql/filteredstats.sql#filteredstats2)]  
  
 <span data-ttu-id="c486b-225">查询优化器可使用 `BikeWeights` 筛选的统计信息来改进下面这个查询的查询计划，此查询选择重量超过 `25`的所有自行车。</span><span class="sxs-lookup"><span data-stu-id="c486b-225">The query optimizer can use the `BikeWeights` filtered statistics to improve the query plan for the following query that selects all of the bikes that weigh more than `25`.</span></span>  
  
```  
SELECT P.Weight AS Weight, S.Name AS BikeName  
FROM Production.Product AS P  
    JOIN Production.ProductSubcategory AS S   
    ON P.ProductSubcategoryID = S.ProductSubcategoryID  
WHERE P.ProductSubcategoryID IN (1,2,3) AND P.Weight > 25  
ORDER BY P.Weight;  
GO  
```  
  
### <a name="query-identifies-missing-statistics"></a><span data-ttu-id="c486b-226">查询识别缺少的统计信息</span><span class="sxs-lookup"><span data-stu-id="c486b-226">Query Identifies Missing Statistics</span></span>  
 <span data-ttu-id="c486b-227">如果错误或其他事件阻止查询优化器创建统计信息，则查询优化器将不使用统计信息创建查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-227">If an error or other event prevents the query optimizer from creating statistics, the query optimizer creates the query plan without using statistics.</span></span> <span data-ttu-id="c486b-228">查询优化器将统计信息标记为缺失，并且在下次执行查询时尝试重新生成统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-228">The query optimizer marks the statistics as missing and attempts to regenerate the statistics the next time the query is executed.</span></span>  
  
 <span data-ttu-id="c486b-229">在使用 [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]以图形方式显示查询的执行计划时，缺少的统计信息将予以警告显示（表名称以红色文本显示）。</span><span class="sxs-lookup"><span data-stu-id="c486b-229">Missing statistics are indicated as warnings (table name in red text) when the execution plan of a query is graphically displayed using [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="c486b-230">另外，使用 **监视** Missing Column Statistics [!INCLUDE[ssSqlProfiler](../../includes/sssqlprofiler-md.md)] 事件类可以指明何时缺少统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-230">Additionally, monitoring the **Missing Column Statistics** event class by using [!INCLUDE[ssSqlProfiler](../../includes/sssqlprofiler-md.md)] indicates when statistics are missing.</span></span> <span data-ttu-id="c486b-231">有关详细信息，请参阅 [Errors and Warnings 事件类别（数据库引擎）](../event-classes/errors-and-warnings-event-category-database-engine.md)。</span><span class="sxs-lookup"><span data-stu-id="c486b-231">For more information, see [Errors and Warnings Event Category &#40;Database Engine&#41;](../event-classes/errors-and-warnings-event-category-database-engine.md).</span></span>  
  
 <span data-ttu-id="c486b-232">如果缺少统计信息，则执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="c486b-232">If statistics are missing, perform the following steps:</span></span>  
  
-   <span data-ttu-id="c486b-233">确认 AUTO_CREATE_STATISTICS 和 AUTO_UPDATE_STATISTICS 为 ON。</span><span class="sxs-lookup"><span data-stu-id="c486b-233">Verify that AUTO_CREATE_STATISTICS and AUTO_UPDATE_STATISTICS are on.</span></span>  
  
-   <span data-ttu-id="c486b-234">请确保数据库不是只读的。</span><span class="sxs-lookup"><span data-stu-id="c486b-234">Verify that the database is not read-only.</span></span> <span data-ttu-id="c486b-235">如果数据库是只读的，则查询优化器无法保存统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-235">If the database is read-only, the query optimizer cannot save statistics.</span></span>  
  
-   <span data-ttu-id="c486b-236">通过使用 CREATE STATISTICS 语句创建缺少的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-236">Create the missing statistics by using the CREATE STATISTICS statement.</span></span>  
  
 <span data-ttu-id="c486b-237">当有关只读数据库或只读快照的统计信息丢失或变得陈旧时，[!INCLUDE[ssDE](../../../includes/ssde-md.md)]将创建临时统计信息并在 `tempdb` 中进行维护。</span><span class="sxs-lookup"><span data-stu-id="c486b-237">When statistics on a read-only database or read-only snapshot are missing or stale, the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] creates and maintains temporary statistics in `tempdb`.</span></span> <span data-ttu-id="c486b-238">当 [!INCLUDE[ssDE](../../../includes/ssde-md.md)] 创建临时统计信息时，将在统计信息名称后追加后缀 _readonly_database_statistic，以便将临时统计信息与永久统计信息加以区分。</span><span class="sxs-lookup"><span data-stu-id="c486b-238">When the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] creates temporary statistics, the statistics name is appended with the suffix _readonly_database_statistic to differentiate the temporary statistics from the permanent statistics.</span></span> <span data-ttu-id="c486b-239">后缀 suffix _readonly_database_statistic 是为 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]生成的统计信息预留的。</span><span class="sxs-lookup"><span data-stu-id="c486b-239">The suffix _readonly_database_statistic is reserved for statistics generated by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="c486b-240">可以在读写数据库上创建和重新生成临时统计信息的脚本。</span><span class="sxs-lookup"><span data-stu-id="c486b-240">Scripts for the temporary statistics can be created and reproduced on a read-write database.</span></span> <span data-ttu-id="c486b-241">编写脚本时， [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] 将统计信息名称的后缀从 _readonly_database_statistic 更改为 _readonly_database_statistic_scripted。</span><span class="sxs-lookup"><span data-stu-id="c486b-241">When scripted, [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] changes the suffix of the statistics name from _readonly_database_statistic to _readonly_database_statistic_scripted.</span></span>  
  
 <span data-ttu-id="c486b-242">只有 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 可以创建和更新临时统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-242">Only [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can create and update temporary statistics.</span></span> <span data-ttu-id="c486b-243">但是，您可以使用用于永久统计信息的相同工具来删除临时统计信息和监视统计信息属性：</span><span class="sxs-lookup"><span data-stu-id="c486b-243">However, you can delete temporary statistics and monitor statistics properties using the same tools that you use for permanent statistics:</span></span>  
  
-   <span data-ttu-id="c486b-244">使用 [DROP STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-statistics-transact-sql) 语句创建的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-244">Delete temporary statistics using the [DROP STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-statistics-transact-sql) statement.</span></span>  
  
-   <span data-ttu-id="c486b-245">使用 **sys.stats** 和 **sys.stats_columns** 目录视图监视统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-245">Monitor statistics using the **sys.stats** and **sys.stats_columns** catalog views.</span></span> <span data-ttu-id="c486b-246">**sys_stats** 包含 **is_temporary** 列，用于指示哪些统计信息是永久的，哪些统计信息是临时的。</span><span class="sxs-lookup"><span data-stu-id="c486b-246">**sys_stats** includes the **is_temporary** column, to indicate which statistics are permanent and which are temporary.</span></span>  
  
 <span data-ttu-id="c486b-247">因为临时统计信息存储在 `tempdb` 中，所以，重新启动 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 服务将导致所有临时统计信息消失。</span><span class="sxs-lookup"><span data-stu-id="c486b-247">Because temporary statistics are stored in `tempdb`, a restart of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] service causes all temporary statistics to disappear.</span></span>  
  
##  <a name="when-to-update-statistics"></a><a name="UpdateStatistics"></a><span data-ttu-id="c486b-248">更新统计信息的时间</span><span class="sxs-lookup"><span data-stu-id="c486b-248">When to Update Statistics</span></span>  
 <span data-ttu-id="c486b-249">查询优化器确定统计信息何时可能过期，然后在查询计划需要统计信息时更新它们。</span><span class="sxs-lookup"><span data-stu-id="c486b-249">The query optimizer determines when statistics might be out-of-date and then updates them when they are needed for a query plan.</span></span> <span data-ttu-id="c486b-250">在某些情况下，将 AUTO_UPDATE_STATISTICS 设置为 ON 时，可以通过频繁更新统计信息来优化查询计划，并因此提高查询性能。</span><span class="sxs-lookup"><span data-stu-id="c486b-250">In some cases you can improve the query plan and therefore improve query performance by updating statistics more frequently than occur when AUTO_UPDATE_STATISTICS is on.</span></span> <span data-ttu-id="c486b-251">可以使用 UPDATE STATISTICS 语句或存储过程 sp_updatestats 来更新统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-251">You can update statistics with the UPDATE STATISTICS statement or the stored procedure sp_updatestats.</span></span>  
  
 <span data-ttu-id="c486b-252">更新统计信息可确保查询使用最新的统计信息进行编译。</span><span class="sxs-lookup"><span data-stu-id="c486b-252">Updating statistics ensures that queries compile with up-to-date statistics.</span></span> <span data-ttu-id="c486b-253">不过，更新统计信息会导致查询重新编译。</span><span class="sxs-lookup"><span data-stu-id="c486b-253">However, updating statistics causes queries to recompile.</span></span> <span data-ttu-id="c486b-254">我们建议不要太频繁地更新统计信息，因为需要在改进查询计划和重新编译查询所用时间之间权衡性能。</span><span class="sxs-lookup"><span data-stu-id="c486b-254">We recommend not updating statistics too frequently because there is a performance tradeoff between improving query plans and the time it takes to recompile queries.</span></span> <span data-ttu-id="c486b-255">具体的折衷方案取决于你的应用程序。</span><span class="sxs-lookup"><span data-stu-id="c486b-255">The specific tradeoffs depend on your application.</span></span>  
  
 <span data-ttu-id="c486b-256">在使用 UPDATE STATISTICS 或 sp_updatestats 更新统计信息时，我们建议保持将 AUTO_UPDATE_STATISTICS 设置为 ON，以便查询优化器继续定期更新统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-256">When updating statistics with UPDATE STATISTICS or sp_updatestats, we recommend keeping AUTO_UPDATE_STATISTICS set to ON so that the query optimizer continues to routinely update statistics.</span></span> <span data-ttu-id="c486b-257">有关如何更新列、索引、表或索引视图的统计信息的详细信息，请参阅 [UPDATE STATISTICS (Transact-SQL)](/sql/t-sql/statements/update-statistics-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="c486b-257">For more information about how to update statistics on a column, an index, a table, or an indexed view, see [UPDATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/update-statistics-transact-sql).</span></span> <span data-ttu-id="c486b-258">有关如何为数据库中的所有用户定义表和内部表更新统计信息的信息，请参阅存储过程 [sp_updatestats (Transact-SQL)](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="c486b-258">For information about how to update statistics for all user-defined and internal tables in the database, see the stored procedure [sp_updatestats &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql).</span></span>  
  
 <span data-ttu-id="c486b-259">若要确定最近一次更新统计信息的时间，请使用 [STATS_DATE](/sql/t-sql/functions/stats-date-transact-sql) 函数。</span><span class="sxs-lookup"><span data-stu-id="c486b-259">To determine when statistics were last updated, use the [STATS_DATE](/sql/t-sql/functions/stats-date-transact-sql) function.</span></span>  
  
 <span data-ttu-id="c486b-260">在以下情况下考虑更新统计信息：</span><span class="sxs-lookup"><span data-stu-id="c486b-260">Consider updating statistics for the following conditions:</span></span>  
  
-   <span data-ttu-id="c486b-261">查询执行时间很长。</span><span class="sxs-lookup"><span data-stu-id="c486b-261">Query execution times are slow.</span></span>  
  
-   <span data-ttu-id="c486b-262">在升序或降序键列上发生插入操作。</span><span class="sxs-lookup"><span data-stu-id="c486b-262">Insert operations occur on ascending or descending key columns.</span></span>  
  
-   <span data-ttu-id="c486b-263">在维护操作后。</span><span class="sxs-lookup"><span data-stu-id="c486b-263">After maintenance operations.</span></span>  
  
### <a name="query-execution-times-are-slow"></a><span data-ttu-id="c486b-264">查询执行时间很长</span><span class="sxs-lookup"><span data-stu-id="c486b-264">Query Execution Times Are Slow</span></span>  
 <span data-ttu-id="c486b-265">如果查询响应时间很长或不可预知，则在执行其他故障排除步骤前，确保查询具有最新的统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-265">If query response times are slow or unpredictable, ensure that queries have up-to-date statistics before performing additional troubleshooting steps.</span></span>  
  
### <a name="insert-operations-occur-on-ascending-or-descending-key-columns"></a><span data-ttu-id="c486b-266">在升序或降序键列上发生插入操作</span><span class="sxs-lookup"><span data-stu-id="c486b-266">Insert Operations Occur on Ascending or Descending Key Columns</span></span>  
 <span data-ttu-id="c486b-267">与查询优化器执行的统计信息更新相比，升序或降序键列（例如 IDENTITY 或实时时间戳列）上的统计信息可能要求更频繁地更新。</span><span class="sxs-lookup"><span data-stu-id="c486b-267">Statistics on ascending or descending key columns, such as IDENTITY or real-time timestamp columns, might require more frequent statistics updates than the query optimizer performs.</span></span> <span data-ttu-id="c486b-268">插入操作将新值追加到升序或降序键列上。</span><span class="sxs-lookup"><span data-stu-id="c486b-268">Insert operations append new values to ascending or descending columns.</span></span> <span data-ttu-id="c486b-269">添加的行的数目可能过小，以致无法触发统计信息更新。</span><span class="sxs-lookup"><span data-stu-id="c486b-269">The number of rows added might be too small to trigger a statistics update.</span></span> <span data-ttu-id="c486b-270">如果统计信息不是最新的并且查询从最频繁添加的行中选择数据，则当前统计信息将没有这些新值的基数估计。</span><span class="sxs-lookup"><span data-stu-id="c486b-270">If statistics are not up-to-date and queries select from the most recently added rows, the current statistics will not have cardinality estimates for these new values.</span></span> <span data-ttu-id="c486b-271">这可能导致不精确的基数估计和查询性能低下。</span><span class="sxs-lookup"><span data-stu-id="c486b-271">This can result in inaccurate cardinality estimates and slow query performance.</span></span>  
  
 <span data-ttu-id="c486b-272">例如，如果统计信息未更新以包括最近销售订单日期的基数估计，则从最近销售订单日期选择的查询将具有不精确的基数估计。</span><span class="sxs-lookup"><span data-stu-id="c486b-272">For example, a query that selects from the most recent sales order dates will have inaccurate cardinality estimates if the statistics are not updated to include cardinality estimates for the most recent sales order dates.</span></span>  
  
### <a name="after-maintenance-operations"></a><span data-ttu-id="c486b-273">在维护操作后</span><span class="sxs-lookup"><span data-stu-id="c486b-273">After Maintenance Operations</span></span>  
 <span data-ttu-id="c486b-274">考虑在执行维护过程（例如截断表或对很大百分比的行执行大容量插入）后更新统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-274">Consider updating statistics after performing maintenance procedures that change the distribution of data, such as truncating a table or performing a bulk insert of a large percentage of the rows.</span></span> <span data-ttu-id="c486b-275">这可以避免在将来查询等待自动统计信息更新时在查询处理中出现延迟。</span><span class="sxs-lookup"><span data-stu-id="c486b-275">This can avoid future delays in query processing while queries wait for automatic statistics updates.</span></span>  
  
 <span data-ttu-id="c486b-276">索引的重新生成、碎片整理或重新组织之类的操作不会更改数据的分布。</span><span class="sxs-lookup"><span data-stu-id="c486b-276">Operations such as rebuilding, defragmenting, or reorganizing an index do not change the distribution of data.</span></span> <span data-ttu-id="c486b-277">因此，在执行 ALTER INDEX REBUILD、DBCC REINDEX、DBCC INDEXDEFRAG 或 ALTER INDEX REORGANIZE 操作后，您无需更新统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-277">Therefore, you do not need to update statistics after performing ALTER INDEX REBUILD, DBCC REINDEX, DBCC INDEXDEFRAG, or ALTER INDEX REORGANIZE operations.</span></span> <span data-ttu-id="c486b-278">查询优化器将在您使用 ALTER INDEX REBUILD 或 DBCC DBREINDEX 对表或视图重新生成索引时更新统计信息，但是，此统计信息更新是重新创建索引的副产品。</span><span class="sxs-lookup"><span data-stu-id="c486b-278">The query optimizer updates statistics when you rebuild an index on a table or view with ALTER INDEX REBUILD or DBCC DBREINDEX, however; this statistics update is a byproduct of re-creating the index.</span></span> <span data-ttu-id="c486b-279">在 DBCC INDEXDEFRAG 或 ALTER INDEX REORGANIZE 操作后，查询优化器并不更新统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-279">The query optimizer does not update statistics after DBCC INDEXDEFRAG or ALTER INDEX REORGANIZE operations.</span></span>  
  
##  <a name="queries-that-use-statistics-effectively"></a><a name="DesignStatistics"></a><span data-ttu-id="c486b-280">有效使用统计信息的查询</span><span class="sxs-lookup"><span data-stu-id="c486b-280">Queries That Use Statistics Effectively</span></span>  
 <span data-ttu-id="c486b-281">某些查询实现（如查询谓词中的局部变量和复杂的表达式）可能导致查询计划不是最佳的。</span><span class="sxs-lookup"><span data-stu-id="c486b-281">Certain query implementations, such as local variables and complex expressions in the query predicate, can lead to suboptimal query plans.</span></span> <span data-ttu-id="c486b-282">遵循有关高效使用统计信息的查询设计指导原则可以避免这种情况。</span><span class="sxs-lookup"><span data-stu-id="c486b-282">Following query design guidelines for using statistics effectively can help to avoid this.</span></span> <span data-ttu-id="c486b-283">有关查询谓词的详细信息，请参阅[搜索条件 (Transact-SQL)](/sql/t-sql/queries/search-condition-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="c486b-283">For more information about query predicates, see [Search Condition &#40;Transact-SQL&#41;](/sql/t-sql/queries/search-condition-transact-sql).</span></span>  
  
 <span data-ttu-id="c486b-284">您可以通过应用查询设计指导原则来改进查询计划，这些查询设计指导原则高效地使用统计信息，以便改进在查询谓词中使用的表达式、变量和函数的 *基数估计* 。</span><span class="sxs-lookup"><span data-stu-id="c486b-284">You can improve query plans by applying query design guidelines that use statistics effectively to improve *cardinality estimates* for expressions, variables, and functions used in query predicates.</span></span> <span data-ttu-id="c486b-285">在查询优化器不知道表达式、变量或函数的值时，它并不知道在直方图中要查找的值，因此无法从直方图检索最佳的基数估计。</span><span class="sxs-lookup"><span data-stu-id="c486b-285">When the query optimizer does not know the value of an expression, variable, or function, it does not know which value to lookup in the histogram and therefore cannot retrieve the best cardinality estimate from the histogram.</span></span> <span data-ttu-id="c486b-286">查询优化器而是为直方图中所有取样行，在每个不同值的平均行数的基础上执行基数估计。</span><span class="sxs-lookup"><span data-stu-id="c486b-286">Instead, the query optimizer bases the cardinality estimate on the average number of rows per distinct value for all of the sampled rows in the histogram.</span></span> <span data-ttu-id="c486b-287">这将导致不是最佳的基数估计并且可能影响查询性能。</span><span class="sxs-lookup"><span data-stu-id="c486b-287">This leads to suboptimal cardinality estimates and can hurt query performance.</span></span>  
  
 <span data-ttu-id="c486b-288">下面的指导原则描述如何编写查询以便通过改进基数估计来改进查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-288">The following guidelines describe how to write queries to improve query plans by improving cardinality estimates.</span></span>  
  
### <a name="improving-cardinality-estimates-for-expressions"></a><span data-ttu-id="c486b-289">改进表达式的基数估计</span><span class="sxs-lookup"><span data-stu-id="c486b-289">Improving Cardinality Estimates for Expressions</span></span>  
 <span data-ttu-id="c486b-290">要改进表达式的基数估计，请遵循以下指导原则：</span><span class="sxs-lookup"><span data-stu-id="c486b-290">To improve cardinality estimates for expressions, follow these guidelines:</span></span>  
  
-   <span data-ttu-id="c486b-291">只要可能，应简化其中含常量的表达式。</span><span class="sxs-lookup"><span data-stu-id="c486b-291">Whenever possible, simplify expressions with constants in them.</span></span> <span data-ttu-id="c486b-292">查询优化器在确定基数估计前并不对包含常量的所有函数和表达式进行求值。</span><span class="sxs-lookup"><span data-stu-id="c486b-292">The query optimizer does not evaluate all functions and expressions containing constants prior to determining cardinality estimates.</span></span> <span data-ttu-id="c486b-293">例如，简化表达式 ABS(`-100) to 100`。</span><span class="sxs-lookup"><span data-stu-id="c486b-293">For example, simplify the expression ABS(`-100) to 100`.</span></span>  
  
-   <span data-ttu-id="c486b-294">如果表达式使用多个变量，则考虑为表达式创建一个计算列，然后对该计算列创建统计信息或索引。</span><span class="sxs-lookup"><span data-stu-id="c486b-294">If the expression uses multiple variables, consider creating a computed column for the expression and then create statistics or an index on the computed column.</span></span> <span data-ttu-id="c486b-295">例如，如果您为表达式 `WHERE PRICE + Tax > 100` 创建计算列，则查询谓词 `Price + Tax`可能会具有更好的基数估计。</span><span class="sxs-lookup"><span data-stu-id="c486b-295">For example, the query predicate `WHERE PRICE + Tax > 100` might have a better cardinality estimate if you create a computed column for the expression `Price + Tax`.</span></span>  
  
### <a name="improving-cardinality-estimates-for-variables-and-functions"></a><span data-ttu-id="c486b-296">改进变量和函数的基数估计</span><span class="sxs-lookup"><span data-stu-id="c486b-296">Improving Cardinality Estimates for Variables and Functions</span></span>  
 <span data-ttu-id="c486b-297">要改进变量和函数的基数估计，请遵循以下指导原则：</span><span class="sxs-lookup"><span data-stu-id="c486b-297">To improve the cardinality estimates for variables and functions, follow these guidelines:</span></span>  
  
-   <span data-ttu-id="c486b-298">如果查询谓词使用局部变量，则考虑重新编写查询以使用参数，而非局部变量。</span><span class="sxs-lookup"><span data-stu-id="c486b-298">If the query predicate uses a local variable, consider rewriting the query to use a parameter instead of a local variable.</span></span> <span data-ttu-id="c486b-299">在查询优化器创建查询执行计划时，局部变量的值未知。</span><span class="sxs-lookup"><span data-stu-id="c486b-299">The value of a local variable is not known when the query optimizer creates the query execution plan.</span></span> <span data-ttu-id="c486b-300">在查询使用某一参数时，查询优化器将基数估计用于传递到存储过程的第一个实际参数值。</span><span class="sxs-lookup"><span data-stu-id="c486b-300">When a query uses a parameter, the query optimizer uses the cardinality estimate for the first actual parameter value that is passed to the stored procedure.</span></span>  
  
-   <span data-ttu-id="c486b-301">考虑使用标准表或临时表来保存多语句表值函数的结果。</span><span class="sxs-lookup"><span data-stu-id="c486b-301">Consider using a standard table or temporary table to hold the results of multi-statement table-valued functions.</span></span> <span data-ttu-id="c486b-302">查询优化器并不为多语句表值函数创建统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-302">The query optimizer does not create statistics for multi-statement table-valued functions.</span></span> <span data-ttu-id="c486b-303">使用此方法，查询优化器可对表列创建统计信息并使用它们创建更好的查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-303">With this approach the query optimizer can create statistics on the table columns and use them to create a better query plan.</span></span>  
  
-   <span data-ttu-id="c486b-304">考虑使用标准表或临时表来代替表变量。</span><span class="sxs-lookup"><span data-stu-id="c486b-304">Consider using a standard table or temporary table as a replacement for table variables.</span></span> <span data-ttu-id="c486b-305">查询优化器不会为表变量创建统计信息。</span><span class="sxs-lookup"><span data-stu-id="c486b-305">The query optimizer does not create statistics for table variables.</span></span> <span data-ttu-id="c486b-306">使用此方法，查询优化器可对表列创建统计信息并使用它们创建更好的查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-306">With this approach the query optimizer can create statistics on the table columns and use them to create a better query plan.</span></span> <span data-ttu-id="c486b-307">在确定是使用临时表还是表变量时需要进行一些权衡，与临时表相比，在存储过程中使用的表变量会导致更少的存储过程的重新编译。</span><span class="sxs-lookup"><span data-stu-id="c486b-307">There are tradeoffs in determining whether to use a temporary table or a table variable; Table variables used in stored procedures cause fewer recompilations of the stored procedure than temporary tables.</span></span> <span data-ttu-id="c486b-308">根据应用程序，使用临时表来代替表变量可能不会改进性能。</span><span class="sxs-lookup"><span data-stu-id="c486b-308">Depending on the application, using a temporary table instead of a table variable might not improve performance.</span></span>  
  
-   <span data-ttu-id="c486b-309">如果某一存储过程包含使用某一传入的参数的查询，则在查询中使用该参数值之前，应避免在该存储过程内更改该参数值。</span><span class="sxs-lookup"><span data-stu-id="c486b-309">If a stored procedure contains a query that uses a passed-in parameter, avoid changing the parameter value within the stored procedure before using it in the query.</span></span> <span data-ttu-id="c486b-310">查询的基数估计基于传入的参数值，而非更新的值。</span><span class="sxs-lookup"><span data-stu-id="c486b-310">The cardinality estimates for the query are based on the passed-in parameter value and not the updated value.</span></span> <span data-ttu-id="c486b-311">为了避免更改参数值，您可以重新编写查询以使用两个存储过程。</span><span class="sxs-lookup"><span data-stu-id="c486b-311">To avoid changing the parameter value, you can rewrite the query to use two stored procedures.</span></span>  
  
     <span data-ttu-id="c486b-312">例如，以下存储过程 `Sales.GetRecentSales` 将在 `@date` 时更改参数 `@date is NULL`的值。</span><span class="sxs-lookup"><span data-stu-id="c486b-312">For example, the following stored procedure `Sales.GetRecentSales` changes the value of the parameter `@date` when `@date is NULL`.</span></span>  
  
    ```  
    USE AdventureWorks2012;  
    GO  
    IF OBJECT_ID ( 'Sales.GetRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetRecentSales (@date datetime)  
    AS BEGIN  
        IF @date is NULL  
            SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
        SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
        WHERE h.SalesOrderID = d.SalesOrderID  
        AND h.OrderDate > @date  
    END  
    GO  
    ```  
  
     <span data-ttu-id="c486b-313">如果对存储过程 `Sales.GetRecentSales` 的首次调用为 `@date` 参数传递了 NULL，则查询优化器将使用针对 `@date = NULL` 的基数估计编译存储过程，即使查询谓词不是使用 `@date = NULL`调用的。</span><span class="sxs-lookup"><span data-stu-id="c486b-313">If the first call to the stored procedure `Sales.GetRecentSales` passes a NULL for the `@date` parameter, the query optimizer will compile the stored procedure with the cardinality estimate for `@date = NULL` even though the query predicate is not called with `@date = NULL`.</span></span> <span data-ttu-id="c486b-314">此基数估计可能与实际查询结果中的行数差别很大。</span><span class="sxs-lookup"><span data-stu-id="c486b-314">This cardinality estimate might be significantly different than the number of rows in the actual query result.</span></span> <span data-ttu-id="c486b-315">因此，查询优化器可能会选择非最佳查询计划。</span><span class="sxs-lookup"><span data-stu-id="c486b-315">As a result, the query optimizer might choose a suboptimal query plan.</span></span> <span data-ttu-id="c486b-316">若要避免此情况发生，您可以按如下所示将存储过程重新编写成两个过程：</span><span class="sxs-lookup"><span data-stu-id="c486b-316">To help avoid this, you can rewrite the stored procedure into two procedures as follows:</span></span>  
  
    ```  
    USE AdventureWorks2012;  
    GO  
    IF OBJECT_ID ( 'Sales.GetNullRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetNullRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetNullRecentSales (@date datetime)  
    AS BEGIN  
        IF @date is NULL  
            SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
        EXEC Sales.GetNonNullRecentSales @date;  
    END  
    GO  
    IF OBJECT_ID ( 'Sales.GetNonNullRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetNonNullRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetNonNullRecentSales (@date datetime)  
    AS BEGIN  
        SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
        WHERE h.SalesOrderID = d.SalesOrderID  
        AND h.OrderDate > @date  
    END  
    GO  
    ```  
  
### <a name="improving-cardinality-estimates-with-query-hints"></a><span data-ttu-id="c486b-317">使用查询提示改进基数估计</span><span class="sxs-lookup"><span data-stu-id="c486b-317">Improving Cardinality Estimates with Query Hints</span></span>  
 <span data-ttu-id="c486b-318">为了改进局部变量的基数估计，您可以将 OPTIMIZE FOR 或 OPTIMIZE FOR UNKNOWN 查询提示与 RECOMPILE 一起使用。</span><span class="sxs-lookup"><span data-stu-id="c486b-318">To improve cardinality estimates for local variables, you can use the OPTIMIZE FOR or OPTIMIZE FOR UNKNOWN query hints with RECOMPILE.</span></span> <span data-ttu-id="c486b-319">有关详细信息，请参阅[查询提示 (Transact-SQL)](/sql/t-sql/queries/hints-transact-sql-query)。</span><span class="sxs-lookup"><span data-stu-id="c486b-319">For more information, see [Query Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span></span>  
  
 <span data-ttu-id="c486b-320">对于某些应用程序，每次执行查询时都重新编译查询可能会占用过多时间。</span><span class="sxs-lookup"><span data-stu-id="c486b-320">For some applications, recompiling the query each time it executes might take too much time.</span></span> <span data-ttu-id="c486b-321">OPTIMIZER FOR 查询提示可对此给予帮助，即使您不使用 RECOMPILE 选项。</span><span class="sxs-lookup"><span data-stu-id="c486b-321">The OPTIMIZER FOR query hint can help even if you don't use the RECOMPILE option.</span></span> <span data-ttu-id="c486b-322">例如，您可以将 OPTIMIZER FOR 选项添加到存储过程 Sales.GetRecentSales，以便指定一个特定的日期。</span><span class="sxs-lookup"><span data-stu-id="c486b-322">For example, you could add an OPTIMIZER FOR option to the stored procedure Sales.GetRecentSales to specify a specific date.</span></span> <span data-ttu-id="c486b-323">以下示例将 OPTIMIZE FOR 选项添加到 Sales.GetRecentSales 过程。</span><span class="sxs-lookup"><span data-stu-id="c486b-323">The following example adds the OPTIMIZE FOR option to the Sales.GetRecentSales procedure.</span></span>  
  
```sql
USE AdventureWorks2012;  
GO  
IF OBJECT_ID ( 'Sales.GetRecentSales', 'P') IS NOT NULL  
    DROP PROCEDURE Sales.GetRecentSales;  
GO  
CREATE PROCEDURE Sales.GetRecentSales (@date datetime)  
AS BEGIN  
    IF @date is NULL  
        SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
    SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
    WHERE h.SalesOrderID = d.SalesOrderID  
    AND h.OrderDate > @date  
    OPTION ( OPTIMIZE FOR ( @date = '2004-05-01 00:00:00.000'))  
END;  
GO  
```  
  
### <a name="improving-cardinality-estimates-with-plan-guides"></a><span data-ttu-id="c486b-324">使用计划指南改进基数估计</span><span class="sxs-lookup"><span data-stu-id="c486b-324">Improving Cardinality Estimates with Plan Guides</span></span>  
 <span data-ttu-id="c486b-325">对于某些应用程序，查询计划指南可能不适用，因为您无法更改查询，或者使用 RECOMPILE 查询提示可能导致过多的重新编译。</span><span class="sxs-lookup"><span data-stu-id="c486b-325">For some applications, query design guidelines might not apply because you cannot change the query or using the RECOMPILE query hint might be cause too many recompiles.</span></span> <span data-ttu-id="c486b-326">您可以使用计划指南来指定 USE PLAN 之类的其他提示，以便在向应用程序供应商调查应用程序变化的同时，控制查询的行为。</span><span class="sxs-lookup"><span data-stu-id="c486b-326">You can use plan guides to specify other hints, such as USE PLAN, to control the behavior of the query while investigating application changes with the application vendor.</span></span> <span data-ttu-id="c486b-327">有关计划指南的详细信息，请参阅 [Plan Guides](../performance/plan-guides.md)。</span><span class="sxs-lookup"><span data-stu-id="c486b-327">For more information about plan guides, see [Plan Guides](../performance/plan-guides.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c486b-328">另请参阅</span><span class="sxs-lookup"><span data-stu-id="c486b-328">See Also</span></span>  
 <span data-ttu-id="c486b-329">[CREATE STATISTICS (Transact-SQL)](/sql/t-sql/statements/create-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="c486b-329">[CREATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-statistics-transact-sql) </span></span>  
 <span data-ttu-id="c486b-330">[UPDATE STATISTICS (Transact-SQL)](/sql/t-sql/statements/update-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="c486b-330">[UPDATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/update-statistics-transact-sql) </span></span>  
 <span data-ttu-id="c486b-331">[sp_updatestats (Transact-SQL)](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="c486b-331">[sp_updatestats &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql) </span></span>  
 <span data-ttu-id="c486b-332">[DBCC SHOW_STATISTICS (Transact-SQL)](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="c486b-332">[DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql) </span></span>  
 <span data-ttu-id="c486b-333">[ALTER DATABASE SET 选项 (Transact-SQL)](/sql/t-sql/statements/alter-database-transact-sql-set-options) </span><span class="sxs-lookup"><span data-stu-id="c486b-333">[ALTER DATABASE SET Options &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-set-options) </span></span>  
 <span data-ttu-id="c486b-334">[DROP STATISTICS (Transact-SQL)](/sql/t-sql/statements/drop-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="c486b-334">[DROP STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-statistics-transact-sql) </span></span>  
 <span data-ttu-id="c486b-335">[CREATE INDEX (Transact-SQL)](/sql/t-sql/statements/create-index-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="c486b-335">[CREATE INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-index-transact-sql) </span></span>  
 <span data-ttu-id="c486b-336">[ALTER INDEX (Transact-SQL)](/sql/t-sql/statements/alter-index-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="c486b-336">[ALTER INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-index-transact-sql) </span></span>  
 [<span data-ttu-id="c486b-337">创建筛选索引</span><span class="sxs-lookup"><span data-stu-id="c486b-337">Create Filtered Indexes</span></span>](../indexes/create-filtered-indexes.md)  
