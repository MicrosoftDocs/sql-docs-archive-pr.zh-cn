---
title: 改进全文查询的性能 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: search
ms.topic: conceptual
ms.assetid: 0658dc74-25eb-4486-bbd6-e85c1f92c272
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: a1437f710725df5c87d31f6a80939a5d7869b412
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87690475"
---
# <a name="improve-the-performance-of-full-text-queries"></a><span data-ttu-id="b2948-102">改进全文查询的性能</span><span class="sxs-lookup"><span data-stu-id="b2948-102">Improve the Performance of Full-Text Queries</span></span>
  <span data-ttu-id="b2948-103">下面列出了有助于提高全文查询性能的建议。</span><span class="sxs-lookup"><span data-stu-id="b2948-103">The following is a list of recommendations that will help to improve the performance of full-text queries.</span></span>  
  
 <span data-ttu-id="b2948-104">硬件资源（例如内存、磁盘速度、CPU 速度和计算机体系结构）也会影响全文查询的性能。</span><span class="sxs-lookup"><span data-stu-id="b2948-104">The performance of full-text queries is also influenced by hardware resources, such as memory, disk speed, CPU speed, and machine architecture.</span></span>  
  
-   <span data-ttu-id="b2948-105">使用 [ALTER INDEX REORGANIZE](/sql/t-sql/statements/alter-index-transact-sql)对基表的索引进行碎片整理。</span><span class="sxs-lookup"><span data-stu-id="b2948-105">Defragment the index of the base table by using [ALTER INDEX REORGANIZE](/sql/t-sql/statements/alter-index-transact-sql).</span></span>  
  
-   <span data-ttu-id="b2948-106">使用 [ALTER FULLTEXT CATALOG REORGANIZE](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)重新组织全文目录。</span><span class="sxs-lookup"><span data-stu-id="b2948-106">Reorganize the full-text catalog by using [ALTER FULLTEXT CATALOG REORGANIZE](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql).</span></span> <span data-ttu-id="b2948-107">请务必在性能测试之前执行此操作，因为它会导致该目录中全文索引的主合并。</span><span class="sxs-lookup"><span data-stu-id="b2948-107">Make sure that you do this before performance testing because running this statement causes a master merge of the full-text indexes in that catalog.</span></span>  
  
-   <span data-ttu-id="b2948-108">仅选择较小的列作为全文键列。</span><span class="sxs-lookup"><span data-stu-id="b2948-108">Restrict your choice of full-text key columns to a small column.</span></span> <span data-ttu-id="b2948-109">尽管支持 900 个字节的列，但我们建议在全文索引中使用更小的键列。</span><span class="sxs-lookup"><span data-stu-id="b2948-109">Although a 900-byte column is supported, we recommend using a smaller key column in a full-text index.</span></span> <span data-ttu-id="b2948-110">`int` 和 `bigint` 可提供最佳性能。</span><span class="sxs-lookup"><span data-stu-id="b2948-110">`int` and `bigint` provide the best performance.</span></span>  
  
-   <span data-ttu-id="b2948-111">使用整数型全文键可以避免与 **docid** 映射表联接。</span><span class="sxs-lookup"><span data-stu-id="b2948-111">Using an integer full-text key avoids a join with the **docid** mapping table.</span></span> <span data-ttu-id="b2948-112">因此，整数型全文键可以使查询性能获得数量级的提升，并改进爬网性能。</span><span class="sxs-lookup"><span data-stu-id="b2948-112">Therefore, an integer full-text key improves query performance by an order of magnitude and improves crawl performance.</span></span> <span data-ttu-id="b2948-113">如果全文键也是聚集索引键，可能会进一步提高性能。</span><span class="sxs-lookup"><span data-stu-id="b2948-113">Additional performance benefits might result if the full-text key is also the clustered index key.</span></span>  
  
-   <span data-ttu-id="b2948-114">将多个 [CONTAINS](/sql/t-sql/queries/contains-transact-sql) 谓词合并为一个 CONTAINS 谓词。</span><span class="sxs-lookup"><span data-stu-id="b2948-114">Combine multiple [CONTAINS](/sql/t-sql/queries/contains-transact-sql) predicates into one CONTAINS predicate.</span></span> <span data-ttu-id="b2948-115">在 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 中，您可以在 CONTAINS 查询中指定一个包含若干列的列表。</span><span class="sxs-lookup"><span data-stu-id="b2948-115">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] you can specify a list of columns in the CONTAINS query.</span></span>  
  
-   <span data-ttu-id="b2948-116">如果只需要全文键或排名的信息，请使用 [CONTAINSTABLE](/sql/relational-databases/system-functions/containstable-transact-sql) 或 [FREETEXTTABLE](/sql/relational-databases/system-functions/freetexttable-transact-sql) ，而不要使用分别与之对应的 CONTAINS 或 FREETEXT。</span><span class="sxs-lookup"><span data-stu-id="b2948-116">If you only require full-text key or rank information, use [CONTAINSTABLE](/sql/relational-databases/system-functions/containstable-transact-sql) or [FREETEXTTABLE](/sql/relational-databases/system-functions/freetexttable-transact-sql) instead of CONTAINS or FREETEXT, respectively.</span></span>  
  
-   <span data-ttu-id="b2948-117">若要限制结果数并提高性能，请使用 FREETEXTTABLE 和 CONTAINSTABLE 函数的 *top_n_by_rank* 参数。</span><span class="sxs-lookup"><span data-stu-id="b2948-117">To limit results and increase performance, use the *top_n_by_rank* parameter of the FREETEXTTABLE and CONTAINSTABLE functions.</span></span> <span data-ttu-id="b2948-118">使用*top_n_by_rank* 可以只返回最密切相关的匹配项。</span><span class="sxs-lookup"><span data-stu-id="b2948-118">*top_n_by_rank* allows you to recall only the most relevant hits.</span></span> <span data-ttu-id="b2948-119">仅当商业应用场景不需要返回所有可能的匹配项（即不需要“返回全部项”  ）时，才应使用此参数。</span><span class="sxs-lookup"><span data-stu-id="b2948-119">Use this parameter only if your business scenario does not require recalling all possible hits (that is, it does not require *total recall*).</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="b2948-120">法律应用场景通常需要返回全部项，不过对于诸如电子商务等商业应用场景，性能可能更为重要。</span><span class="sxs-lookup"><span data-stu-id="b2948-120">Total recall is typically necessary for legal scenarios but might be less important than performance for business scenarios such as an e-business.</span></span>  
  
-   <span data-ttu-id="b2948-121">检查全文查询计划以确保选择了适当的联接计划。</span><span class="sxs-lookup"><span data-stu-id="b2948-121">Check the full-text query plan to make sure that the appropriate join plan is chosen.</span></span> <span data-ttu-id="b2948-122">若有必要，可使用一个联接提示或查询提示。</span><span class="sxs-lookup"><span data-stu-id="b2948-122">Use a join hint or query hint if you have to.</span></span> <span data-ttu-id="b2948-123">如果全文查询中使用了参数，则该参数的第一时间值决定查询计划。</span><span class="sxs-lookup"><span data-stu-id="b2948-123">If a parameter is used in the full-text query, the first-time value of the parameter determines the query plan.</span></span> <span data-ttu-id="b2948-124">可以使用 OPTIMIZE FOR [查询提示](/sql/t-sql/queries/hints-transact-sql-query) 强制用您指定的值编译查询。</span><span class="sxs-lookup"><span data-stu-id="b2948-124">You can use the OPTIMIZE FOR [query hint](/sql/t-sql/queries/hints-transact-sql-query) to force the query to compile with the value you want.</span></span> <span data-ttu-id="b2948-125">这有助于实现确定性查询计划和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="b2948-125">This helps achieve a deterministic query plan and better performance.</span></span>  
  
-   <span data-ttu-id="b2948-126">如果全文索引中的全文索引碎片太多，会导致查询性能大幅下降。</span><span class="sxs-lookup"><span data-stu-id="b2948-126">Too many full-text index fragments in the full-text index, can lead to substantial degradation in query performance.</span></span> <span data-ttu-id="b2948-127">若要减少碎片数，请使用 [ALTER FULLTEXT CATALOG](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)[!INCLUDE[tsql](../../includes/tsql-md.md)] 语句的 REORGANIZE 选项重新组织全文目录。</span><span class="sxs-lookup"><span data-stu-id="b2948-127">To reduce the number of fragments, reorganize the full-text catalog by using the REORGANIZE option of the [ALTER FULLTEXT CATALOG](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)[!INCLUDE[tsql](../../includes/tsql-md.md)] statement.</span></span> <span data-ttu-id="b2948-128">实际上，该语句会将所有碎片合并成单个更大的碎片，并从全文索引中删除所有过时的条目。</span><span class="sxs-lookup"><span data-stu-id="b2948-128">This statement essentially merges all the fragments into a single larger fragment and removes all obsolete entries from the full-text index.</span></span>  
  
-   <span data-ttu-id="b2948-129">在  全文搜索中，在 CONTAINSTABLE (AND, OR) 中指定的逻辑运算符可以作为 SQL 联接实现或在全文执行流式表值函数 (STVF) 中实现。</span><span class="sxs-lookup"><span data-stu-id="b2948-129">In  full-text search, logical operators specified in CONTAINSTABLE (AND, OR) can be implemented either as SQL joins or inside the full-text execution streaming table-valued functions (STVF).</span></span> <span data-ttu-id="b2948-130">通常，仅包含一种逻辑运算符的查询完全由全文执行实现，而混合多种逻辑运算符的查询还拥有 SQL 联接。</span><span class="sxs-lookup"><span data-stu-id="b2948-130">Typically, queries with only one type of logical operators are implemented purely by full-text execution, whereas queries that mix logical operators also possess SQL joins.</span></span> <span data-ttu-id="b2948-131">全文执行 STVF 内的逻辑运算符在实现时使用了一些特殊索引属性，使它比 SQL 联接速度快得多。</span><span class="sxs-lookup"><span data-stu-id="b2948-131">Implementation of a logical operator inside the full-text execution STVF uses some special index properties that make it much faster than SQL joins.</span></span> <span data-ttu-id="b2948-132">由于这个原因，我们建议在可能的情况下仅使用一种逻辑运算符来构建查询框架。</span><span class="sxs-lookup"><span data-stu-id="b2948-132">For this reason, we recommend that, where possible, you frame queries using only a single type of logical operator.</span></span>  
  
-   <span data-ttu-id="b2948-133">对于包含选择性关系谓词的应用程序，如果将使用选择性关系谓词和非选择性全文谓词的查询编写成使用查询优化器，则这样的查询可能会有最佳性能。</span><span class="sxs-lookup"><span data-stu-id="b2948-133">For applications that contain selective-relation predications, queries that use selective relational predicates and unselective full-text predicates might perform best when they are written to use the query optimizer.</span></span> <span data-ttu-id="b2948-134">这将允许查询优化器决定它是否可以利用谓词或范围下推来生成有效的查询计划。</span><span class="sxs-lookup"><span data-stu-id="b2948-134">This allows the query optimizer to decide whether it can exploit predicate or range pushdown to produce an effective query plan.</span></span> <span data-ttu-id="b2948-135">与将关系数据作为全文数据建立索引相比，此方法更简单，通常也更有效。</span><span class="sxs-lookup"><span data-stu-id="b2948-135">This approach is simpler and often more efficient than indexing relational data as full-text data.</span></span>  
  
## <a name="related-resources"></a><span data-ttu-id="b2948-136">相关资源</span><span class="sxs-lookup"><span data-stu-id="b2948-136">Related Resources</span></span>  
 [<span data-ttu-id="b2948-137">SQL Server 2008 Full-Text Search: Internals and Enhancements（SQL Server 2008 全文搜索：内在变化与增强功能）</span><span class="sxs-lookup"><span data-stu-id="b2948-137">SQL Server 2008 Full-Text Search: Internals and Enhancements</span></span>](https://go.microsoft.com/fwlink/?LinkId=129544)  
  
## <a name="see-also"></a><span data-ttu-id="b2948-138">另请参阅</span><span class="sxs-lookup"><span data-stu-id="b2948-138">See Also</span></span>  
 <span data-ttu-id="b2948-139">[sys.dm_fts_memory_buffers (Transact-SQL)](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="b2948-139">[sys.dm_fts_memory_buffers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql) </span></span>  
 [<span data-ttu-id="b2948-140">sys.dm_fts_memory_pools (Transact-SQL)</span><span class="sxs-lookup"><span data-stu-id="b2948-140">sys.dm_fts_memory_pools &#40;Transact-SQL&#41;</span></span>](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-pools-transact-sql)  
  
  
