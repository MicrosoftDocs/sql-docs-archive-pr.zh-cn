---
title: 处理变更数据 (SQL Server) | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- change data [SQL Server]
- change data capture [SQL Server], query function scenarios
- change data capture [SQL Server], LSN boundaries
- change data capture [SQL Server], query functions
ms.assetid: 5346b852-1af8-4080-b278-12efb9b735eb
author: rothja
ms.author: jroth
ms.openlocfilehash: 018d5add95e5d0936f6055e1c6710b6a8ddabdab
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87588377"
---
# <a name="work-with-change-data-sql-server"></a><span data-ttu-id="f0fa4-102">处理变更数据 (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="f0fa4-102">Work with Change Data (SQL Server)</span></span>
  <span data-ttu-id="f0fa4-103">可通过表值函数 (TVF) 为变更数据捕获使用者提供更改数据。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-103">Change data is made available to change data capture consumers through table-valued functions (TVFs).</span></span> <span data-ttu-id="f0fa4-104">这些函数的所有查询均需要使用两个参数来定义日志序列号 (LSN) 范围，在开发返回的结果集时需要考虑这些序列号。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-104">All queries of these functions require two parameters to define the range of Log Sequence Numbers (LSNs) that are eligible for consideration when developing the returned result set.</span></span> <span data-ttu-id="f0fa4-105">限定这一间隔的较高和较低 LSN 值均包含在间隔中。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-105">Both the upper and lower LSN values that bound the interval are considered to be included within the interval.</span></span>  
  
 <span data-ttu-id="f0fa4-106">系统提供了几个函数，以帮助确定用于查询 TVF 的相应 LSN 值。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-106">Several functions are provided to help determine appropriate LSN values for use in querying a TVF.</span></span> <span data-ttu-id="f0fa4-107">[sys.fn_cdc_get_min_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-get-min-lsn-transact-sql) 函数返回与捕获实例有效性间隔关联的最小 LSN。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-107">The function [sys.fn_cdc_get_min_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-get-min-lsn-transact-sql) returns the smallest LSN that is associated with a capture instance validity interval.</span></span> <span data-ttu-id="f0fa4-108">有效性间隔是指更改数据当前可供其捕获实例使用的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-108">The validity interval is the time interval for which change data is currently available for its capture instances.</span></span> <span data-ttu-id="f0fa4-109">[sys.fn_cdc_get_max_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-get-max-lsn-transact-sql) 函数返回有效性间隔中的最大 LSN。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-109">The function [sys.fn_cdc_get_max_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-get-max-lsn-transact-sql) returns the largest LSN in the validity interval.</span></span> <span data-ttu-id="f0fa4-110">[sys.fn_cdc_map_time_to_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-map-time-to-lsn-transact-sql) 和 [sys.fn_cdc_map_lsn_to_time](/sql/relational-databases/system-functions/sys-fn-cdc-map-lsn-to-time-transact-sql) 函数可帮助将 LSN 值置于常规时间线上。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-110">The functions [sys.fn_cdc_map_time_to_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-map-time-to-lsn-transact-sql) and [sys.fn_cdc_map_lsn_to_time](/sql/relational-databases/system-functions/sys-fn-cdc-map-lsn-to-time-transact-sql) are available to help place LSN values on a conventional timeline.</span></span> <span data-ttu-id="f0fa4-111">由于变更数据捕获使用闭合查询间隔，因此，有时需要按顺序生成下一个 LSN 值，以确保在连续查询窗口中不会出现重复更改。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-111">Because change data capture uses closed query intervals, it is sometimes necessary to generate the next LSN value in a sequence to ensure that changes are not duplicated in consecutive query windows.</span></span> <span data-ttu-id="f0fa4-112">[sys.fn_cdc_increment_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-increment-lsn-transact-sql) 和 [sys.fn_cdc_decrement_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-decrement-lsn-transact-sql) 函数在需要对 LSN 值进行增量调整时非常有用。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-112">The functions [sys.fn_cdc_increment_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-increment-lsn-transact-sql) and [sys.fn_cdc_decrement_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-decrement-lsn-transact-sql) are useful when an incremental adjustment to an LSN value is required.</span></span>  
  
##  <a name="validating-lsn-boundaries"></a><a name="LSN"></a> <span data-ttu-id="f0fa4-113">验证 LSN 界限</span><span class="sxs-lookup"><span data-stu-id="f0fa4-113">Validating LSN Boundaries</span></span>  
 <span data-ttu-id="f0fa4-114">对于要在 TVF 查询中使用的 LSN 界限，我们建议在使用之前对其进行验证。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-114">We recommend validating the LSN boundaries that are to be used in a TVF query before their use.</span></span> <span data-ttu-id="f0fa4-115">如果端点为 Null 或位于捕获实例有效性间隔之外，则会强制变更数据捕获 TVF 返回一个错误。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-115">Null endpoints or endpoints that lie outside the validity interval for a capture instance will force an error to be returned by a change data capture TVF.</span></span>  
  
 <span data-ttu-id="f0fa4-116">例如，如果用于定义查询间隔的参数无效，或超出范围，或行筛选器选项无效，则针对所有更改的查询将返回以下错误。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-116">For example, the following error is returned for a query for all changes when a parameter that is used to define the query interval is not valid, or is out of range, or the row filter option is invalid.</span></span>  
  
 `Msg 313, Level 16, State 3, Line 1`  
  
 `An insufficient number of arguments were supplied for the procedure or function cdc.fn_cdc_get_all_changes_ ...`  
  
 <span data-ttu-id="f0fa4-117">为 `net changes` 查询返回的相应错误如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0fa4-117">The corresponding error returned for a `net changes` query is the following:</span></span>  
  
 `Msg 313, Level 16, State 3, Line 1`  
  
 `An insufficient number of arguments were supplied for the procedure or function cdc.fn_cdc_get_net_changes_ ...`  
  
> [!NOTE]  
>  <span data-ttu-id="f0fa4-118">目前已认识到“消息 313”的消息具有误导性，并未提供失败的真正原因。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-118">It is recognized that the message for Msg 313 is misleading and does not convey the actual cause of the failure.</span></span> <span data-ttu-id="f0fa4-119">这种欠妥的用法源于无法从 TVF 中引发显式错误。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-119">This awkward usage stems from the inability to raise an explicit error from within a TVF.</span></span> <span data-ttu-id="f0fa4-120">然而，即便返回可识别的错误值不准确，也比仅仅返回空结果要好。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-120">Nevertheless, the value of returning a recognizable, if inaccurate, error was deemed preferable to simply returning an empty result.</span></span> <span data-ttu-id="f0fa4-121">无法将空结果集与未返回任何更改的有效查询区分开来。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-121">An empty result set would not be distinguishable from a valid query returning no changes.</span></span>  
  
 <span data-ttu-id="f0fa4-122">如果授权失败，在查询所有更改时将返回失败，如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0fa4-122">Authorization failures will return failures when querying for all changes, as shown:</span></span>  
  
 `Msg 229, Level 14, State 5, Line 1`  
  
 `The SELECT permission was denied on the object 'fn_cdc_get_all_changes_...', database 'MyDB', schema 'cdc'.`  
  
 <span data-ttu-id="f0fa4-123">这也适用于净更改查询：</span><span class="sxs-lookup"><span data-stu-id="f0fa4-123">The same is true when querying for net changes:</span></span>  
  
 `Msg 229, Level 14, State 5, Line 1`  
  
 `The SELECT permission was denied on the object fn_cdc_get_net_changes_...', database 'MyDB', schema 'cdc'.`  
  
 <span data-ttu-id="f0fa4-124">有关如何截获这些已知的 TVF 错误并返回有关失败的更有意义的信息的说明，请参阅“使用 TRY CATCH 枚举净更改”模板。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-124">See the template Enumerate Net Changes Using TRY CATCH for a demonstration of how to intercept these known TVF errors and return more meaningful information about the failure.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="f0fa4-125">若要在 SQL Server Management Studio 中查找变更数据捕获模板，请在“视图”  菜单上单击“模板资源管理器”  ，展开 **“SQL Server 模板”** ，然后展开 **“变更数据捕获”** 文件夹。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-125">To locate change data capture templates in SQL Server Management Studio, on the **View** menu, click **Template Explorer**, expand **SQL Server Templates** and then expand the **Change Data Capture** folder.</span></span>  
  
##  <a name="query-functions"></a><a name="Functions"></a> <span data-ttu-id="f0fa4-126">查询函数</span><span class="sxs-lookup"><span data-stu-id="f0fa4-126">Query Functions</span></span>  
 <span data-ttu-id="f0fa4-127">根据所跟踪的源表的特性以及配置其捕获实例的方式，将生成一个或两个查询更改数据的 TVF。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-127">Depending on the characteristics of the source table being tracked and the way in which its capture instance is configured, either one or two TVFs for querying change data are generated.</span></span>  
  
-   <span data-ttu-id="f0fa4-128">函数 [cdc.fn_cdc_get_all_changes_<capture_instance>](/sql/relational-databases/system-functions/cdc-fn-cdc-get-all-changes-capture-instance-transact-sql) 返回在指定间隔内发生的所有更改。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-128">The function [cdc.fn_cdc_get_all_changes_<capture_instance>](/sql/relational-databases/system-functions/cdc-fn-cdc-get-all-changes-capture-instance-transact-sql) returns all changes that occurred for the specified interval.</span></span> <span data-ttu-id="f0fa4-129">将始终生成此函数。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-129">This function is always generated.</span></span> <span data-ttu-id="f0fa4-130">返回的项将始终进行排序：先按更改的事务提交 LSN 进行排序，然后按事务内的更改顺序值进行排序。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-130">Entries are always returned sorted, first by the transaction commit LSN of the change, and then by a value that sequences the change within its transaction.</span></span> <span data-ttu-id="f0fa4-131">根据所选的行筛选器选项，在更新时将返回最终行（行筛选器选项为“all”），或者在更新时返回新值和旧值（行筛选器选项为“all update old”）。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-131">Depending on the row filter option chosen, either the final row is returned on update (row filter option "all") or both the new and old values are returned on update (row filter option "all update old"').</span></span>  
  
-   <span data-ttu-id="f0fa4-132">当启用源表时，如果将参数 @supports_net_changes 设置为 1，将生成函数 [cdc.fn_cdc_get_net_changes_<capture_instance>](/sql/relational-databases/system-functions/cdc-fn-cdc-get-net-changes-capture-instance-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-132">The function [cdc.fn_cdc_get_net_changes_<capture_instance>](/sql/relational-databases/system-functions/cdc-fn-cdc-get-net-changes-capture-instance-transact-sql) is generated when the parameter @supports_net_changes is set to 1 when the source table is enabled.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="f0fa4-133">仅当源表具有定义的主键或已使用 @index_name 参数标识了唯一索引时，才支持此选项。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-133">This option is only supported if the source table has a defined primary key or if the parameter @index_name has been used to identify a unique index.</span></span>  
  
     <span data-ttu-id="f0fa4-134">**净更改** 函数为每个修改的源表行返回一项更改。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-134">The **netchanges** function returns one change per modified source table row.</span></span> <span data-ttu-id="f0fa4-135">如果在指定间隔内为该行记录了多项更改，列值将反映该行的最终内容。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-135">If more than one change is logged for the row during the specified interval, the column values will reflect the final contents of the row.</span></span> <span data-ttu-id="f0fa4-136">要确定更新目标环境所需的正确操作，TVF 必须考虑在该间隔内对行执行的初始操作，同时还要考虑对行执行的最终操作。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-136">To correctly identify the operation that is necessary to update the target environment, the TVF must consider both the initial operation on the row during the interval and the final operation on the row.</span></span> <span data-ttu-id="f0fa4-137">如果指定了行筛选器选项“all”，`net changes` 查询将会返回插入、删除或更新（新值）操作。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-137">When the row filter option 'all' is specified, the operations that are returned by a `net changes` query will either be insert, delete, or update (new values).</span></span> <span data-ttu-id="f0fa4-138">此选项始终将更新掩码返回为 Null，这是因为计算聚合掩码会产生开销。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-138">This option always returns the update mask as null because there is a cost associated with computing an aggregate mask.</span></span> <span data-ttu-id="f0fa4-139">如果需要反映针对某行的所有更改的聚合掩码，请使用“all with mask”选项。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-139">If you require an aggregate mask that reflects all changes to a row, use the 'all with mask' option.</span></span> <span data-ttu-id="f0fa4-140">如果下游处理不需要区分插入和更新，请使用“all with merge”选项。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-140">If downstream processing does not require inserts and updates to be distinguished, use the 'all with merge' option.</span></span> <span data-ttu-id="f0fa4-141">在这种情况下，操作值只采用两个值：1 用于删除，5 用于插入或更新操作。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-141">In this case, the operation value will only take on two values: 1 for delete and 5 for an operation that could be either an insert or an update.</span></span> <span data-ttu-id="f0fa4-142">此选项可避免在确定所派生的操作应该是插入还是更新时所需的附加处理，而且还可在无需区分这些操作时提高查询性能。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-142">This option eliminates the additional processing needed to determine whether the derived operation should be an insert or an update, and can improve the performance of the query when this differentiation is not necessary.</span></span>  
  
 <span data-ttu-id="f0fa4-143">从查询函数中返回的更新掩码是一种简洁表示形式，用于标识某一更改数据行中所有更改的列。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-143">The update mask that is returned from a query function is a compact representation that identifies all columns that changed in a row of change data.</span></span> <span data-ttu-id="f0fa4-144">通常，只有捕获列的小型子集需要此信息。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-144">Typically, this information is only required for a small subset of the captured columns.</span></span> <span data-ttu-id="f0fa4-145">有多个函数可以帮助从掩码中提取信息，以使其更便于应用程序直接使用。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-145">Functions are available to assist in extracting information from the mask in a form that is more directly usable by applications.</span></span> <span data-ttu-id="f0fa4-146">函数 [sys.fn_cdc_get_column_ordinal](/sql/relational-databases/system-functions/sys-fn-cdc-get-column-ordinal-transact-sql) 可返回给定捕获实例的命名列的序号位置，而函数 [sys.fn_cdc_is_bit_set](/sql/relational-databases/system-functions/sys-fn-cdc-is-bit-set-transact-sql) 则可以基于函数调用中传递的序号返回所提供的掩码中该位的奇偶性。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-146">The function [sys.fn_cdc_get_column_ordinal](/sql/relational-databases/system-functions/sys-fn-cdc-get-column-ordinal-transact-sql) returns the ordinal position of a named column for a given capture instance, whereas the function [sys.fn_cdc_is_bit_set](/sql/relational-databases/system-functions/sys-fn-cdc-is-bit-set-transact-sql) returns the parity of the bit in the provided mask based on the ordinal that was passed in the function call.</span></span> <span data-ttu-id="f0fa4-147">在请求更改数据时，可以结合使用这两个函数从掩码中有效地提取并返回信息。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-147">Together, these two functions allow information from the update mask to be efficiently extracted and returned with the request for change data.</span></span> <span data-ttu-id="f0fa4-148">有关如何使用这些函数的说明，请参阅“使用 All With Mask 枚举净更改”模板。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-148">See the template Enumerate Net Changes Using All With Mask for a demonstration of how these functions are used.</span></span>  
  
##  <a name="query-function-scenarios"></a><a name="Scenarios"></a> <span data-ttu-id="f0fa4-149">查询函数应用场景</span><span class="sxs-lookup"><span data-stu-id="f0fa4-149">Query Function Scenarios</span></span>  
 <span data-ttu-id="f0fa4-150">以下部分介绍使用 cdc.fn_cdc_get_all_changes_ < capture_instance > 和 cdc.fn_cdc_get_net_changes_ < capture_instance > 查询函数查询变更数据捕获数据的常用应用场景。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-150">The following sections describe common scenarios for querying change data capture data by using the query functions cdc.fn_cdc_get_all_changes_<capture_instance> and cdc.fn_cdc_get_net_changes_<capture_instance>.</span></span>  
  
### <a name="querying-for-all-changes-within-the-capture-instance-validity-interval"></a><span data-ttu-id="f0fa4-151">查询捕获实例有效性间隔中的所有更改</span><span class="sxs-lookup"><span data-stu-id="f0fa4-151">Querying for All Changes Within the Capture Instance Validity Interval</span></span>  
 <span data-ttu-id="f0fa4-152">请求更改数据的最直接的方式是返回捕获实例的有效性间隔中的所有当前更改数据。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-152">The most straightforward request for change data is one that returns all of the current change data in a capture instance's validity interval.</span></span> <span data-ttu-id="f0fa4-153">若要发出此请求，请首先确定有效性间隔的 LSN 上限和下限。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-153">To make this request, first determine the lower and upper LSN boundaries of the validity interval.</span></span> <span data-ttu-id="f0fa4-154">然后，使用这些值标识传递到 cdc.fn_cdc_get_all_changes_<capture_instance> 或 cdc.fn_cdc_get_net_changes_<capture_instance> 查询函数的 @from_lsn 和 @to_lsn 参数。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-154">Then, use these values to identify the parameters @from_lsn and @to_lsn passed to the query function cdc.fn_cdc_get_all_changes_<capture_instance> or cdc.fn_cdc_get_net_changes_<capture_instance>.</span></span> <span data-ttu-id="f0fa4-155">使用 [sys.fn_cdc_get_min_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-get-min-lsn-transact-sql) 函数获取下限，使用 [sys.fn_cdc_get_max_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-get-max-lsn-transact-sql) 函数获取上限。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-155">Use the function [sys.fn_cdc_get_min_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-get-min-lsn-transact-sql) to obtain the lower bound, and [sys.fn_cdc_get_max_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-get-max-lsn-transact-sql) to obtain the upper bound.</span></span> <span data-ttu-id="f0fa4-156">有关使用 cdc.fn_cdc_get_all_changes_<capture_instance> 查询函数查询所有当前有效更改的示例代码，请参阅“枚举有效范围中的所有更改”模板。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-156">See the template Enumerate All Changes for the Valid Range for sample code to query for all current valid changes by using the query function cdc.fn_cdc_get_all_changes_<capture_instance>.</span></span> <span data-ttu-id="f0fa4-157">有关使用 cdc.fn_cdc_get_net_changes_<capture_instance> 函数的类似示例，请参阅“枚举有效范围中的净更改”模板。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-157">See the template Enumerate Net Changes for the Valid Range for a similar example of using the function cdc.fn_cdc_get_net_changes_<capture_instance>.</span></span>  
  
### <a name="querying-for-all-new-changes-since-the-last-set-of-changes"></a><span data-ttu-id="f0fa4-158">查询最近一组更改之后的所有新的更改</span><span class="sxs-lookup"><span data-stu-id="f0fa4-158">Querying for All New Changes Since the Last Set of Changes</span></span>  
 <span data-ttu-id="f0fa4-159">对于典型应用程序，查询更改数据将是一个不断进行的过程，针对上一次请求之后发生的所有更改发出定期请求。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-159">For typical applications, querying for change data will be an ongoing process, making periodic requests for all of the changes that occurred since the last request.</span></span> <span data-ttu-id="f0fa4-160">对于这种查询，可以使用 [sys.fn_cdc_increment_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-increment-lsn-transact-sql) 函数从上一次查询的上限派生当前查询的下限。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-160">For such queries, you can use the function [sys.fn_cdc_increment_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-increment-lsn-transact-sql) to derive the lower bound of the current query from the upper bound of the previous query.</span></span> <span data-ttu-id="f0fa4-161">此方法可以确保没有重复的行，这是因为查询间隔始终被视为闭区间，两个端点都包括在间隔中。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-161">This method ensures that no rows are repeated because the query interval is always treated as a closed interval where both end-points are included in the interval.</span></span> <span data-ttu-id="f0fa4-162">然后，使用 [sys.fn_cdc_get_max_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-get-max-lsn-transact-sql) 函数获取新的请求间隔的高端点。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-162">Then, use the function [sys.fn_cdc_get_max_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-get-max-lsn-transact-sql) to obtain the high end-point for the new request interval.</span></span> <span data-ttu-id="f0fa4-163">有关系统地移动查询时段以获取上一次请求之后的所有更改的示例代码，请参阅“枚举上一次请求之后的所有更改”模板。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-163">See the template Enumerate All Changes Since Previous Request for sample code to systematically move the query window to obtain all changes since the last request.</span></span>  
  
### <a name="querying-for-all-new-changes-up-until-now"></a><span data-ttu-id="f0fa4-164">查询到目前为止的所有新的更改</span><span class="sxs-lookup"><span data-stu-id="f0fa4-164">Querying for all New Changes Up Until Now</span></span>  
 <span data-ttu-id="f0fa4-165">查询函数返回的更改有一个典型约束，即只包括从上一个请求到当前日期和时间发生的更改。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-165">A typical constraint that is placed on the changes returned by a query function is to include only the changes that occurred between the previous request until the current date and time.</span></span> <span data-ttu-id="f0fa4-166">对于此查询，将 sys.fn_cdc_increment_lsn 函数应用到上一次请求中使用的 @from_lsn 值，以确定下限。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-166">For this query, apply the function sys.fn_cdc_increment_lsn to the @from_lsn value that was used in the previous request to determine the lower bound.</span></span> <span data-ttu-id="f0fa4-167">由于时间间隔的上限表示为特定时间点，必须先将它转换为 LSN 值，然后查询函数才可以使用它。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-167">Because the upper bound on the time interval is expressed as a specific point in time, it must be converted to an LSN value before it can be used by a query function.</span></span> <span data-ttu-id="f0fa4-168">在将日期时间值转换为相应的 LSN 值之前，必须确保捕获进程已经处理了指定上限之前提交的所有更改。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-168">Before the datetime value can be converted to a corresponding LSN value, you must ensure that the capture process has processed all changes that were committed through the specified upper bound.</span></span> <span data-ttu-id="f0fa4-169">为了确保所有符合要求的更改都已经传播到更改表，此操作是必需的。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-169">This is required to ensure that all the qualifying changes have been propagated to the change table.</span></span> <span data-ttu-id="f0fa4-170">执行此操作的一种方法是构造一个等待循环，该循环定期进行检查以查看任何数据库更改表的记录的当前最大提交 LSN 是否超出请求间隔所需的结束时间。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-170">One way to do this is to structure a wait loop that periodically checks to see if the current maximum commit lsn recorded for any database change table exceeds the desired end time of the request interval.</span></span>  
  
 <span data-ttu-id="f0fa4-171">当延迟循环验证捕获进程已经处理了所有相关日志条目之后，请使用 [sys.fn_cdc_map_time_to_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-map-time-to-lsn-transact-sql) 函数确定以 LSN 值表示的新的高端点。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-171">After the delay loop verifies that the capture process has already processed all the relevant log entries, use the function [sys.fn_cdc_map_time_to_lsn](/sql/relational-databases/system-functions/sys-fn-cdc-map-time-to-lsn-transact-sql) to determine the new high end-point expressed as an LSN value.</span></span> <span data-ttu-id="f0fa4-172">为了确保检索指定时间之前提交的所有条目，请调用 sys.fn_cdc_map_time_to_lsn 函数，并使用“largest less than or equal”选项。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-172">To ensure that all entries that were committed through the specified time are retrieved, call the function sys.fn_cdc_map_time_to_lsn, and use the option 'largest less than or equal'.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="f0fa4-173">在不活动期间，会向 cdc.lsn_time_mapping 表添加一个虚条目，以标记捕获进程已经处理了给定提交时间之前的更改的事实。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-173">In periods of inactivity, a dummy entry is added to the table cdc.lsn_time_mapping to mark the fact that the capture process has processed the changes up to a given commit time.</span></span> <span data-ttu-id="f0fa4-174">这样做可以防止使捕获进程看上去已经落后，而实际上只是最近没有任何要处理的更改。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-174">This prevents it from appearing that the capture process has fallen behind when there are simply no recent changes to process.</span></span>  
  
 <span data-ttu-id="f0fa4-175">“枚举到目前为止的所有更改”模板演示如何使用上一个策略查询更改数据。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-175">The template Enumerate All Changes Up Until Now demonstrates how to use the previous strategy to query for change data.</span></span>  
  
### <a name="adding-a-commit-time-to-an-all-changes-result-set"></a><span data-ttu-id="f0fa4-176">向所有更改结果集添加提交时间</span><span class="sxs-lookup"><span data-stu-id="f0fa4-176">Adding a Commit Time to an All Changes Result Set</span></span>  
 <span data-ttu-id="f0fa4-177">在 [cdc.lsn_time_mapping](/sql/relational-databases/system-tables/cdc-lsn-time-mapping-transact-sql)表中有每个事务的提交时间，以及数据库更改表中的相关条目。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-177">The commit time of each transaction with an associated entry in a database change table is available in the table [cdc.lsn_time_mapping](/sql/relational-databases/system-tables/cdc-lsn-time-mapping-transact-sql).</span></span> <span data-ttu-id="f0fa4-178">通过将针对所有更改的请求中返回的 __$start_lsn 值与 cdc.lsn_time_mapping 表条目中的 start_lsn 值相联接，可以返回 tran_end_time 以及更改数据，以将事务在源中的提交时间作为更改的时间戳。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-178">By joining the __$start_lsn value returned in a request for all changes with the start_lsn value of a cdc.lsn_time_mapping table entry, you can return the tran_end_time along with the change data to stamp the change with the commit time of the transaction at the source.</span></span> <span data-ttu-id="f0fa4-179">“将提交时间追加到所有更改结果集”模板演示如何执行此联接。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-179">The template Append Commit Time to All Changes Result Set demonstrates how to perform this join.</span></span>  
  
### <a name="joining-change-data-with-other-data-from-the-same-transaction"></a><span data-ttu-id="f0fa4-180">将更改数据与同一事务的其他数据相联接</span><span class="sxs-lookup"><span data-stu-id="f0fa4-180">Joining Change Data with Other Data from the Same Transaction</span></span>  
 <span data-ttu-id="f0fa4-181">有时，当在源中提交事务时，将更改数据与收集的有关该事务的其他信息相联接非常有用。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-181">Occasionally, it is useful to join change data with other information gathered about the transaction when it committed at the source.</span></span> <span data-ttu-id="f0fa4-182">cdc.lsn_time_mapping 表中的 tran_begin_lsn 列提供执行这种联接所需的信息。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-182">The tran_begin_lsn column in the table cdc.lsn_time_mapping provides the information needed to perform such a join.</span></span> <span data-ttu-id="f0fa4-183">当源发生更新时，必须将 [sys.dm_tran_database_transactions](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-database-transactions-transact-sql) 系统动态视图的 database_transaction_begin_lsn 的值以及要与更改数据相联接的任何其他信息一起保存。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-183">When the update of the source occurs, the value for database_transaction_begin_lsn from the system dynamic view [sys.dm_tran_database_transactions](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-database-transactions-transact-sql) must be saved along with any other information to be joined with the change data.</span></span> <span data-ttu-id="f0fa4-184">使用 fn_convertnumericlsntobinary 函数比较 database_transaction_begin_lsn 和 tran_begin_lsn 的值。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-184">Use the function fn_convertnumericlsntobinary to compare the database_transaction_begin_lsn and tran_begin_lsn values.</span></span> <span data-ttu-id="f0fa4-185">创建此函数的代码可以在“创建 fn_convertnumericlsntobinary 函数”模板中找到。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-185">The code to create this function is available in the template Create Function fn_convertnumericlsntobinary.</span></span> <span data-ttu-id="f0fa4-186">“使用给定的 tran_begin_lsn 返回所有更改”模板演示如何使联接生效。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-186">The template Return All Changes with a Given tran_begin_lsn demonstrates how to effect the join.</span></span>  
  
### <a name="querying-using-datetime-wrapper-functions"></a><span data-ttu-id="f0fa4-187">使用日期时间包装函数进行查询</span><span class="sxs-lookup"><span data-stu-id="f0fa4-187">Querying Using Datetime Wrapper Functions</span></span>  
 <span data-ttu-id="f0fa4-188">查询更改数据有一个典型应用场景，即使用由日期时间值限定的滑动窗口定期请求更改数据。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-188">A typical application scenario for querying for change data is to periodically request change data by using a sliding window bounded by datetime values.</span></span> <span data-ttu-id="f0fa4-189">对于此类使用者，变更数据捕获提供 [sys.sp_cdc_generate_wrapper_function](/sql/relational-databases/system-stored-procedures/sys-sp-cdc-generate-wrapper-function-transact-sql) 存储过程，该存储过程可生成用于创建变更数据捕获查询函数的自定义包装函数的脚本。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-189">For this class of consumers, change data capture provides the stored procedure [sys.sp_cdc_generate_wrapper_function](/sql/relational-databases/system-stored-procedures/sys-sp-cdc-generate-wrapper-function-transact-sql) that generates scripts to create custom wrapper functions for the change data capture query functions.</span></span> <span data-ttu-id="f0fa4-190">使用这些自定义包装可以将查询间隔表示为日期时间对。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-190">These custom wrappers allow the query interval to be expressed as a datetime pair.</span></span>  
  
 <span data-ttu-id="f0fa4-191">使用存储过程的调用选项，可以为调用方有权访问的所有捕获实例生成包装，或仅为指定的捕获实例生成包装。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-191">Calling options for the stored procedure allow for wrappers to be generated for all capture instances that the caller has access to, or only a specified capture instance.</span></span> <span data-ttu-id="f0fa4-192">支持的选项还包括能够指定捕获间隔的高端点应为开放还是闭合，结果集中应包括哪些可用的捕获列，以及哪些包含列应具有关联的更新标志。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-192">Supported options also include the ability to specify whether the high end-point of the capture interval should be open or closed, which of the available captured columns should be included in the result set and which of the included columns should have associated update flags.</span></span> <span data-ttu-id="f0fa4-193">该过程返回具有两个列的结果集：生成的函数名称（此名称可以从捕获实例名称派生），以及包装存储过程的 Create 语句。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-193">The procedure returns a result set with two columns: the generated function name, which is derivable from the capture instance name, and the create statement for the wrapper stored procedure.</span></span> <span data-ttu-id="f0fa4-194">始终生成包装所有更改查询的函数。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-194">The function to wrap the all changes query is always generated.</span></span> <span data-ttu-id="f0fa4-195">如果在创建捕获实例时设置了 @supports_net_changes 参数，还生成包装净更改函数的函数。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-195">If the @supports_net_changes parameter was set when the capture instance was created, the function to wrap the net changes function is also generated.</span></span>  
  
 <span data-ttu-id="f0fa4-196">应用程序设计器负责调用脚本生成存储过程，以生成包装存储过程的 Create 语句，并执行生成的创建脚本以创建函数。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-196">It is the responsibility of the application designer to call the script generation stored procedure to generate the create statements for the wrapper stored procedures, and to execute the resulting create scripts to create the functions.</span></span> <span data-ttu-id="f0fa4-197">当创建捕获实例时，此操作不会自动发生。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-197">This does not occur automatically when a capture instance is created.</span></span>  
  
 <span data-ttu-id="f0fa4-198">日期时间包装由用户所拥有，不会在调用方的默认架构中创建。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-198">Datetime wrappers are owned by the user, and not are created in the default schema of the caller.</span></span> <span data-ttu-id="f0fa4-199">生成的函数适合大多数用户，而不需要修改。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-199">The generated function is suitable without modification for most users.</span></span> <span data-ttu-id="f0fa4-200">但是，在创建函数之前，始终可以向生成的脚本应用进一步的自定义。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-200">However, further customization can always be applied to the generated script prior to creating the function.</span></span>  
  
 <span data-ttu-id="f0fa4-201">包装所有更改查询的函数的名称是 fn_all_changes_ 后面跟捕获实例名称。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-201">The name of the function to wrap the all changes query is fn_all_changes_ followed by the capture instance name.</span></span> <span data-ttu-id="f0fa4-202">净更改包装使用的前缀是 fn_net_changes_。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-202">The prefix that is used for the net changes wrapper is fn_net_changes_.</span></span> <span data-ttu-id="f0fa4-203">两个函数都有三个参数，正如它们的关联的变更数据捕获 TVF 一样。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-203">Both functions take three arguments, just as their associated change data capture TVFs do.</span></span> <span data-ttu-id="f0fa4-204">但是，包装的查询间隔由两个日期时间值限定，而不是由两个 LSN 值限定。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-204">However, the query interval for the wrappers is bounded by two datetime values instead of than by two LSN values.</span></span> <span data-ttu-id="f0fa4-205">两组函数的 @row_filter_option 参数相同。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-205">The @row_filter_option parameter for both sets of functions are the same.</span></span>  
  
 <span data-ttu-id="f0fa4-206">生成的包装函数支持以下约定，以便系统地遍历变更数据捕获时间线：前一个间隔的 @end_time 参数应用作后一个间隔的 @start_time 参数。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-206">The generated wrapper functions support the following convention for systematically walking the change data capture timeline: It is expected that the @end_time parameter of the previous interval be used as the @start_time parameter of the subsequent interval.</span></span> <span data-ttu-id="f0fa4-207">如果遵循此约定，则包装函数负责将日期时间值映射到 LSN 值，并确保不会丢失数据或出现重复数据。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-207">The wrapper function takes care of mapping the datetime values to LSN values and ensuring that no data is lost or repeated if this convention is followed.</span></span>  
  
 <span data-ttu-id="f0fa4-208">可以生成包装以支持指定的查询时段上的闭合上限或开放上限。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-208">The wrappers can be generated to support either a closed upper bound or an open upper bound on the specified query window.</span></span> <span data-ttu-id="f0fa4-209">也就是说，调用方可以指定提交时间等于提取间隔的上限的条目是否要包括在该间隔中。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-209">That is, the caller can specify whether entries having a commit time equal to the upper bound of the extraction interval are to be included within the interval.</span></span> <span data-ttu-id="f0fa4-210">默认情况下，包括上限。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-210">By default, the upper bound is included.</span></span>  
  
 <span data-ttu-id="f0fa4-211">如果为 @from_lsn 值或 @to_lsn 值提供了 Null 值，生成的查询 TVF 将失败，而日期时间包装函数则使用 Null 以允许日期时间包装返回所有当前更改。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-211">While the generated query TVFs fail if supplied a null value for either the @from_lsn value or the @to_lsn value, the datetime wrapper functions use null to allow the datetime wrappers to return all current changes.</span></span> <span data-ttu-id="f0fa4-212">也就是说，如果将 Null 作为查询时段的低端点传递到日期时间包装，则将在应用到查询 TVF 的基础 SELECT 语句中使用捕获实例有效性间隔的低端点。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-212">That is, if null is passed as the low end-point of the query window to the datetime wrapper, the low end point of the capture instance validity interval is used in the underlying SELECT statement that is applied to the query TVF.</span></span> <span data-ttu-id="f0fa4-213">同样，如果将 Null 作为查询时段的高端点传递，则当从查询 TVF 进行选择时将使用捕获实例有效性间隔的高端点。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-213">Similarly, if null is passed as the high end-point of the query window, the high end-point of the capture instance validity interval is used when selecting from the query TVF.</span></span>  
  
 <span data-ttu-id="f0fa4-214">包装函数返回的结果集包括所有请求的列后面跟一个操作列，该操作列重新编码为一个或两个字符以标识与该行关联的操作。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-214">The result set returned by a wrapper function includes all the requested columns followed by an operation column, recoded as one or two characters to identify the operation that is associated with the row.</span></span> <span data-ttu-id="f0fa4-215">如果已请求更新标志，则它们将作为位列显示在操作代码之后，并以在 @update_flag_list 参数中指定的顺序显示。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-215">If update flags have been requested, they appear as bit columns after the operation code, in the order specified in the @update_flag_list parameter.</span></span> <span data-ttu-id="f0fa4-216">有关自定义生成的日期时间包装的调用选项的信息，请参阅 [sys.sp_cdc_generate_wrapper_function (Transact-SQL)](/sql/relational-databases/system-stored-procedures/sys-sp-cdc-generate-wrapper-function-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-216">For information about the calling options for customizing the generated datetime wrappers, see [sys.sp_cdc_generate_wrapper_function &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sys-sp-cdc-generate-wrapper-function-transact-sql).</span></span>  
  
 <span data-ttu-id="f0fa4-217">“使用更新标志实例化包装 TVF”模板介绍如何自定义生成的包装函数以将指定列的更新标志追加到净更改查询返回的结果集。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-217">The template Instantiate a Wrapper TVF With Update Flag shows how to customize a generated wrapper function to append an update flag for a specified column to the result set returned by a net changes query.</span></span> <span data-ttu-id="f0fa4-218">“实例化架构的 CDC 包装 TVF”模板介绍如何将为给定数据库架构中源表创建的所有捕获实例的查询 TVF 的日期时间包装实例化。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-218">The template Instantiate CDC Wrapper TVFs for a Schema shows how to instantiate the Datetime Wrappers for the Query TVFs for all of the capture instances created for the source tables in a given database schema.</span></span>  
  
 <span data-ttu-id="f0fa4-219">有关使用日期时间包装查询更改数据的示例，请参阅“使用包装和更新标志获取净更改”模板。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-219">For an example that uses a datetime wrapper to query for change data, see the template Get Net Changes Using Wrapper With Update Flags.</span></span> <span data-ttu-id="f0fa4-220">此模板演示当包装配置为返回更新标志时，如何使用包装函数查询净更改。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-220">This template demonstrates how to query for net changes with a wrapper function when the wrapper is configured to return update flags.</span></span> <span data-ttu-id="f0fa4-221">请注意，基础查询函数需要行筛选器选项“all with mask”以在更新时返回非 Null 更新掩码。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-221">Note that the row filter option 'all with mask' is required for the underlying query function to return a non-null update mask on update.</span></span> <span data-ttu-id="f0fa4-222">为日期时间间隔的上限和下限都传递 Null 值，以便当执行基于 LSN 的基础查询时，指示该函数使用捕获实例的有效性间隔的低端点和高端点。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-222">Null values are passed for both the lower and upper datetime interval boundaries to signal the function to use the low end point and the high end point of the validity interval for the capture instance when performing the underlying LSN based query.</span></span> <span data-ttu-id="f0fa4-223">对于在捕获实例的有效范围内源行发生的每一次修改，查询返回一行。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-223">The query returns one row for each modification to a source row that occurred within the valid range for the capture instance.</span></span>  
  
### <a name="using-the-datetime-wrapper-functions-to-transition-between-capture-instances"></a><span data-ttu-id="f0fa4-224">使用日期时间包装函数在捕获实例之间转换</span><span class="sxs-lookup"><span data-stu-id="f0fa4-224">Using the Datetime Wrapper Functions to Transition Between Capture Instances</span></span>  
 <span data-ttu-id="f0fa4-225">对于单个被跟踪的源表，变更数据捕获支持最多两个捕获实例。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-225">Change data capture supports up to two capture instances for a single tracked source table.</span></span> <span data-ttu-id="f0fa4-226">此功能的主要用途是当源表的数据定义语言 (DDL) 更改扩展了可进行跟踪的列的集合时，在多个捕获实例之间实现转换。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-226">The principal use of this capability is to accommodate a transition between multiple capture instances when data definition language (DDL) changes to the source table expand the set of available columns for tracking.</span></span> <span data-ttu-id="f0fa4-227">当转换到新的捕获实例时，为了保护较高应用级中基础查询函数的名称不被更改，一个方法是使用包装函数包装基础调用。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-227">When transitioning to a new capture instance, one way to protect higher application levels from changes in the names of the underlying query functions is to use a wrapper function to wrap the underlying call.</span></span> <span data-ttu-id="f0fa4-228">然后，确保包装函数的名称保持不变。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-228">Then, ensure that the name of the wrapper function remains the same.</span></span> <span data-ttu-id="f0fa4-229">当发生切换时，旧包装函数可能会被删除，并创建一个同名的引用新查询函数的新包装函数。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-229">When the switch is to occur, the old wrapper function can be dropped, and a new one with the same name created that references the new query functions.</span></span> <span data-ttu-id="f0fa4-230">通过首先修改生成的脚本以创建同名的包装函数，可以切换到新捕获实例，而不影响较高应用层。</span><span class="sxs-lookup"><span data-stu-id="f0fa4-230">By first modifying the generated script to create a wrapper function of the same name, you can make the switch to a new capture instance without affecting higher application layers.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f0fa4-231">另请参阅</span><span class="sxs-lookup"><span data-stu-id="f0fa4-231">See Also</span></span>  
 <span data-ttu-id="f0fa4-232">[跟踪数据更改 (SQL Server)](../track-changes/track-data-changes-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="f0fa4-232">[Track Data Changes &#40;SQL Server&#41;](../track-changes/track-data-changes-sql-server.md) </span></span>  
 <span data-ttu-id="f0fa4-233">[关于变更数据捕获 (SQL Server)](../track-changes/about-change-data-capture-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="f0fa4-233">[About Change Data Capture &#40;SQL Server&#41;](../track-changes/about-change-data-capture-sql-server.md) </span></span>  
 <span data-ttu-id="f0fa4-234">[启用和禁用变更数据捕获 (SQL Server)](../track-changes/enable-and-disable-change-data-capture-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="f0fa4-234">[Enable and Disable Change Data Capture &#40;SQL Server&#41;](../track-changes/enable-and-disable-change-data-capture-sql-server.md) </span></span>  
 [<span data-ttu-id="f0fa4-235">管理和监视变更数据捕获 (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="f0fa4-235">Administer and Monitor Change Data Capture &#40;SQL Server&#41;</span></span>](../track-changes/administer-and-monitor-change-data-capture-sql-server.md)  
  
  
