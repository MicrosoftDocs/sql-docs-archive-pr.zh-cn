---
title: XML 数据类型和列 (SQL Server) | Microsoft Docs
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
ms.assetid: 00db8f21-7d4b-4347-ae43-3a7c314d2fa1
author: rothja
ms.author: jroth
ms.openlocfilehash: 575f8b8fc640ea5ff671a6b0cef4208e7447898f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87693662"
---
# <a name="xml-data-type-and-columns-sql-server"></a><span data-ttu-id="a1734-102">XML 数据类型和列 (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="a1734-102">XML Data Type and Columns (SQL Server)</span></span>
  <span data-ttu-id="a1734-103">本主题讨论中数据类型的优点和局限性 `xml` [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ，并帮助您选择如何存储 XML 数据。</span><span class="sxs-lookup"><span data-stu-id="a1734-103">This topic discusses the advantages and the limitations of the `xml` data type in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], and helps you to choose how to store XML data.</span></span>  
  
## <a name="relational-or-xml-data-model"></a><span data-ttu-id="a1734-104">关系或 XML 数据模型</span><span class="sxs-lookup"><span data-stu-id="a1734-104">Relational or XML Data Model</span></span>  
 <span data-ttu-id="a1734-105">如果您的数据已通过已知架构高度结构化，则关系模型可能最适合用于数据存储。</span><span class="sxs-lookup"><span data-stu-id="a1734-105">If your data is highly structured with known schema, the relational model is likely to work best for data storage.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="a1734-106">提供了您所需的必要功能和工具。</span><span class="sxs-lookup"><span data-stu-id="a1734-106">provides the required functionality and tools you may need.</span></span> <span data-ttu-id="a1734-107">另一方面，如果结构是半结构化或非结构化的或者未知的，则必须考虑对这类数据进行建模。</span><span class="sxs-lookup"><span data-stu-id="a1734-107">On the other hand, if the structure is semi-structured or unstructured, or unknown, you have to give consideration to modeling such data.</span></span>  
  
 <span data-ttu-id="a1734-108">如果您需要一个与平台无关的模型，以便通过使用结构和语义标记来确保数据的可移植性，则 XML 是一个不错的选择。</span><span class="sxs-lookup"><span data-stu-id="a1734-108">XML is a good choice if you want a platform-independent model in order to ensure portability of the data by using structural and semantic markup.</span></span> <span data-ttu-id="a1734-109">此外，下列情况下，适于做此选择：</span><span class="sxs-lookup"><span data-stu-id="a1734-109">Additionally, it is an appropriate option if some of the following properties are satisfied:</span></span>  
  
-   <span data-ttu-id="a1734-110">您的数据为稀疏数据，或您不了解数据的结构，或数据结构将来可能会有重大变化。</span><span class="sxs-lookup"><span data-stu-id="a1734-110">Your data is sparse or you do not know the structure of the data, or the structure of your data may change significantly in the future.</span></span>  
  
-   <span data-ttu-id="a1734-111">您的数据体现的是包容层次结构而不是在实体间的引用，并且可能是递归数据。</span><span class="sxs-lookup"><span data-stu-id="a1734-111">Your data represents containment hierarchy, instead of references among entities, and may be recursive.</span></span>  
  
-   <span data-ttu-id="a1734-112">您的数据本身具有顺序性。</span><span class="sxs-lookup"><span data-stu-id="a1734-112">Order is inherent in your data.</span></span>  
  
-   <span data-ttu-id="a1734-113">您希望基于数据的结构查询数据或更新部分数据。</span><span class="sxs-lookup"><span data-stu-id="a1734-113">You want to query into the data or update parts of it, based on its structure.</span></span>  
  
 <span data-ttu-id="a1734-114">如果上述条件均不满足，则应使用关系数据模型。</span><span class="sxs-lookup"><span data-stu-id="a1734-114">If none of these conditions is met, you should use the relational data model.</span></span> <span data-ttu-id="a1734-115">例如，如果数据的格式为 XML，但是应用程序只使用数据库存储和检索数据，则必须使用 `[n]varchar(max)` 列。</span><span class="sxs-lookup"><span data-stu-id="a1734-115">For example, if your data is in XML format but your application just uses the database to store and retrieve the data, an `[n]varchar(max)` column is all you require.</span></span> <span data-ttu-id="a1734-116">将数据存储在 XML 列中还有其他好处，</span><span class="sxs-lookup"><span data-stu-id="a1734-116">Storing the data in an XML column has additional benefits.</span></span> <span data-ttu-id="a1734-117">包括让引擎确定数据格式是否正确或有效，以及支持对 XML 数据进行精细查询和更新。</span><span class="sxs-lookup"><span data-stu-id="a1734-117">This includes having the engine determine that the data is well formed or valid, and also includes support for fine-grained query and updates into the XML data.</span></span>  
  
## <a name="reasons-for-storing-xml-data-in-sql-server"></a><span data-ttu-id="a1734-118">在 SQL Server 中存储 XML 数据的理由</span><span class="sxs-lookup"><span data-stu-id="a1734-118">Reasons for Storing XML Data in SQL Server</span></span>  
 <span data-ttu-id="a1734-119">下面是一些使用 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 中的本机 XML 功能而不是在文件系统中管理 XML 数据的理由：</span><span class="sxs-lookup"><span data-stu-id="a1734-119">Following are some of the reasons to use native XML features in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] instead of managing your XML data in the file system:</span></span>  
  
-   <span data-ttu-id="a1734-120">您希望以一种高效的事务处理方式来共享、查询和修改 XML 数据。</span><span class="sxs-lookup"><span data-stu-id="a1734-120">You want to share, query, and modify your XML data in an efficient and transacted way.</span></span> <span data-ttu-id="a1734-121">精细的数据访问对于您的应用程序而言很重要。</span><span class="sxs-lookup"><span data-stu-id="a1734-121">Fine-grained data access is important to your application.</span></span> <span data-ttu-id="a1734-122">例如，您可能需要提取 XML 文档中的某些部分，或者您可能需要插入新的部分而不是替换整个文档。</span><span class="sxs-lookup"><span data-stu-id="a1734-122">For example, you may want to extract some of the sections within an XML document, or you may want to insert a new section without replacing your whole document.</span></span>  
  
-   <span data-ttu-id="a1734-123">您有关系数据和 XML 数据，希望在应用程序中进行关系数据和 XML 数据之间的互操作。</span><span class="sxs-lookup"><span data-stu-id="a1734-123">You have relational data and XML data and you want interoperability between both relational and XML data within your application.</span></span>  
  
-   <span data-ttu-id="a1734-124">您需要语言支持，以便对于跨域应用程序可以进行查询和数据修改。</span><span class="sxs-lookup"><span data-stu-id="a1734-124">You need language support for query and data modification for cross-domain applications.</span></span>  
  
-   <span data-ttu-id="a1734-125">您希望服务器能够保证数据格式正确，并能够视情况根据 XML 架构来验证您的数据。</span><span class="sxs-lookup"><span data-stu-id="a1734-125">You want the server to guarantee that the data is well formed and also optionally validate your data according to XML schemas.</span></span>  
  
-   <span data-ttu-id="a1734-126">您希望对 XML 数据创建索引以实现高效的查询处理和良好的可伸缩性，并使用一流查询优化器。</span><span class="sxs-lookup"><span data-stu-id="a1734-126">You want indexing of XML data for efficient query processing and good scalability, and the use of a first-rate query optimizer.</span></span>  
  
-   <span data-ttu-id="a1734-127">您希望对 XML 数据进行 SOAP、ADO.NET 和 OLE DB 访问。</span><span class="sxs-lookup"><span data-stu-id="a1734-127">You want SOAP, ADO.NET, and OLE DB access to XML data.</span></span>  
  
-   <span data-ttu-id="a1734-128">您希望使用数据库服务器的管理功能来管理 XML 数据。</span><span class="sxs-lookup"><span data-stu-id="a1734-128">You want to use administrative functionality of the database server for managing your XML data.</span></span> <span data-ttu-id="a1734-129">例如，这可能是备份、恢复和复制。</span><span class="sxs-lookup"><span data-stu-id="a1734-129">For example, this would be backup, recovery, and replication.</span></span>  
  
 <span data-ttu-id="a1734-130">如果未满足这些条件中的任意一个，则最好是将数据存储为非 XML 数据，这是一种大型对象类型（如 `[n]varchar(max)` 或 `varbinary(max)`）。</span><span class="sxs-lookup"><span data-stu-id="a1734-130">If none of these conditions is satisfied, it may be better to store your data as a non-XML, large object type, such as `[n]varchar(max)` or `varbinary(max)`.</span></span>  
  
## <a name="xml-storage-options"></a><span data-ttu-id="a1734-131">XML 存储选项</span><span class="sxs-lookup"><span data-stu-id="a1734-131">XML Storage Options</span></span>  
 <span data-ttu-id="a1734-132">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 中的 XML 存储选项包括：</span><span class="sxs-lookup"><span data-stu-id="a1734-132">The storage options for XML in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] include the following:</span></span>  
  
-   <span data-ttu-id="a1734-133">本机存储，数据类型为 `xml`</span><span class="sxs-lookup"><span data-stu-id="a1734-133">Native storage as `xml` data type</span></span>  
  
     <span data-ttu-id="a1734-134">数据以保留数据的 XML 内容的内部表示形式进行存储，</span><span class="sxs-lookup"><span data-stu-id="a1734-134">The data is stored in an internal representation that preserves the XML content of the data.</span></span> <span data-ttu-id="a1734-135">这种内部表示形式包括包容层次结构、文档顺序、元素和属性值的相关信息。</span><span class="sxs-lookup"><span data-stu-id="a1734-135">This internal representation includes information about the containment hierarchy, document order, and element and attribute values.</span></span> <span data-ttu-id="a1734-136">具体来说，就是保留 XML 数据的 InfoSet 内容。</span><span class="sxs-lookup"><span data-stu-id="a1734-136">Specifically, the InfoSet content of the XML data is preserved.</span></span> <span data-ttu-id="a1734-137">有关信息集的详细信息，请访问 [http://www.w3.org/TR/xml-infoset](https://go.microsoft.com/fwlink/?LinkId=48843)。</span><span class="sxs-lookup"><span data-stu-id="a1734-137">For more information about InfoSet, visit [http://www.w3.org/TR/xml-infoset](https://go.microsoft.com/fwlink/?LinkId=48843).</span></span> <span data-ttu-id="a1734-138">InfoSet 内容并不是文本 XML 的精确副本，因为其中未保留下列信息：无关紧要的空格、属性顺序、命名空间前缀和 XML 声明。</span><span class="sxs-lookup"><span data-stu-id="a1734-138">The InfoSet content may not be an identical copy of the text XML, because the following information is not retained: insignificant white spaces, order of attributes, namespace prefixes, and XML declaration.</span></span>  
  
     <span data-ttu-id="a1734-139">对于类型化的 `xml` 数据类型、 `xml` 绑定到 XML 架构的数据类型， () PSVI 的后架构验证信息集会将类型信息添加到信息集并在内部表示形式进行编码。</span><span class="sxs-lookup"><span data-stu-id="a1734-139">For typed `xml` data type, an `xml` data type bound to XML schemas, the post-schema validation InfoSet (PSVI) adds type information to the InfoSet and is encoded in the internal representation.</span></span> <span data-ttu-id="a1734-140">这会显著提高分析速度。</span><span class="sxs-lookup"><span data-stu-id="a1734-140">This improves parsing speed significantly.</span></span> <span data-ttu-id="a1734-141">有关详细信息，请参阅位于 [http://www.w3.org/TR/xmlschema-1](https://go.microsoft.com/fwlink/?LinkId=48881) 和 [http://www.w3.org/TR/xmlschema-2](https://go.microsoft.com/fwlink/?LinkId=4871) 的 W3C XML 架构规范。</span><span class="sxs-lookup"><span data-stu-id="a1734-141">For more information, see the W3C XML Schema specifications at [http://www.w3.org/TR/xmlschema-1](https://go.microsoft.com/fwlink/?LinkId=48881) and [http://www.w3.org/TR/xmlschema-2](https://go.microsoft.com/fwlink/?LinkId=4871).</span></span>  
  
-   <span data-ttu-id="a1734-142">在 XML 和关系存储之间映射</span><span class="sxs-lookup"><span data-stu-id="a1734-142">Mapping between XML and relational storage</span></span>  
  
     <span data-ttu-id="a1734-143">通过使用带批注的架构 (AXSD)，将 XML 分解到一个或多个表中的列。</span><span class="sxs-lookup"><span data-stu-id="a1734-143">By using an annotated schema (AXSD), the XML is decomposed into columns in one or more tables.</span></span> <span data-ttu-id="a1734-144">这可保留在关系级别上的数据保真度。</span><span class="sxs-lookup"><span data-stu-id="a1734-144">This preserves fidelity of the data at the relational level.</span></span> <span data-ttu-id="a1734-145">因此，尽管忽略了元素间的顺序，但仍保留了层次结构。</span><span class="sxs-lookup"><span data-stu-id="a1734-145">As a result, the hierarchical structure is preserved although order among elements is ignored.</span></span> <span data-ttu-id="a1734-146">架构不能是递归的。</span><span class="sxs-lookup"><span data-stu-id="a1734-146">The schema cannot be recursive.</span></span>  
  
-   <span data-ttu-id="a1734-147">大型对象存储（`[n]varchar(max)` 和 `varbinary(max)`）</span><span class="sxs-lookup"><span data-stu-id="a1734-147">Large object storage, `[n]varchar(max)` and `varbinary(max)`</span></span>  
  
     <span data-ttu-id="a1734-148">存储数据的精确副本。</span><span class="sxs-lookup"><span data-stu-id="a1734-148">An identical copy of the data is stored.</span></span> <span data-ttu-id="a1734-149">这对于特殊用途的应用（如法律文档）很有用。</span><span class="sxs-lookup"><span data-stu-id="a1734-149">This is useful for special-purpose applications such as legal documents.</span></span> <span data-ttu-id="a1734-150">大多数应用不需要完全相同的副本，且 XML 内容（InfoSet 保真度）即可满足需要。</span><span class="sxs-lookup"><span data-stu-id="a1734-150">Most applications do not require an exact copy and are satisfied with the XML content (InfoSet fidelity).</span></span>  
  
 <span data-ttu-id="a1734-151">通常，您必须结合使用这些方法。</span><span class="sxs-lookup"><span data-stu-id="a1734-151">Generally, you may have to use a combination of these approaches.</span></span> <span data-ttu-id="a1734-152">例如，您可能想要在 `xml` 数据类型列中存储 XML 数据，并将属性从此列提升到关系列。</span><span class="sxs-lookup"><span data-stu-id="a1734-152">For example, you may want to store your XML data in an `xml` data type column and promote properties from it into relational columns.</span></span> <span data-ttu-id="a1734-153">或者，您可能想要使用映射技术将非递归部分存储在非 XML 列中，并且仅将递归部分存储在 `xml` 数据类型列中。</span><span class="sxs-lookup"><span data-stu-id="a1734-153">Or, you may want to use mapping technology to store nonrecursive parts in non-XML columns and only the recursive parts in `xml` data type columns.</span></span>  
  
### <a name="choice-of-xml-technology"></a><span data-ttu-id="a1734-154">XML 技术的选择</span><span class="sxs-lookup"><span data-stu-id="a1734-154">Choice of XML Technology</span></span>  
 <span data-ttu-id="a1734-155">XML 技术（本机 XML 与 XML 视图）的选择通常取决于下列因素：</span><span class="sxs-lookup"><span data-stu-id="a1734-155">The choice of XML technology, native XML versus XML view, generally depends upon the following factors:</span></span>  
  
-   <span data-ttu-id="a1734-156">存储选项</span><span class="sxs-lookup"><span data-stu-id="a1734-156">Storage options</span></span>  
  
     <span data-ttu-id="a1734-157">您的 XML 数据可能更适于大型对象存储（例如，产品手册），或更适于存储在关系列中（例如，转换为 XML 的行项）。</span><span class="sxs-lookup"><span data-stu-id="a1734-157">Your XML data may be more appropriate for large object storage (for example, a product manual), or more amenable to storage in relational columns (for example, a line item converted to XML).</span></span> <span data-ttu-id="a1734-158">每个存储选项都在不同程度上保留文档保真度。</span><span class="sxs-lookup"><span data-stu-id="a1734-158">Each storage option preserves document fidelity to a different extent.</span></span>  
  
-   <span data-ttu-id="a1734-159">查询功能</span><span class="sxs-lookup"><span data-stu-id="a1734-159">Query capabilities</span></span>  
  
     <span data-ttu-id="a1734-160">您可能会发现，基于查询的特性和对 XML 数据进行查询的程度，某一个存储选项比其他选项更合适。</span><span class="sxs-lookup"><span data-stu-id="a1734-160">You may find one storage option more appropriate than another, based on the nature of your queries and on the extent to which you query your XML data.</span></span> <span data-ttu-id="a1734-161">在两个存储选项中，对 XML 数据的精细查询（例如，XML 节点上的谓词评估）得到不同程度的支持。</span><span class="sxs-lookup"><span data-stu-id="a1734-161">Fine-grained query of your XML data, for example, predicate evaluation on XML nodes, is supported to varying degrees in the two storage options.</span></span>  
  
-   <span data-ttu-id="a1734-162">对 XML 数据创建索引</span><span class="sxs-lookup"><span data-stu-id="a1734-162">Indexing XML data</span></span>  
  
     <span data-ttu-id="a1734-163">您可能希望对 XML 数据创建索引以提高 XML 查询的性能。</span><span class="sxs-lookup"><span data-stu-id="a1734-163">You may want to index the XML data to speed up XML query performance.</span></span> <span data-ttu-id="a1734-164">索引选项随存储选项的不同而不同，您必须做出适当的选择才能优化工作负荷。</span><span class="sxs-lookup"><span data-stu-id="a1734-164">Indexing options vary with the storage options; you have to make the appropriate choice to optimize your workload.</span></span>  
  
-   <span data-ttu-id="a1734-165">数据修改功能</span><span class="sxs-lookup"><span data-stu-id="a1734-165">Data modification capabilities</span></span>  
  
     <span data-ttu-id="a1734-166">某些工作负荷涉及对 XML 数据进行精细修改。</span><span class="sxs-lookup"><span data-stu-id="a1734-166">Some workloads involve fine-grained modification of XML data.</span></span> <span data-ttu-id="a1734-167">例如，在文档中添加新的部分，而其他工作负荷（如 Web 内容）则不涉及。</span><span class="sxs-lookup"><span data-stu-id="a1734-167">For example, this can include adding a new section within a document, while other workloads, such as Web content, do not.</span></span> <span data-ttu-id="a1734-168">对于您的应用程序来说，数据修改语言支持可能很重要。</span><span class="sxs-lookup"><span data-stu-id="a1734-168">Data modification language support may be important for your application.</span></span>  
  
-   <span data-ttu-id="a1734-169">架构支持</span><span class="sxs-lookup"><span data-stu-id="a1734-169">Schema support</span></span>  
  
     <span data-ttu-id="a1734-170">您的 XML 数据可通过架构进行说明，该架构可能是 XML 架构文档，也可能不是。</span><span class="sxs-lookup"><span data-stu-id="a1734-170">Your XML data may be described by a schema that may or may not be an XML schema document.</span></span> <span data-ttu-id="a1734-171">对绑定到架构的 XML 的支持取决于 XML 技术。</span><span class="sxs-lookup"><span data-stu-id="a1734-171">The support for schema-bound XML depends upon the XML technology.</span></span>  
  
 <span data-ttu-id="a1734-172">此外，不同的选择具有不同的性能特征。</span><span class="sxs-lookup"><span data-stu-id="a1734-172">Different choices also have different performance characteristics.</span></span>  
  
### <a name="native-xml-storage"></a><span data-ttu-id="a1734-173">本机 XML 存储</span><span class="sxs-lookup"><span data-stu-id="a1734-173">Native XML Storage</span></span>  
 <span data-ttu-id="a1734-174">您可以将 XML 数据存储在服务器中的 `xml` 数据类型列中。</span><span class="sxs-lookup"><span data-stu-id="a1734-174">You can store your XML data in an `xml` data type column at the server.</span></span> <span data-ttu-id="a1734-175">下列情况下，适于做此选择：</span><span class="sxs-lookup"><span data-stu-id="a1734-175">This is an appropriate choice if the following applies:</span></span>  
  
-   <span data-ttu-id="a1734-176">您希望使用一种简单的方法将 XML 数据存储在服务器上，同时保留文档顺序和文档结构。</span><span class="sxs-lookup"><span data-stu-id="a1734-176">You want a straightforward way to store your XML data at the server and, at the same time, preserve document order and document structure.</span></span>  
  
-   <span data-ttu-id="a1734-177">您可能有对应于您的 XML 数据的架构，也可能没有。</span><span class="sxs-lookup"><span data-stu-id="a1734-177">You may or may not have a schema for your XML data.</span></span>  
  
-   <span data-ttu-id="a1734-178">您希望查询和修改 XML 数据。</span><span class="sxs-lookup"><span data-stu-id="a1734-178">You want to query and modify your XML data.</span></span>  
  
-   <span data-ttu-id="a1734-179">您希望对 XML 数据创建索引，以提高查询处理的速度。</span><span class="sxs-lookup"><span data-stu-id="a1734-179">You want to index the XML data for faster query processing.</span></span>  
  
-   <span data-ttu-id="a1734-180">您的应用程序需要系统目录视图以管理您的 XML 数据和 XML 架构。</span><span class="sxs-lookup"><span data-stu-id="a1734-180">Your application needs system catalog views to administer your XML data and XML schemas.</span></span>  
  
 <span data-ttu-id="a1734-181">如果您的 XML 文档具有多种结构，或您的 XML 文档符合不同的或复杂的架构，而这些架构很难映射到关系结构，本机 XML 存储很有用。</span><span class="sxs-lookup"><span data-stu-id="a1734-181">Native XML storage is useful when you have XML documents that have a range of structures, or you have XML documents that conform to different or complex schemas that are too hard to map to relational structures.</span></span>  
  
#### <a name="example-modeling-xml-data-using-the-xml-data-type"></a><span data-ttu-id="a1734-182">示例：使用 XML 数据类型对 XML 数据进行建模</span><span class="sxs-lookup"><span data-stu-id="a1734-182">Example: Modeling XML Data Using the xml Data Type</span></span>  
 <span data-ttu-id="a1734-183">例如有一个 XML 格式的产品手册，其中每个主题对应单独的一章，而每章中又包含多节。</span><span class="sxs-lookup"><span data-stu-id="a1734-183">Consider a product manual in XML format that is made up of a separate chapter for each topic and that has multiple sections within each chapter.</span></span> <span data-ttu-id="a1734-184">一节可以包含多个小节。</span><span class="sxs-lookup"><span data-stu-id="a1734-184">A section can contain subsections.</span></span> <span data-ttu-id="a1734-185">因此，\<section> 是一个递归元素。</span><span class="sxs-lookup"><span data-stu-id="a1734-185">As a result, \<section> is a recursive element.</span></span> <span data-ttu-id="a1734-186">产品手册包含大量混合内容、关系图和技术材料；数据是半结构化的。</span><span class="sxs-lookup"><span data-stu-id="a1734-186">Product manuals contain a large amount of mixed content, diagrams, and technical material; the data is semi-structured.</span></span> <span data-ttu-id="a1734-187">用户可能希望对感兴趣的主题执行上下文搜索，例如，在有关“索引”的章中搜索有关“聚集索引”的节，并查询技术数量。</span><span class="sxs-lookup"><span data-stu-id="a1734-187">Users may want to perform a contextual search for topics of interest such as searching for the section on "clustered index" within the chapter on "indexing", and query technical quantities.</span></span>  
  
 <span data-ttu-id="a1734-188">适合 XML 文档的存储模型为 `xml` 数据类型列。</span><span class="sxs-lookup"><span data-stu-id="a1734-188">An appropriate storage model for your XML documents is an `xml` data type column.</span></span> <span data-ttu-id="a1734-189">这可保留 XML 数据的 InfoSet 内容。</span><span class="sxs-lookup"><span data-stu-id="a1734-189">This preserves the InfoSet content of your XML data.</span></span> <span data-ttu-id="a1734-190">对 XML 列创建索引有利于提高查询性能。</span><span class="sxs-lookup"><span data-stu-id="a1734-190">Indexing the XML column benefits query performance.</span></span>  
  
#### <a name="example-retaining-exact-copies-of-xml-data"></a><span data-ttu-id="a1734-191">示例：保留 XML 数据的精确副本</span><span class="sxs-lookup"><span data-stu-id="a1734-191">Example: Retaining Exact Copies of XML Data</span></span>  
 <span data-ttu-id="a1734-192">为了进行说明，假定政府条例要求您保留 XML 文档的精确文本副本。</span><span class="sxs-lookup"><span data-stu-id="a1734-192">For illustration, assume that government regulations require you to retain exact textual copies of your XML documents.</span></span> <span data-ttu-id="a1734-193">例如，这些文档可能为签署的文档、法律文档或股票交易单。</span><span class="sxs-lookup"><span data-stu-id="a1734-193">For example, these could include signed documents, legal documents, or stock transaction orders.</span></span> <span data-ttu-id="a1734-194">您可能需要将文档存储在 `[n]varchar(max)` 列中。</span><span class="sxs-lookup"><span data-stu-id="a1734-194">You may want to store your documents in a `[n]varchar(max)` column.</span></span>  
  
 <span data-ttu-id="a1734-195">对于查询，可以在运行时将数据转换为 `xml` 数据类型并针对此数据执行 Xquery。</span><span class="sxs-lookup"><span data-stu-id="a1734-195">For querying, convert the data to `xml` data type at run time and execute Xquery on it.</span></span> <span data-ttu-id="a1734-196">运行时转换开销可能很高，尤其是在文档较大的情况下更是如此。</span><span class="sxs-lookup"><span data-stu-id="a1734-196">The run-time conversion may be costly, especially when the document is large.</span></span> <span data-ttu-id="a1734-197">如果要频繁查询，则可以另外将文档存储在 `xml` 数据类型列中，并在从 `[n]varchar(max)` 列返回精确的文档副本时对文档创建索引。</span><span class="sxs-lookup"><span data-stu-id="a1734-197">If you query frequently, you can redundantly store the documents in an `xml` data type column and index it while you return exact document copies from the `[n]varchar(max)` column.</span></span>  
  
 <span data-ttu-id="a1734-198">XML 列可能为基于 `[n]varchar(max)` 列的计算列。</span><span class="sxs-lookup"><span data-stu-id="a1734-198">The XML column may be a computed column, based on the `[n]varchar(max)` column.</span></span> <span data-ttu-id="a1734-199">但是，不能对计算出的 XML 列创建 XML 索引，也不能对或列生成 XML 索引 `[n]varchar(max)` `varbinary(max)` 。</span><span class="sxs-lookup"><span data-stu-id="a1734-199">However, you cannot create an XML index on a computed, XML column, nor can an XML index be built on `[n]varchar(max)` or `varbinary(max)` columns.</span></span>  
  
### <a name="xml-view-technology"></a><span data-ttu-id="a1734-200">XML 视图技术</span><span class="sxs-lookup"><span data-stu-id="a1734-200">XML View Technology</span></span>  
 <span data-ttu-id="a1734-201">通过定义 XML 架构和数据库中的表之间的映射，可以创建持久性数据的“XML 视图”。</span><span class="sxs-lookup"><span data-stu-id="a1734-201">By defining a mapping between your XML schemas and the tables in a database, you create an "XML view" of your persistent data.</span></span> <span data-ttu-id="a1734-202">通过 XML 视图，可使用 XML 大容量加载来填充基础表。</span><span class="sxs-lookup"><span data-stu-id="a1734-202">XML bulk load can be used to populate the underlying tables by using the XML view.</span></span> <span data-ttu-id="a1734-203">您可以使用 XPath 1.0 版来查询 XML 视图；这种查询将被转换为针对表的 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="a1734-203">You can query the XML view by using XPath version 1.0; the query is translated to SQL queries on the tables.</span></span> <span data-ttu-id="a1734-204">与此类似，更新也会被传播到那些表。</span><span class="sxs-lookup"><span data-stu-id="a1734-204">Similarly, updates are also propagated to those tables.</span></span>  
  
 <span data-ttu-id="a1734-205">在下列情况下，此技术很有用：</span><span class="sxs-lookup"><span data-stu-id="a1734-205">This technology is useful in the following situations:</span></span>  
  
-   <span data-ttu-id="a1734-206">您需要拥有以 XML 为中心的编程模型，该模型使用建立在现有关系数据上的 XML 视图。</span><span class="sxs-lookup"><span data-stu-id="a1734-206">You want to have an XML-centric programming model using XML views over your existing relational data.</span></span>  
  
-   <span data-ttu-id="a1734-207">您有对应于您的 XML 数据的架构（XSD、XDR），该架构可能由外部伙伴提供。</span><span class="sxs-lookup"><span data-stu-id="a1734-207">You have a schema (XSD, XDR) for your XML data that an external partner may have provided.</span></span>  
  
-   <span data-ttu-id="a1734-208">数据中的顺序并不重要，或查询表数据不是递归的，或事先已知最大递归深度。</span><span class="sxs-lookup"><span data-stu-id="a1734-208">Order is not important in your data, or your query table data is not recursive, or the maximal recursion depth is known in advance.</span></span>  
  
-   <span data-ttu-id="a1734-209">您希望使用 XPath 1.0 版通过 XML 视图查询和修改数据。</span><span class="sxs-lookup"><span data-stu-id="a1734-209">You want to query and modify the data through the XML view by using XPath version 1.0.</span></span>  
  
-   <span data-ttu-id="a1734-210">您希望通过 XML 视图来大容量加载 XML 数据，并将其分解到基础表。</span><span class="sxs-lookup"><span data-stu-id="a1734-210">You want to bulk load XML data and decompose them into the underlying tables by using the XML view.</span></span>  
  
 <span data-ttu-id="a1734-211">这方面的例子有，作为用于数据交换和 Web 服务的 XML 公开的关系数据，以及具有固定架构的 XML 数据。</span><span class="sxs-lookup"><span data-stu-id="a1734-211">Examples include relational data exposed as XML for data exchange and Web services, and XML data with fixed schema.</span></span> <span data-ttu-id="a1734-212">有关详细信息，请参阅 [MSDN Online Library](https://go.microsoft.com/fwlink/?linkid=31174)。</span><span class="sxs-lookup"><span data-stu-id="a1734-212">For more information, see the [MSDN Online Library](https://go.microsoft.com/fwlink/?linkid=31174).</span></span>  
  
#### <a name="example-modeling-data-using-an-annotated-xml-schema-axsd"></a><span data-ttu-id="a1734-213">示例：使用带批注的 XML 架构 (AXSD) 对数据进行建模</span><span class="sxs-lookup"><span data-stu-id="a1734-213">Example: Modeling Data Using an Annotated XML Schema (AXSD)</span></span>  
 <span data-ttu-id="a1734-214">为了进行说明，假定您具有希望将其作为 XML 处理的关系数据（如客户、订单和行项）。</span><span class="sxs-lookup"><span data-stu-id="a1734-214">For illustration, assume that you have existing relational data, such as customers, orders, and line items, that you want to handle as XML.</span></span> <span data-ttu-id="a1734-215">请使用 AXSD 在关系数据上定义 XML 视图。</span><span class="sxs-lookup"><span data-stu-id="a1734-215">Define an XML view by using AXSD over the relational data.</span></span> <span data-ttu-id="a1734-216">通过使用 XML 视图可以将 XML 数据大容量加载到表，以及使用 XML 视图查询和更新关系数据。</span><span class="sxs-lookup"><span data-stu-id="a1734-216">The XML view allows you to bulk load XML data into your tables and query and update the relational data by using the XML view.</span></span> <span data-ttu-id="a1734-217">如果必须在 SQL 应用程序不间断工作时与其他应用程序交换包含 XML 标记的数据，该模型很有用。</span><span class="sxs-lookup"><span data-stu-id="a1734-217">This model is useful if you have to exchange data that contains XML markup with other applications while your SQL applications work uninterrupted.</span></span>  
  
### <a name="hybrid-model"></a><span data-ttu-id="a1734-218">混合模型</span><span class="sxs-lookup"><span data-stu-id="a1734-218">Hybrid Model</span></span>  
 <span data-ttu-id="a1734-219">通常，关系 `xml` 数据类型列和数据类型列的组合适用于数据建模。</span><span class="sxs-lookup"><span data-stu-id="a1734-219">Frequently, a combination of relational and `xml` data type columns is appropriate for data modeling.</span></span> <span data-ttu-id="a1734-220">可以将 XML 数据中的某些值存储在关系列中，而将其余或全部 XML 值存储在 XML 列中。</span><span class="sxs-lookup"><span data-stu-id="a1734-220">Some of the values from your XML data can be stored in relational columns, and the rest, or the whole XML value stored in an XML column.</span></span> <span data-ttu-id="a1734-221">这可获得更好的性能，您可以更好地控制对关系列创建的索引和锁定特征。</span><span class="sxs-lookup"><span data-stu-id="a1734-221">This may yield better performance in that you have more control over the indexes created on the relational columns and locking characteristics.</span></span>  
  
 <span data-ttu-id="a1734-222">要存储在关系列中的值取决于您的工作负荷。</span><span class="sxs-lookup"><span data-stu-id="a1734-222">The values to store in relational columns depend on your workload.</span></span> <span data-ttu-id="a1734-223">例如，如果根据路径表达式 /Customer/@CustId 检索所有 XML 值，则将 **CustId** 属性的值提升到关系列并对其进行索引可以获得更快的查询性能。</span><span class="sxs-lookup"><span data-stu-id="a1734-223">For example, if you retrieve all the XML values based on the path expression, /Customer/@CustId, promoting the value of the **CustId** attribute into a relational column and indexing it may yield faster query performance.</span></span> <span data-ttu-id="a1734-224">另一方面，如果您的 XML 数据是以非冗余方式广泛地分解在关系列中，则重新汇集的开销可能很大。</span><span class="sxs-lookup"><span data-stu-id="a1734-224">On the other hand, if your XML data is extensively and nonredundantly decomposed into relational columns, the re-assembly cost may be significant.</span></span>  
  
 <span data-ttu-id="a1734-225">对于高度结构化的 XML 数据，例如，表的内容已转换为 XML，您可以将所有值映射到关系列，并且可能使用 XML 视图技术。</span><span class="sxs-lookup"><span data-stu-id="a1734-225">For highly structured XML data, for example, the content of a table has been converted into XML; you can map all values to relational columns, and possibly use XML view technology.</span></span>  
  
## <a name="granularity-of-xml-data"></a><span data-ttu-id="a1734-226">XML 数据的粒度</span><span class="sxs-lookup"><span data-stu-id="a1734-226">Granularity of XML Data</span></span>  
 <span data-ttu-id="a1734-227">XML 列中存储的 XML 数据的粒度对锁定至关重要，在一定程度上，对更新也很重要。</span><span class="sxs-lookup"><span data-stu-id="a1734-227">The granularity of the XML data stored in an XML column is very important for locking and, to a lesser degree, it is also important for updates.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="a1734-228">对 XML 数据和非 XML 数据都使用相同的锁定机制。</span><span class="sxs-lookup"><span data-stu-id="a1734-228">uses the same locking mechanism for both XML and non-XML data.</span></span> <span data-ttu-id="a1734-229">因此，行级锁定会导致锁定行中的所有 XML 实例。</span><span class="sxs-lookup"><span data-stu-id="a1734-229">Therefore, row-level locking causes all XML instances in the row to be locked.</span></span> <span data-ttu-id="a1734-230">当粒度较大时，锁定大型 XML 实例以便进行更新会导致多用户情况下的吞吐量下降。</span><span class="sxs-lookup"><span data-stu-id="a1734-230">When the granularity is large, locking large XML instances for updates causes throughput to decline in a multiuser scenario.</span></span> <span data-ttu-id="a1734-231">另一方面，过度分解会丢失对象封装，并增加重新汇集开销。</span><span class="sxs-lookup"><span data-stu-id="a1734-231">On the other hand, severe decomposition loses object encapsulation and increases reassembly cost.</span></span>  
  
 <span data-ttu-id="a1734-232">对于良好的设计而言，重要的是保持数据建模要求与锁定和更新特征之间的平衡。</span><span class="sxs-lookup"><span data-stu-id="a1734-232">A balance between data modeling requirements and locking and update characteristics is important for good design.</span></span> <span data-ttu-id="a1734-233">但在 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]中，实际存储的 XML 实例的大小并不十分重要。</span><span class="sxs-lookup"><span data-stu-id="a1734-233">However, in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], the size of actual stored XML instances is not as critical.</span></span>  
  
 <span data-ttu-id="a1734-234">例如，通过使用对部分二进制大型对象 (BLOB) 和部分索引更新（将存储的现有 XML 实例与其更新后的版本进行比较）的新支持，对 XML 实例进行更新。</span><span class="sxs-lookup"><span data-stu-id="a1734-234">For example, updates to an XML instance are performed by using new support for partial binary large object (BLOB) and partial index updates in which the existing stored XML instance is compared to its updated version.</span></span> <span data-ttu-id="a1734-235">部分二进制大型对象 (BLOB) 更新在两个 XML 实例之间执行差异比较，并只更新差异之处。</span><span class="sxs-lookup"><span data-stu-id="a1734-235">Partial binary large object (BLOB) update performs a differential comparison between the two XML instances and updates only the differences.</span></span> <span data-ttu-id="a1734-236">部分索引更新只修改那些必须在 XML 索引中更改的行。</span><span class="sxs-lookup"><span data-stu-id="a1734-236">Partial index updates modify only those rows that must be changed in the XML index.</span></span>  
  
## <a name="limitations-of-the-xml-data-type"></a><span data-ttu-id="a1734-237">xml 数据类型的限制</span><span class="sxs-lookup"><span data-stu-id="a1734-237">Limitations of the xml Data Type</span></span>  
 <span data-ttu-id="a1734-238">请注意以下适用于 `xml` 数据类型的一般限制：</span><span class="sxs-lookup"><span data-stu-id="a1734-238">Note the following general limitations that apply to the `xml` data type:</span></span>  
  
-   <span data-ttu-id="a1734-239">`xml` 数据类型实例所占据的存储空间大小不能超过 2 GB。</span><span class="sxs-lookup"><span data-stu-id="a1734-239">The stored representation of `xml` data type instances cannot exceed 2 GB.</span></span>  
  
-   <span data-ttu-id="a1734-240">不能用作 **sql_variant** 实例的子类型。</span><span class="sxs-lookup"><span data-stu-id="a1734-240">It cannot be used as a subtype of a **sql_variant** instance.</span></span>  
  
-   <span data-ttu-id="a1734-241">不支持转换或转换为 `text` 或 `ntext`。</span><span class="sxs-lookup"><span data-stu-id="a1734-241">It does not support casting or converting to either `text` or `ntext`.</span></span> <span data-ttu-id="a1734-242">请改用 `varchar(max)` 或 `nvarchar(max)`。</span><span class="sxs-lookup"><span data-stu-id="a1734-242">Use `varchar(max)` or `nvarchar(max)` instead.</span></span>  
  
-   <span data-ttu-id="a1734-243">不能进行比较或排序。</span><span class="sxs-lookup"><span data-stu-id="a1734-243">It cannot be compared or sorted.</span></span> <span data-ttu-id="a1734-244">这意味着 `xml` 数据类型不能用在 GROUP BY 语句中。</span><span class="sxs-lookup"><span data-stu-id="a1734-244">This means an `xml` data type cannot be used in a GROUP BY statement.</span></span>  
  
-   <span data-ttu-id="a1734-245">不能用作除 ISNULL、COALESCE 和 DATALENGTH 之外的任何内置标量函数的参数。</span><span class="sxs-lookup"><span data-stu-id="a1734-245">It cannot be used as a parameter to any scalar, built-in functions other than ISNULL, COALESCE, and DATALENGTH.</span></span>  
  
-   <span data-ttu-id="a1734-246">不能用作索引中的键列。</span><span class="sxs-lookup"><span data-stu-id="a1734-246">It cannot be used as a key column in an index.</span></span> <span data-ttu-id="a1734-247">但可以作为数据包含在聚集索引中；如果创建了非聚集索引，也可以使用 INCLUDE 关键字显式添加到该非聚集索引中。</span><span class="sxs-lookup"><span data-stu-id="a1734-247">However, it can be included as data in a clustered index or explicitly added to a nonclustered index by using the INCLUDE keyword when the nonclustered index is created.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a1734-248">另请参阅</span><span class="sxs-lookup"><span data-stu-id="a1734-248">See Also</span></span>  
 [<span data-ttu-id="a1734-249">批量导入和导出 XML 文档的示例 (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="a1734-249">Examples of Bulk Import and Export of XML Documents &#40;SQL Server&#41;</span></span>](../import-export/examples-of-bulk-import-and-export-of-xml-documents-sql-server.md)  
  
  
