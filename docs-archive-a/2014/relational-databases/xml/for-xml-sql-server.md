---
title: FOR XML (SQL Server) | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- FOR XML clause, about FOR XML clause
- PATH FOR XML mode, construction
- EXPLICIT FOR XML mode
- RAW FOR XML mode
- retrieving XML data
- XML [SQL Server], FOR XML clause
- AUTO FOR XML mode
- XML [SQL Server], construction
ms.assetid: 2b6b5c61-c5bd-49d2-8c0c-b7cf15857906
author: rothja
ms.author: jroth
ms.openlocfilehash: 6fe55186e89020f57ae1eb078625d1cdce262864
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87694387"
---
# <a name="for-xml-sql-server"></a><span data-ttu-id="a4ec6-102">FOR XML (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="a4ec6-102">FOR XML (SQL Server)</span></span>
  <span data-ttu-id="a4ec6-103">SELECT 查询将结果作为行集返回。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-103">A SELECT query returns results as a rowset.</span></span> <span data-ttu-id="a4ec6-104">（可选操作）您可以通过在 SQL 查询中指定 FOR XML 子句，从而将该查询的正式结果作为 XML 来检索。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-104">You can optionally retrieve formal results of a SQL query as XML by specifying the FOR XML clause in the query.</span></span> <span data-ttu-id="a4ec6-105">FOR XML 子句可以用在顶级查询和子查询中。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-105">The FOR XML clause can be used in top-level queries and in sub queries.</span></span> <span data-ttu-id="a4ec6-106">顶级 FOR XML 子句只能用在 SELECT 语句中。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-106">The top-level FOR XML clause can be used only in the SELECT statement.</span></span> <span data-ttu-id="a4ec6-107">而在子查询中，FOR XML 可以用在 INSERT、UPDATE 和 DELETE 语句中。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-107">In sub queries, FOR XML can be used in the INSERT, UPDATE, and DELETE statements.</span></span> <span data-ttu-id="a4ec6-108">它还可以用在赋值语句中。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-108">It can also be used in assignment statements.</span></span>  
  
 <span data-ttu-id="a4ec6-109">在 FOR XML 子句中，指定以下模式之一：</span><span class="sxs-lookup"><span data-stu-id="a4ec6-109">In a FOR XML clause, you specify one of these modes:</span></span>  
  
-   <span data-ttu-id="a4ec6-110">RAW</span><span class="sxs-lookup"><span data-stu-id="a4ec6-110">RAW</span></span>  
  
-   <span data-ttu-id="a4ec6-111">AUTO</span><span class="sxs-lookup"><span data-stu-id="a4ec6-111">AUTO</span></span>  
  
-   <span data-ttu-id="a4ec6-112">EXPLICIT</span><span class="sxs-lookup"><span data-stu-id="a4ec6-112">EXPLICIT</span></span>  
  
-   <span data-ttu-id="a4ec6-113">PATH</span><span class="sxs-lookup"><span data-stu-id="a4ec6-113">PATH</span></span>  
  
 <span data-ttu-id="a4ec6-114">RAW 模式将为 SELECT 语句所返回行集中的每行生成一个 \<row> 元素。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-114">The RAW mode generates a single \<row> element per row in the rowset that is returned by the SELECT statement.</span></span> <span data-ttu-id="a4ec6-115">可以通过编写嵌套 FOR XML 查询来生成 XML 层次结构。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-115">You can generate XML hierarchy by writing nested FOR XML queries.</span></span>  
  
 <span data-ttu-id="a4ec6-116">AUTO 模式将基于指定 SELECT 语句的方式来使用试探性方法在 XML 结果中生成嵌套。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-116">The AUTO mode generates nesting in the resulting XML by using heuristics based on the way the SELECT statement is specified.</span></span> <span data-ttu-id="a4ec6-117">您对生成的 XML 的形状具有最低限度的控制能力。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-117">You have minimal control over the shape of the XML generated.</span></span> <span data-ttu-id="a4ec6-118">除了 AUTO 模式的试探性方法生成的 XML 形状之外，还可以编写 FOR XML 查询来生成 XML 层次结构。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-118">The nested FOR XML queries can be written to generate XML hierarchy beyond the XML shape that is generated by AUTO mode heuristics.</span></span>  
  
 <span data-ttu-id="a4ec6-119">EXPLICIT 模式允许对 XML 的形状进行更多控制。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-119">The EXPLICIT mode allows more control over the shape of the XML.</span></span> <span data-ttu-id="a4ec6-120">您可以随意混合属性和元素来确定 XML 的形状。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-120">You can mix attributes and elements at will in deciding the shape of the XML.</span></span> <span data-ttu-id="a4ec6-121">由于执行查询而生成的结果行集需要具有特定的格式。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-121">It requires a specific format for the resulting rowset that is generated because of query execution.</span></span> <span data-ttu-id="a4ec6-122">此行集格式随后将映射为 XML 形状。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-122">This rowset format is then mapped into XML shape.</span></span> <span data-ttu-id="a4ec6-123">使用 EXPLICIT 模式能够随意混合属性和元素、创建包装和嵌套的复杂属性、创建用空格分隔的值（例如 OrderID 属性可能具有一列排序顺序 ID 值）以及混合内容。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-123">The power of EXPLICIT mode is to mix attributes and elements at will, create wrappers and nested complex properties, create space-separated values (for example, OrderID attribute may have a list of order ID values), and mixed contents.</span></span>  
  
 <span data-ttu-id="a4ec6-124">但是，编写 EXPLICIT 模式的查询会比较麻烦。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-124">However, writing EXPLICIT mode queries can be cumbersome.</span></span> <span data-ttu-id="a4ec6-125">可以使用某些新的 FOR XML 功能（例如编写嵌套 FOR XML RAW/AUTO/PATH 模式查询和 TYPE 指令），而不使用 EXPLICIT 模式来生成层次结构。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-125">You can use some of the new FOR XML capabilities, such as writing nested FOR XML RAW/AUTO/PATH mode queries and the TYPE directive, instead of using EXPLICIT mode to generate the hierarchies.</span></span> <span data-ttu-id="a4ec6-126">嵌套 FOR XML 查询可以生成使用 EXPLICIT 模式可生成的任何 XML。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-126">The nested FOR XML queries can produce any XML that you can generate by using the EXPLICIT mode.</span></span> <span data-ttu-id="a4ec6-127">有关详细信息，请参阅 [使用嵌套的 FOR XML 查询](use-nested-for-xml-queries.md) 和 [FOR XML 查询中的 TYPE 指令](type-directive-in-for-xml-queries.md)。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-127">For more information, see [Use Nested FOR XML Queries](use-nested-for-xml-queries.md) and [TYPE Directive in FOR XML Queries](type-directive-in-for-xml-queries.md).</span></span>  
  
 <span data-ttu-id="a4ec6-128">PATH 模式与嵌套 FOR XML 查询功能一起以较简单的方式提供了 EXPLICIT 模式的灵活性。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-128">The PATH mode together with the nested FOR XML query capability provides the flexibility of the EXPLICIT mode in a simpler manner.</span></span>  
  
 <span data-ttu-id="a4ec6-129">仅当执行设置了这些模式的查询时，这些模式才有效。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-129">These modes are in effect only for the execution of the query for which they are set.</span></span> <span data-ttu-id="a4ec6-130">它们不会影响以后执行的任何查询的结果。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-130">They do not affect the results of any subsequent queries.</span></span>  
  
 <span data-ttu-id="a4ec6-131">对于任何与 FOR BROWSE 子句一起使用的选择语句，FOR XML 均无效。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-131">FOR XML is not valid for any selection that is used with a FOR BROWSE clause.</span></span>  
  
## <a name="example"></a><span data-ttu-id="a4ec6-132">示例</span><span class="sxs-lookup"><span data-stu-id="a4ec6-132">Example</span></span>  
 <span data-ttu-id="a4ec6-133">下面的 `SELECT` 语句将从 `Sales.Customer` 数据库的 `Sales.SalesOrderHeader` 和 `AdventureWorks2012` 表中检索信息。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-133">The following `SELECT` statement retrieves information from the `Sales.Customer` and `Sales.SalesOrderHeader` tables in the `AdventureWorks2012` database.</span></span> <span data-ttu-id="a4ec6-134">此查询在 `AUTO` 子句中指定了 `FOR XML` 模式：</span><span class="sxs-lookup"><span data-stu-id="a4ec6-134">This query specifies the `AUTO` mode in the `FOR XML` clause:</span></span>  
  
```  
USE AdventureWorks2012  
GO  
SELECT Cust.CustomerID,   
       OrderHeader.CustomerID,  
       OrderHeader.SalesOrderID,   
       OrderHeader.Status  
FROM Sales.Customer Cust   
INNER JOIN Sales.SalesOrderHeader OrderHeader  
ON Cust.CustomerID = OrderHeader.CustomerID  
FOR XML AUTO  
```  
  
## <a name="the-for-xml-clause-and-server-names"></a><span data-ttu-id="a4ec6-135">FOR XML 子句和服务器名称</span><span class="sxs-lookup"><span data-stu-id="a4ec6-135">The FOR XML Clause and Server Names</span></span>  
 <span data-ttu-id="a4ec6-136">如果带 FOR XML 子句的 SELECT 语句在查询中指定了一个由四部分组成的名称，则在本地计算机上执行查询时，所得 XML 文档中将不返回该服务器名称。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-136">When a SELECT statement with a FOR XML clause specifies a four-part name in the query, the server name is not returned in the resulting XML document when the query is executed on the local computer.</span></span> <span data-ttu-id="a4ec6-137">但在网络服务器上执行该查询时，此服务器名称将作为由四部分组成的名称返回。</span><span class="sxs-lookup"><span data-stu-id="a4ec6-137">However, the server name is returned as the four-part name when the query is executed on a network server.</span></span>  
  
 <span data-ttu-id="a4ec6-138">例如，请考虑下面的查询：</span><span class="sxs-lookup"><span data-stu-id="a4ec6-138">For example, consider this query:</span></span>  
  
```  
SELECT TOP 1 LastName  
FROM ServerName.AdventureWorks2012.Person.Person  
FOR XML AUTO  
```  
  
 <span data-ttu-id="a4ec6-139">如果 `ServerName` 是本地服务器，则此查询将返回以下结果：</span><span class="sxs-lookup"><span data-stu-id="a4ec6-139">When `ServerName` is a local server, the query returns the following:</span></span>  
  
```  
<AdventureWorks2012.Person.Person LastName="Achong" />  
```  
  
 <span data-ttu-id="a4ec6-140">如果 `ServerName` 是网络服务器，此查询将返回以下结果：</span><span class="sxs-lookup"><span data-stu-id="a4ec6-140">When `ServerName` is a network server, the query returns the following:</span></span>  
  
```  
<ServerName.AdventureWorks2012.Person.Person LastName="Achong" />  
```  
  
 <span data-ttu-id="a4ec6-141">通过指定如下别名可以避免这种潜在的二义性：</span><span class="sxs-lookup"><span data-stu-id="a4ec6-141">This potential ambiguity can be avoided by specifying this alias:</span></span>  
  
```  
SELECT TOP 1 LastName  
FROM ServerName.AdventureWorks2012.Person.Person x  
FOR XML AUTO   
```  
  
 <span data-ttu-id="a4ec6-142">此查询将返回如下结果：</span><span class="sxs-lookup"><span data-stu-id="a4ec6-142">This query returns the following:</span></span>  
  
```  
<x LastName="Achong"/>  
```  
  
## <a name="see-also"></a><span data-ttu-id="a4ec6-143">另请参阅</span><span class="sxs-lookup"><span data-stu-id="a4ec6-143">See Also</span></span>  
 <span data-ttu-id="a4ec6-144">[FOR XML 子句的基本语法](basic-syntax-of-the-for-xml-clause.md) </span><span class="sxs-lookup"><span data-stu-id="a4ec6-144">[Basic Syntax of the FOR XML Clause](basic-syntax-of-the-for-xml-clause.md) </span></span>  
 <span data-ttu-id="a4ec6-145">[将 RAW 模式与 FOR XML 一起使用](use-raw-mode-with-for-xml.md) </span><span class="sxs-lookup"><span data-stu-id="a4ec6-145">[Use RAW Mode with FOR XML](use-raw-mode-with-for-xml.md) </span></span>  
 <span data-ttu-id="a4ec6-146">[将 AUTO 模式与 FOR XML 一起使用](use-auto-mode-with-for-xml.md) </span><span class="sxs-lookup"><span data-stu-id="a4ec6-146">[Use AUTO Mode with FOR XML](use-auto-mode-with-for-xml.md) </span></span>  
 <span data-ttu-id="a4ec6-147">[将 EXPLICIT 模式与 FOR XML 一起使用](use-explicit-mode-with-for-xml.md) </span><span class="sxs-lookup"><span data-stu-id="a4ec6-147">[Use EXPLICIT Mode with FOR XML](use-explicit-mode-with-for-xml.md) </span></span>  
 <span data-ttu-id="a4ec6-148">[将 PATH 模式与 FOR XML 一起使用](use-path-mode-with-for-xml.md) </span><span class="sxs-lookup"><span data-stu-id="a4ec6-148">[Use PATH Mode with FOR XML](use-path-mode-with-for-xml.md) </span></span>  
 <span data-ttu-id="a4ec6-149">[OPENXML &#40;SQL Server&#41;](openxml-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="a4ec6-149">[OPENXML &#40;SQL Server&#41;](openxml-sql-server.md) </span></span>  
 [<span data-ttu-id="a4ec6-150">使用 WITH XMLNAMESPACES 将命名空间添加到查询</span><span class="sxs-lookup"><span data-stu-id="a4ec6-150">Add Namespaces to Queries with WITH XMLNAMESPACES</span></span>](add-namespaces-to-queries-with-with-xmlnamespaces.md)  
  
  
