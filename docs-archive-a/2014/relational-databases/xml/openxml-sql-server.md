---
title: OPENXML (SQL Server) | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- ColPattern [XML in SQL Server]
- OPENXML statement, about OPENXML statement
- writing XML, OPENXML statement
- OPENXML statement, querying XML
- attribute-centric mapping
- SELECT statement [SQL Server], OPENXML keyword
- column patterns [XML in SQL Server]
- row patterns [XML in SQL Server]
- rowpattern [XML in SQL Server]
- queries [XML in SQL Server], OPENXML statement
- XML [SQL Server], OPENXML statement
- element-centric mapping [SQL Server]
ms.assetid: 060126fc-ed0f-478f-830a-08e418d410dc
author: rothja
ms.author: jroth
ms.openlocfilehash: 1849029e6654fcd629499cceeff9957e5389370f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87694360"
---
# <a name="openxml-sql-server"></a><span data-ttu-id="6a47d-102">OPENXML (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="6a47d-102">OPENXML (SQL Server)</span></span>
  <span data-ttu-id="6a47d-103">OPENXML 是一个 [!INCLUDE[tsql](../../includes/tsql-md.md)] 关键字，对内存中的 XML 文档提供与表或视图相似的行集。</span><span class="sxs-lookup"><span data-stu-id="6a47d-103">OPENXML, a [!INCLUDE[tsql](../../includes/tsql-md.md)] keyword, provides a rowset over in-memory XML documents that is similar to a table or a view.</span></span> <span data-ttu-id="6a47d-104">OPENXML 允许像访问关系行集一样访问 XML 数据。</span><span class="sxs-lookup"><span data-stu-id="6a47d-104">OPENXML allows access to XML data as though it is a relational rowset.</span></span> <span data-ttu-id="6a47d-105">它通过提供以内部形式表示的 XML 文档的行集视图来实现这一点。</span><span class="sxs-lookup"><span data-stu-id="6a47d-105">It does this by providing a rowset view of the internal representation of an XML document.</span></span> <span data-ttu-id="6a47d-106">行集中的记录可以存储在数据库表中。</span><span class="sxs-lookup"><span data-stu-id="6a47d-106">The records in the rowset can be stored in database tables.</span></span>

 <span data-ttu-id="6a47d-107">无论行集提供程序（视图或 OPENROWSET）可以在何处作为源出现，都可以在 SELECT 和 SELECT INTO 语句中使用 OPENXML。</span><span class="sxs-lookup"><span data-stu-id="6a47d-107">OPENXML can be used in SELECT and SELECT INTO statements wherever rowset providers, a view, or OPENROWSET can appear as the source.</span></span> <span data-ttu-id="6a47d-108">有关 OPENXML 语法的信息，请参阅 [OPENXML (Transact-SQL)](/sql/t-sql/functions/openxml-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="6a47d-108">For information about the syntax of OPENXML, see [OPENXML &#40;Transact-SQL&#41;](/sql/t-sql/functions/openxml-transact-sql).</span></span>

 <span data-ttu-id="6a47d-109">若要使用 OPENXML 编写对 XML 文档的查询，必须先调用 `sp_xml_preparedocument` 。</span><span class="sxs-lookup"><span data-stu-id="6a47d-109">To write queries against an XML document by using OPENXML, you must first call `sp_xml_preparedocument`.</span></span> <span data-ttu-id="6a47d-110">它将分析 XML 文档并向准备使用的已分析文档返回一个句柄。</span><span class="sxs-lookup"><span data-stu-id="6a47d-110">This parses the XML document and returns a handle to the parsed document that is ready for consumption.</span></span> <span data-ttu-id="6a47d-111">已分析文档以文档对象模型 (DOM) 树的形式说明 XML 文档中的各种节点。</span><span class="sxs-lookup"><span data-stu-id="6a47d-111">The parsed document is a document object model (DOM) tree representation of various nodes in the XML document.</span></span> <span data-ttu-id="6a47d-112">该文档句柄传递给 OPENXML。</span><span class="sxs-lookup"><span data-stu-id="6a47d-112">The document handle is passed to OPENXML.</span></span> <span data-ttu-id="6a47d-113">然后 OPENXML 根据传递给它的参数提供一个该文档的行集视图。</span><span class="sxs-lookup"><span data-stu-id="6a47d-113">OPENXML then provides a rowset view of the document, based on the parameters passed to it.</span></span>

> [!NOTE]
>  <span data-ttu-id="6a47d-114">`sp_xml_preparedocument`使用 MSXML 分析器的 SQL 更新版本 Msxmlsql.dll。</span><span class="sxs-lookup"><span data-stu-id="6a47d-114">`sp_xml_preparedocument` uses a SQL-updated version of the MSXML parser, Msxmlsql.dll.</span></span> <span data-ttu-id="6a47d-115">此版本的 MSXML 分析器设计为支持 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 并保持与 MSXML 2.6 版的向后兼容性。</span><span class="sxs-lookup"><span data-stu-id="6a47d-115">This version of the MSXML parser was designed to support [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] and remain backward compatible with MSXML version 2.6.</span></span>

 <span data-ttu-id="6a47d-116">必须通过调用 **sp_xml_removedocument** 系统存储过程从内存中删除以内部形式表示的 XML 文档来释放内存。</span><span class="sxs-lookup"><span data-stu-id="6a47d-116">The internal representation of an XML document must be removed from memory by calling the **sp_xml_removedocument** system stored procedure to free the memory.</span></span>

 <span data-ttu-id="6a47d-117">下图说明了该过程。</span><span class="sxs-lookup"><span data-stu-id="6a47d-117">The following illustration shows the process.</span></span>

 <span data-ttu-id="6a47d-118">![使用 OPENXML 分析 XML](../../database-engine/media/xmlsp.gif "使用 OPENXML 分析 XML")</span><span class="sxs-lookup"><span data-stu-id="6a47d-118">![Parsing XML with OPENXML](../../database-engine/media/xmlsp.gif "Parsing XML with OPENXML")</span></span>

 <span data-ttu-id="6a47d-119">请注意，要理解 OPENXML，需要熟悉 XPath 查询并理解 XML。</span><span class="sxs-lookup"><span data-stu-id="6a47d-119">Note that to understand OPENXML, familiarity with XPath queries and an understanding of XML is required.</span></span> <span data-ttu-id="6a47d-120">有关 SQL Server 中 XPath 支持的详细信息，请参阅 [在 SQLXML 4.0 中使用 XPath 查询](../sqlxml-annotated-xsd-schemas-xpath-queries/using-xpath-queries-in-sqlxml-4-0.md)。</span><span class="sxs-lookup"><span data-stu-id="6a47d-120">For more information about XPath support in SQL Server, see [Using XPath Queries in SQLXML 4.0](../sqlxml-annotated-xsd-schemas-xpath-queries/using-xpath-queries-in-sqlxml-4-0.md).</span></span>

> [!NOTE]
>  <span data-ttu-id="6a47d-121">OPENXML 允许将行和列的 XPath 模式参数化为变量。</span><span class="sxs-lookup"><span data-stu-id="6a47d-121">OpenXML allows the row and column XPath patterns to be parameterized as variables.</span></span> <span data-ttu-id="6a47d-122">如果程序员向外部用户公开参数化（例如通过外部调用的存储过程提供参数），这种参数化可能会导致引入 XPath 表达式。</span><span class="sxs-lookup"><span data-stu-id="6a47d-122">Such parameterization could lead to XPath expression injections, if the programmer exposes the parameterization to outside users (for example, if the parameters are provided via an externally called stored procedure).</span></span> <span data-ttu-id="6a47d-123">为了避免这种潜在的安全问题，建议切勿向外部调用方公开 XPath 参数。</span><span class="sxs-lookup"><span data-stu-id="6a47d-123">To avoid such potential security issues, it is recommended that XPath parameters should never be exposed to external callers.</span></span>

## <a name="example"></a><span data-ttu-id="6a47d-124">示例</span><span class="sxs-lookup"><span data-stu-id="6a47d-124">Example</span></span>
 <span data-ttu-id="6a47d-125">`OPENXML` 下面的示例说明了如何在 `INSERT` 语句和 `SELECT` 语句中使用 。</span><span class="sxs-lookup"><span data-stu-id="6a47d-125">The following example shows the use of `OPENXML` in an `INSERT` statement and a `SELECT` statement.</span></span> <span data-ttu-id="6a47d-126">`<Customers>` 示例 XML 文档包含 `<Orders>` 和  元素。</span><span class="sxs-lookup"><span data-stu-id="6a47d-126">The sample XML document contains `<Customers>` and `<Orders>` elements.</span></span>

 <span data-ttu-id="6a47d-127">首先， `sp_xml_preparedocument` 存储过程分析 XML 文档。</span><span class="sxs-lookup"><span data-stu-id="6a47d-127">First, the `sp_xml_preparedocument` stored procedure parses the XML document.</span></span> <span data-ttu-id="6a47d-128">分析后的文档是 XML 文档中各节点（元素、属性、文本和注释）的树状表示形式。</span><span class="sxs-lookup"><span data-stu-id="6a47d-128">The parsed document is a tree representation of the nodes (elements, attributes, text, and comments) in the XML document.</span></span> <span data-ttu-id="6a47d-129">`OPENXML` 然后， 引用此经过分析的 XML 文档，并提供此 XML 文档全部或部分内容的行集视图。</span><span class="sxs-lookup"><span data-stu-id="6a47d-129">`OPENXML` then refers to this parsed XML document and provides a rowset view of all or parts of this XML document.</span></span> <span data-ttu-id="6a47d-130">`INSERT` 使用 `OPENXML` 的  语句可将数据从这样的行集插入数据库表中。</span><span class="sxs-lookup"><span data-stu-id="6a47d-130">An `INSERT` statement using `OPENXML` can insert data from such a rowset into a database table.</span></span> <span data-ttu-id="6a47d-131">`OPENXML` 可以使用多个  调用来提供 XML 文档中各部分的行集视图，并对它们进行处理，例如，将它们插入不同的表中。</span><span class="sxs-lookup"><span data-stu-id="6a47d-131">Several `OPENXML` calls can be used to provide a rowset view of various parts of the XML document and process them, for example, by inserting them into different tables.</span></span> <span data-ttu-id="6a47d-132">此过程也称为“将 XML 拆分到表中”。</span><span class="sxs-lookup"><span data-stu-id="6a47d-132">This process is also referred to as shredding XML into tables.</span></span>

 <span data-ttu-id="6a47d-133">`<Customers>` 在下面的示例中，拆分 XML 文档的方式是使用两个 `Customers` 语句，将 `<Orders>` 元素存储在 `Orders` 表中，将 `INSERT` 元素存储在  表中。</span><span class="sxs-lookup"><span data-stu-id="6a47d-133">In the following example, an XML document is shredded in a way that `<Customers>` elements are stored in the `Customers` table and `<Orders>` elements are stored in the `Orders` table by using two `INSERT` statements.</span></span> <span data-ttu-id="6a47d-134">`SELECT` 另外，此例还说明了 `OPENXML` 语句如何使用 `CustomerID` 从 XML 文档中检索 `OrderDate` 和 。</span><span class="sxs-lookup"><span data-stu-id="6a47d-134">The example also shows a `SELECT` statement with `OPENXML` that retrieves `CustomerID` and `OrderDate` from the XML document.</span></span> <span data-ttu-id="6a47d-135">`sp_xml_removedocument`该过程的最后一步是调用 。</span><span class="sxs-lookup"><span data-stu-id="6a47d-135">The last step in the process is to call `sp_xml_removedocument`.</span></span> <span data-ttu-id="6a47d-136">这样做是为了释放已分配的内存，以包含在分析阶段创建的内部 XML 树表示形式。</span><span class="sxs-lookup"><span data-stu-id="6a47d-136">This is done in order to release the memory allocated to contain the internal XML tree representation that was created during the parse phase.</span></span>

```
-- Create tables for later population using OPENXML.
CREATE TABLE Customers (CustomerID varchar(20) primary key,
                ContactName varchar(20), 
                CompanyName varchar(20));
GO
CREATE TABLE Orders( CustomerID varchar(20), OrderDate datetime);
GO
DECLARE @docHandle int;
DECLARE @xmlDocument nvarchar(max); -- or xml type
SET @xmlDocument = N'<ROOT>
<Customers CustomerID="XYZAA" ContactName="Joe" CompanyName="Company1">
<Orders CustomerID="XYZAA" OrderDate="2000-08-25T00:00:00"/>
<Orders CustomerID="XYZAA" OrderDate="2000-10-03T00:00:00"/>
</Customers>
<Customers CustomerID="XYZBB" ContactName="Steve"
CompanyName="Company2">No Orders yet!
</Customers>
</ROOT>';
EXEC sp_xml_preparedocument @docHandle OUTPUT, @xmlDocument;
-- Use OPENXML to provide rowset consisting of customer data.
INSERT Customers 
SELECT * 
FROM OPENXML(@docHandle, N'/ROOT/Customers') 
  WITH Customers;
-- Use OPENXML to provide rowset consisting of order data.
INSERT Orders 
SELECT * 
FROM OPENXML(@docHandle, N'//Orders') 
  WITH Orders;
-- Using OPENXML in a SELECT statement.
SELECT * FROM OPENXML(@docHandle, N'/ROOT/Customers/Orders') WITH (CustomerID nchar(5) '../@CustomerID', OrderDate datetime);
-- Remove the internal representation of the XML document.
EXEC sp_xml_removedocument @docHandle; 
```

 <span data-ttu-id="6a47d-137">下图显示了使用 sp_xml_preparedocument 创建的上述 XML 文档的 XML 分析树。</span><span class="sxs-lookup"><span data-stu-id="6a47d-137">The following illustration shows the parsed XML tree of the previous XML document that was created by using sp_xml_preparedocument.</span></span>

 <span data-ttu-id="6a47d-138">![经过分析的 XML 树](../../database-engine/media/xmlparsedtree.gif "经过分析的 XML 树")</span><span class="sxs-lookup"><span data-stu-id="6a47d-138">![Parsed XML tree](../../database-engine/media/xmlparsedtree.gif "Parsed XML tree")</span></span>

## <a name="openxml-parameters"></a><span data-ttu-id="6a47d-139">OPENXML 参数</span><span class="sxs-lookup"><span data-stu-id="6a47d-139">OPENXML Parameters</span></span>
 <span data-ttu-id="6a47d-140">OPENXML 的参数包括：</span><span class="sxs-lookup"><span data-stu-id="6a47d-140">The parameters to OPENXML include the following:</span></span>

-   <span data-ttu-id="6a47d-141">XML 文档句柄 (*idoc*)</span><span class="sxs-lookup"><span data-stu-id="6a47d-141">An XML document handle (*idoc*)</span></span>

-   <span data-ttu-id="6a47d-142">标识要映射到行的节点的 XPath 表达式 (*rowpattern*)</span><span class="sxs-lookup"><span data-stu-id="6a47d-142">An XPath expression to identify the nodes to be mapped to rows (*rowpattern*)</span></span>

-   <span data-ttu-id="6a47d-143">对要生成的行集的说明</span><span class="sxs-lookup"><span data-stu-id="6a47d-143">A description of the rowset to be generated</span></span>

-   <span data-ttu-id="6a47d-144">行集列和 XML 节点之间的映射</span><span class="sxs-lookup"><span data-stu-id="6a47d-144">Mapping between the rowset columns and the XML nodes</span></span>

### <a name="xml-document-handle-idoc"></a><span data-ttu-id="6a47d-145">XML 文档句柄 (idoc)</span><span class="sxs-lookup"><span data-stu-id="6a47d-145">XML Document Handle (idoc)</span></span>
 <span data-ttu-id="6a47d-146">该存储过程返回该文档句柄 `sp_xml_preparedocument` 。</span><span class="sxs-lookup"><span data-stu-id="6a47d-146">The document handle is returned by the `sp_xml_preparedocument` stored procedure.</span></span>

### <a name="xpath-expression-to-identify-the-nodes-to-be-processed-rowpattern"></a><span data-ttu-id="6a47d-147">标识要处理的节点的 XPath 表达式 (rowpattern)</span><span class="sxs-lookup"><span data-stu-id="6a47d-147">XPath Expression to Identify the Nodes to Be Processed (rowpattern)</span></span>
 <span data-ttu-id="6a47d-148"> 指定为 rowpattern 的 XPath 表达式标识 XML 文档中的一组节点。</span><span class="sxs-lookup"><span data-stu-id="6a47d-148">The XPath expression specified as *rowpattern* identifies a set of nodes in the XML document.</span></span> <span data-ttu-id="6a47d-149">*rowpattern* 标识的每个节点对应于 OPENXML 所生成的行集中的一行。</span><span class="sxs-lookup"><span data-stu-id="6a47d-149">Each node that is identified by *rowpattern* corresponds to a single row in the rowset that is generated by OPENXML.</span></span>

 <span data-ttu-id="6a47d-150">XPath 表达式标识的节点可以是 XML 文档中的任何 XML 节点。</span><span class="sxs-lookup"><span data-stu-id="6a47d-150">The nodes identified by the XPath expression can be any XML node in the XML document.</span></span> <span data-ttu-id="6a47d-151"> 如果 rowpattern 标识 XML 文档中的一组元素，则所标识的每个元素节点在行集中都占一行。</span><span class="sxs-lookup"><span data-stu-id="6a47d-151">If *rowpattern* identifies a set of elements in the XML document, there is one row in the rowset for each element node identified.</span></span> <span data-ttu-id="6a47d-152">例如，如果 *rowpattern*以属性结束，则将为 *rowpattern* 选择的每个属性节点创建一行。</span><span class="sxs-lookup"><span data-stu-id="6a47d-152">For example, if *rowpattern* ends in an attribute, a row is created for each attribute node selected by *rowpattern*.</span></span>

### <a name="description-of-the-rowset-to-be-generated"></a><span data-ttu-id="6a47d-153">对要生成的行集的说明</span><span class="sxs-lookup"><span data-stu-id="6a47d-153">Description of the Rowset to Be Generated</span></span>
 <span data-ttu-id="6a47d-154">OPENXML 使用行集架构来生成结果行集。</span><span class="sxs-lookup"><span data-stu-id="6a47d-154">A rowset schema is used by OPENXML to generate the resulting rowset.</span></span> <span data-ttu-id="6a47d-155">指定行集架构时，可以使用下列选项。</span><span class="sxs-lookup"><span data-stu-id="6a47d-155">You can use the following options when specifying a rowset schema.</span></span>

#### <a name="using-the-edge-table-format"></a><span data-ttu-id="6a47d-156">使用边缘表格式</span><span class="sxs-lookup"><span data-stu-id="6a47d-156">Using the Edge Table Format</span></span>
 <span data-ttu-id="6a47d-157">应使用边缘表格式来指定行集架构。</span><span class="sxs-lookup"><span data-stu-id="6a47d-157">You should use the edge table format to specify a rowset schema.</span></span> <span data-ttu-id="6a47d-158">请勿使用 WITH 子句。</span><span class="sxs-lookup"><span data-stu-id="6a47d-158">Do not use the WITH clause.</span></span>

 <span data-ttu-id="6a47d-159">否则，OPENXML 将以边缘表格式返回行集。</span><span class="sxs-lookup"><span data-stu-id="6a47d-159">When you do this, OPENXML returns a rowset in the edge table format.</span></span> <span data-ttu-id="6a47d-160">边缘表这种称谓源于已分析的 XML 文档树中的每个边缘都映射到行集中的一行。</span><span class="sxs-lookup"><span data-stu-id="6a47d-160">This is referred to as an edge table, because every edge in the parsed XML document tree maps to a row in the rowset.</span></span>

 <span data-ttu-id="6a47d-161">边缘表在单个表中表示 XML 文档的细密结构。</span><span class="sxs-lookup"><span data-stu-id="6a47d-161">Edge tables represent within a single table the fine-grained XML document structure.</span></span> <span data-ttu-id="6a47d-162">此结构包括元素名称和属性名称、文档层次结构、命名空间和处理指令。</span><span class="sxs-lookup"><span data-stu-id="6a47d-162">This structure includes the element and attribute names, the document hierarchy, the namespaces, and the processing instructions.</span></span> <span data-ttu-id="6a47d-163">通过边缘表格式可以获得无法通过元属性表现的其他信息。</span><span class="sxs-lookup"><span data-stu-id="6a47d-163">The edge table format allows you to obtain additional information that is not exposed through the metaproperties.</span></span> <span data-ttu-id="6a47d-164">[Specify Metaproperties in OPENXML](../xml/specify-metaproperties-in-openxml.md)有关元数据属性的详细信息，请参阅。</span><span class="sxs-lookup"><span data-stu-id="6a47d-164">For more information about metaproperties, see [Specify Metaproperties in OPENXML](../xml/specify-metaproperties-in-openxml.md).</span></span>

 <span data-ttu-id="6a47d-165">通过边缘表提供的其他信息可以存储和查询元素和属性的数据类型以及节点类型，另外还可以存储和查询有关 XML 文档结构的信息。</span><span class="sxs-lookup"><span data-stu-id="6a47d-165">The additional information provided by an edge table allows you to store and query the data type of an element and attribute, and the node type, and also store and query information about the XML document structure.</span></span> <span data-ttu-id="6a47d-166">有了这些其他信息，还可以创建您自己的 XML 文档管理系统。</span><span class="sxs-lookup"><span data-stu-id="6a47d-166">With this additional information, it may also be possible to build your own XML document management system.</span></span>

 <span data-ttu-id="6a47d-167">通过使用边缘表，可以编写这样一些存储过程：将 XML 文档作为二进制大型对象 (BLOB) 输入，生成边缘表，然后以更为详细的级别提取和分析文档。</span><span class="sxs-lookup"><span data-stu-id="6a47d-167">By using an edge table, you can write stored procedures that take XML documents as binary large object (BLOB) input, produce the edge table, and then extract and analyze the document on a more detailed level.</span></span> <span data-ttu-id="6a47d-168">此详细级别可以包括查找文档层次结构、元素名称和属性名称、命名空间和处理指令。</span><span class="sxs-lookup"><span data-stu-id="6a47d-168">This detailed level could include finding the document hierarchy, the element and attribute names, the namespaces, and the processing instructions.</span></span>

 <span data-ttu-id="6a47d-169">当映射到其他关系格式不合逻辑且 ntext 字段没有提供足够的结构信息时，边缘表还可以用作 XML 文档的存储格式。</span><span class="sxs-lookup"><span data-stu-id="6a47d-169">The edge table also can serve as a storage format for XML documents when mapping to other relational formats is not logical and an ntext field is not providing enough structural information.</span></span>

 <span data-ttu-id="6a47d-170">在可以使用 XML 分析器检查 XML 文档的情况下，使用边缘表也可以获得相同的信息。</span><span class="sxs-lookup"><span data-stu-id="6a47d-170">In situations where you can use an XML parser to examine an XML document, you can use an edge table instead to obtain the same information.</span></span>

 <span data-ttu-id="6a47d-171">下表介绍了边缘表的结构。</span><span class="sxs-lookup"><span data-stu-id="6a47d-171">The following table describes the structure of the edge table.</span></span>

|<span data-ttu-id="6a47d-172">列名称</span><span class="sxs-lookup"><span data-stu-id="6a47d-172">Column name</span></span>|<span data-ttu-id="6a47d-173">数据类型</span><span class="sxs-lookup"><span data-stu-id="6a47d-173">Data type</span></span>|<span data-ttu-id="6a47d-174">说明</span><span class="sxs-lookup"><span data-stu-id="6a47d-174">Description</span></span>|
|-----------------|---------------|-----------------|
|<span data-ttu-id="6a47d-175">**id**</span><span class="sxs-lookup"><span data-stu-id="6a47d-175">**id**</span></span>|<span data-ttu-id="6a47d-176">**bigint**</span><span class="sxs-lookup"><span data-stu-id="6a47d-176">**bigint**</span></span>|<span data-ttu-id="6a47d-177">文档节点的唯一 ID。</span><span class="sxs-lookup"><span data-stu-id="6a47d-177">Is the unique ID of the document node.</span></span><br /><br /> <span data-ttu-id="6a47d-178">根元素具有的 ID 值为 0。</span><span class="sxs-lookup"><span data-stu-id="6a47d-178">The root element has an ID value of 0.</span></span> <span data-ttu-id="6a47d-179">保留负的 ID 值。</span><span class="sxs-lookup"><span data-stu-id="6a47d-179">The negative ID values are reserved.</span></span>|
|<span data-ttu-id="6a47d-180">**parentid**</span><span class="sxs-lookup"><span data-stu-id="6a47d-180">**parentid**</span></span>|<span data-ttu-id="6a47d-181">**bigint**</span><span class="sxs-lookup"><span data-stu-id="6a47d-181">**bigint**</span></span>|<span data-ttu-id="6a47d-182">标识节点的父节点。</span><span class="sxs-lookup"><span data-stu-id="6a47d-182">Identifies the parent of the node.</span></span> <span data-ttu-id="6a47d-183">此 ID 标识的父节点不一定是父元素。</span><span class="sxs-lookup"><span data-stu-id="6a47d-183">The parent identified by this ID is not necessarily the parent element.</span></span> <span data-ttu-id="6a47d-184">但具体情况取决于此 ID 所标识节点的子节点的节点类型。</span><span class="sxs-lookup"><span data-stu-id="6a47d-184">However, this depends on the NodeType of the node whose parent is identified by this ID.</span></span> <span data-ttu-id="6a47d-185">例如，如果节点为文本节点，则其父节点可能是一个属性节点。</span><span class="sxs-lookup"><span data-stu-id="6a47d-185">For example, if the node is a text node, its parent may be an attribute node.</span></span><br /><br /> <span data-ttu-id="6a47d-186"> 如果节点位于 XML 文档的顶层，则其 ParentID 为 NULL。</span><span class="sxs-lookup"><span data-stu-id="6a47d-186">If the node is at the top level in the XML document, its **ParentID** is NULL.</span></span>|
|<span data-ttu-id="6a47d-187">**节点类型**</span><span class="sxs-lookup"><span data-stu-id="6a47d-187">**node type**</span></span>|<span data-ttu-id="6a47d-188">**int**</span><span class="sxs-lookup"><span data-stu-id="6a47d-188">**int**</span></span>|<span data-ttu-id="6a47d-189">标识节点类型，是对应于 XML 对象模型 (DOM) 节点类型编号的一个整数。</span><span class="sxs-lookup"><span data-stu-id="6a47d-189">Identifies the node type and is an integer that corresponds to the XML object model (DOM) node type numbering.</span></span><br /><br /> <span data-ttu-id="6a47d-190">下列值是可以显示在此列中以指明节点类型的值：</span><span class="sxs-lookup"><span data-stu-id="6a47d-190">Following are the values that can appear in this column to indicate the node type:</span></span><br /><br /> <span data-ttu-id="6a47d-191">**1** = 元素节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-191">**1** = Element node</span></span><br /><br /> <span data-ttu-id="6a47d-192">**2** = 属性节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-192">**2** = Attribute node</span></span><br /><br /> <span data-ttu-id="6a47d-193">**3** = 文本节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-193">**3** = Text node</span></span><br /><br /> <span data-ttu-id="6a47d-194">**4** = CDATA 部分节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-194">**4** = CDATA section node</span></span><br /><br /> <span data-ttu-id="6a47d-195">**5** = 实体引用节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-195">**5** = Entity reference node</span></span><br /><br /> <span data-ttu-id="6a47d-196">**6** = 实体节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-196">**6** = Entity node</span></span><br /><br /> <span data-ttu-id="6a47d-197">**7** = 处理指令节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-197">**7** = Processing instruction node</span></span><br /><br /> <span data-ttu-id="6a47d-198">**8** = 注释节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-198">**8** = Comment node</span></span><br /><br /> <span data-ttu-id="6a47d-199">**9** = 文档节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-199">**9** = Document node</span></span><br /><br /> <span data-ttu-id="6a47d-200">**10** = 文档类型节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-200">**10** = Document Type node</span></span><br /><br /> <span data-ttu-id="6a47d-201">**11** = 文档片段节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-201">**11** = Document Fragment node</span></span><br /><br /> <span data-ttu-id="6a47d-202">**12** = 表示法节点</span><span class="sxs-lookup"><span data-stu-id="6a47d-202">**12** = Notation node</span></span><br /><br /> <span data-ttu-id="6a47d-203">有关详细信息，请参阅 Microsoft XML (MSXML) SDK 中的“节点类型属性”主题。</span><span class="sxs-lookup"><span data-stu-id="6a47d-203">For more information, see the "nodeType Property" topic in the Microsoft XML (MSXML) SDK.</span></span>|
|<span data-ttu-id="6a47d-204">**localname**</span><span class="sxs-lookup"><span data-stu-id="6a47d-204">**localname**</span></span>|<span data-ttu-id="6a47d-205">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="6a47d-205">**nvarchar(max)**</span></span>|<span data-ttu-id="6a47d-206">给出元素或属性的本地名称。</span><span class="sxs-lookup"><span data-stu-id="6a47d-206">Gives the local name of the element or attribute.</span></span> <span data-ttu-id="6a47d-207">如果 DOM 对象没有名称，则为 NULL。</span><span class="sxs-lookup"><span data-stu-id="6a47d-207">Is NULL if the DOM object does not have a name.</span></span>|
|<span data-ttu-id="6a47d-208">**prefix**</span><span class="sxs-lookup"><span data-stu-id="6a47d-208">**prefix**</span></span>|<span data-ttu-id="6a47d-209">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="6a47d-209">**nvarchar(max)**</span></span>|<span data-ttu-id="6a47d-210">节点名称的命名空间前缀。</span><span class="sxs-lookup"><span data-stu-id="6a47d-210">Is the namespace prefix of the node name.</span></span>|
|<span data-ttu-id="6a47d-211">**namespaceuri**</span><span class="sxs-lookup"><span data-stu-id="6a47d-211">**namespaceuri**</span></span>|<span data-ttu-id="6a47d-212">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="6a47d-212">**nvarchar(max)**</span></span>|<span data-ttu-id="6a47d-213">节点的命名空间 URI。</span><span class="sxs-lookup"><span data-stu-id="6a47d-213">Is the namespace URI of the node.</span></span> <span data-ttu-id="6a47d-214">如果值为 NULL，则命名空间不存在。</span><span class="sxs-lookup"><span data-stu-id="6a47d-214">If the value is NULL, no namespace is present.</span></span>|
|<span data-ttu-id="6a47d-215">**datatype**</span><span class="sxs-lookup"><span data-stu-id="6a47d-215">**datatype**</span></span>|<span data-ttu-id="6a47d-216">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="6a47d-216">**nvarchar(max)**</span></span>|<span data-ttu-id="6a47d-217">元素或属性行的实际数据类型，否则是 NULL。</span><span class="sxs-lookup"><span data-stu-id="6a47d-217">Is the actual data type of the element or attribute row and is otherwise NULL.</span></span> <span data-ttu-id="6a47d-218">数据类型是从内联 DTD 中或从内联架构中推断得出。</span><span class="sxs-lookup"><span data-stu-id="6a47d-218">The data type is inferred from the inline DTD or from the inline schema.</span></span>|
|<span data-ttu-id="6a47d-219">**prev**</span><span class="sxs-lookup"><span data-stu-id="6a47d-219">**prev**</span></span>|<span data-ttu-id="6a47d-220">**bigint**</span><span class="sxs-lookup"><span data-stu-id="6a47d-220">**bigint**</span></span>|<span data-ttu-id="6a47d-221">前一个同级元素的 XML ID。</span><span class="sxs-lookup"><span data-stu-id="6a47d-221">Is the XML ID of the previous sibling element.</span></span> <span data-ttu-id="6a47d-222">如果前面没有同级元素，则为 NULL。</span><span class="sxs-lookup"><span data-stu-id="6a47d-222">Is NULL if there is no direct previous sibling.</span></span>|
|<span data-ttu-id="6a47d-223">**text**</span><span class="sxs-lookup"><span data-stu-id="6a47d-223">**text**</span></span>|<span data-ttu-id="6a47d-224">**ntext**</span><span class="sxs-lookup"><span data-stu-id="6a47d-224">**ntext**</span></span>|<span data-ttu-id="6a47d-225">包含文本形式的属性值或元素内容。</span><span class="sxs-lookup"><span data-stu-id="6a47d-225">Contains the attribute value or the element content in text form.</span></span> <span data-ttu-id="6a47d-226">如果边缘表项不需要值则为 NULL。</span><span class="sxs-lookup"><span data-stu-id="6a47d-226">Or is NULL, if the edge table entry does not need a value.</span></span>|

#### <a name="using-the-with-clause-to-specify-an-existing-table"></a><span data-ttu-id="6a47d-227">使用 WITH 子句指定现有表</span><span class="sxs-lookup"><span data-stu-id="6a47d-227">Using the WITH Clause to Specify an Existing Table</span></span>
 <span data-ttu-id="6a47d-228">可以使用 WITH 字句指定现有表的名称。</span><span class="sxs-lookup"><span data-stu-id="6a47d-228">You can use the WITH clause to specify the name of an existing table.</span></span> <span data-ttu-id="6a47d-229">若要执行此操作，只需指定现有的表名称，OPENXML 可以使用该表的架构生成行集。</span><span class="sxs-lookup"><span data-stu-id="6a47d-229">To do this, just specify an existing table name whose schema can be used by OPENXML to generate the rowset.</span></span>

#### <a name="using-the-with-clause-to-specify-a-schema"></a><span data-ttu-id="6a47d-230">使用 WITH 子句指定架构</span><span class="sxs-lookup"><span data-stu-id="6a47d-230">Using the WITH Clause to Specify a Schema</span></span>
 <span data-ttu-id="6a47d-231">可以使用 WITH 子句指定完整架构。</span><span class="sxs-lookup"><span data-stu-id="6a47d-231">You can use the WITH Clause to specify a complete schema.</span></span> <span data-ttu-id="6a47d-232">在指定行集架构时，可指定列名、它们的数据类型，以及它们到 XML 文档的映射。</span><span class="sxs-lookup"><span data-stu-id="6a47d-232">In specifying the rowset schema, you specify the column names, their data types, and their mapping to the XML document.</span></span>

 <span data-ttu-id="6a47d-233">可以使用 SchemaDeclaration 中的 ColPattern 参数来指定列模式。</span><span class="sxs-lookup"><span data-stu-id="6a47d-233">You can specify the column pattern by using the ColPattern parameter in the SchemaDeclaration.</span></span> <span data-ttu-id="6a47d-234">指定的列模式用于将行集列映射到 rowpattern 标识的 XML 节点并确定映射类型。</span><span class="sxs-lookup"><span data-stu-id="6a47d-234">The specified column pattern is used to map a rowset column to the XML node that is identified by rowpattern and is also used to determine the type of mapping.</span></span>

 <span data-ttu-id="6a47d-235">*flags* 如果没有为列指定 ColPattern，则行集列根据  参数指定的映射来映射到具有相同名称的 XML 节点。</span><span class="sxs-lookup"><span data-stu-id="6a47d-235">If ColPattern is not specified for a column, the rowset column maps to the XML node with the same name, based on the mapping specified by the *flags* parameter.</span></span> <span data-ttu-id="6a47d-236">*flags* 但是，如果在 WITH 子句中将 ColPattern 指定为架构描述的一部分，则它将覆盖在  参数中指定的映射。</span><span class="sxs-lookup"><span data-stu-id="6a47d-236">However, if ColPattern is specified as part of the schema specification in the WITH clause, it overwrites the mapping that is specified in the *flags* parameter.</span></span>

### <a name="mapping-between-the-rowset-columns-and-the-xml-nodes"></a><span data-ttu-id="6a47d-237">行集列和 XML 节点之间的映射</span><span class="sxs-lookup"><span data-stu-id="6a47d-237">Mapping Between the Rowset Columns and the XML Nodes</span></span>
 <span data-ttu-id="6a47d-238">在 OPENXML 语句中，可以选择指定行集列和 *rowpattern*标识的 XML 节点之间的映射类型（如以属性为中心或以元素为中心）。</span><span class="sxs-lookup"><span data-stu-id="6a47d-238">In the OPENXML statement, you can optionally specify the type of mapping, such as attribute-centric or element-centric, between the rowset columns and the XML nodes that are identified by the *rowpattern*.</span></span> <span data-ttu-id="6a47d-239">此信息用于 XML 节点和行集列之间的转换。</span><span class="sxs-lookup"><span data-stu-id="6a47d-239">This information is used in the transformation between the XML nodes and the rowset columns.</span></span>

 <span data-ttu-id="6a47d-240">可以采用下列两种方式之一来指定映射，也可以同时采用来指定映射：</span><span class="sxs-lookup"><span data-stu-id="6a47d-240">You can specify the mapping in two ways, and you can also specify both:</span></span>

-   <span data-ttu-id="6a47d-241"> 通过使用 flags 参数</span><span class="sxs-lookup"><span data-stu-id="6a47d-241">By using the *flags* parameter</span></span>

     <span data-ttu-id="6a47d-242"> 由 flags 参数指定的映射采用名称对应，即 XML 节点映射到具有相同名称的对应行集列。</span><span class="sxs-lookup"><span data-stu-id="6a47d-242">The mapping that is specified by the *flags* parameter assumes name correspondence in which the XML nodes map to the corresponding rowset columns with same name.</span></span>

-   <span data-ttu-id="6a47d-243"> 通过使用 ColPattern 参数</span><span class="sxs-lookup"><span data-stu-id="6a47d-243">By using the *ColPattern* parameter</span></span>

     <span data-ttu-id="6a47d-244">*ColPattern*是 XPath 表达式，被指定为 WITH 子句中的 *SchemaDeclaration* 的一部分。</span><span class="sxs-lookup"><span data-stu-id="6a47d-244">*ColPattern*, an XPath expression, is specified as part of *SchemaDeclaration* in the WITH clause.</span></span> <span data-ttu-id="6a47d-245">在 *ColPattern* 中指定的映射覆盖 *flags* 参数指定的映射。</span><span class="sxs-lookup"><span data-stu-id="6a47d-245">The mapping specified in *ColPattern* overwrites the mapping specified by the *flags* parameter.</span></span>

     <span data-ttu-id="6a47d-246">*ColPattern* 可以用于指定映射类型（如以属性为中心或以元素为中心），以覆盖或增强 *flags*指定的默认映射。</span><span class="sxs-lookup"><span data-stu-id="6a47d-246">*ColPattern* can be used to specify the type of mapping, such as attribute-centric or element-centric, that overwrites or enhances the default mapping indicated by the *flags*.</span></span>

     <span data-ttu-id="6a47d-247"> 在下列情况下指定 ColPattern：</span><span class="sxs-lookup"><span data-stu-id="6a47d-247">*ColPattern* is specified under the following circumstances:</span></span>

    -   <span data-ttu-id="6a47d-248">行集中的列名不同于它映射到的元素名称或属性名称。</span><span class="sxs-lookup"><span data-stu-id="6a47d-248">The column name in the rowset is different from the element or attribute name to which it is mapped.</span></span> <span data-ttu-id="6a47d-249"> 在这种情况下，ColPattern 用于标识行集列映射到的 XML 元素名称和属性名称。</span><span class="sxs-lookup"><span data-stu-id="6a47d-249">In this case, *ColPattern* is used to identify the XML element and attribute name to which the rowset column maps.</span></span>

    -   <span data-ttu-id="6a47d-250">希望将元属性特性映射到列。</span><span class="sxs-lookup"><span data-stu-id="6a47d-250">You want to map a metaproperty attribute to the column.</span></span> <span data-ttu-id="6a47d-251"> 在这种情况下，ColPattern 用于标识行集列映射到的元属性。</span><span class="sxs-lookup"><span data-stu-id="6a47d-251">In this case, *ColPattern* is used to identify the metaproperty to which the rowset column maps.</span></span> <span data-ttu-id="6a47d-252">有关如何使用元属性的详细信息，请参阅 [在 OPENXML 中指定元属性](../xml/specify-metaproperties-in-openxml.md)。</span><span class="sxs-lookup"><span data-stu-id="6a47d-252">For more information about how to use metaproperties, see [Specify Metaproperties in OPENXML](../xml/specify-metaproperties-in-openxml.md).</span></span>

 <span data-ttu-id="6a47d-253">*flags* 和 *ColPattern* 参数都是可选的。</span><span class="sxs-lookup"><span data-stu-id="6a47d-253">Both the *flags* and *ColPattern* parameters are optional.</span></span> <span data-ttu-id="6a47d-254">如果未指定映射，则采用以属性为中心的映射。</span><span class="sxs-lookup"><span data-stu-id="6a47d-254">If no mapping is specified, attribute-centric mapping is assumed.</span></span> <span data-ttu-id="6a47d-255">以属性为中心的映射是 *flags* 参数的默认值。</span><span class="sxs-lookup"><span data-stu-id="6a47d-255">Attribute-centric mapping is the default value of the *flags* parameter.</span></span>

#### <a name="attribute-centric-mapping"></a><span data-ttu-id="6a47d-256">以属性为中心的映射</span><span class="sxs-lookup"><span data-stu-id="6a47d-256">Attribute-centric Mapping</span></span>
 <span data-ttu-id="6a47d-257">将 OPENXML 中的 *flags* 参数设置为 1 (XML_ATTRIBUTES) 将指定“**以属性为中心**”的映射。</span><span class="sxs-lookup"><span data-stu-id="6a47d-257">Setting the *flags* parameter in OPENXML to 1 (XML_ATTRIBUTES) specifies **attribute-centric** mapping.</span></span> <span data-ttu-id="6a47d-258">如果 *flags* 包含 XML_ATTRIBUTES，则显示的行集提供或使用其中每个 XML 元素都表示为一行的那些行。</span><span class="sxs-lookup"><span data-stu-id="6a47d-258">If *flags* contains XML_ ATTRIBUTES, the exposed rowset provides or consumes rows where each XML element is represented as a row.</span></span> <span data-ttu-id="6a47d-259">XML 属性根据名称对应映射到 SchemaDeclaration 中定义的属性，或 WITH 子句的 Tablename 提供的属性。</span><span class="sxs-lookup"><span data-stu-id="6a47d-259">The XML attributes are mapped to the attributes that are defined in the SchemaDeclaration or that are provided by the Tablename of the WITH clause, based on name correspondence.</span></span> <span data-ttu-id="6a47d-260">名称对应表示具有特定名称的 XML 属性都以相同名称存储在行集中的列内。</span><span class="sxs-lookup"><span data-stu-id="6a47d-260">Name correspondence means that the XML attributes of a particular name are stored in a column in the rowset with the same name.</span></span>

 <span data-ttu-id="6a47d-261"> 如果列名不同于它映射到的属性名称，则必须指定 ColPattern。</span><span class="sxs-lookup"><span data-stu-id="6a47d-261">If the column name is different from the attribute name that it maps to, *ColPattern* must be specified.</span></span>

 <span data-ttu-id="6a47d-262">如果 XML 属性具有命名空间限定符，则行集中的列名也必须有该限定符。</span><span class="sxs-lookup"><span data-stu-id="6a47d-262">If the XML attribute has a namespace qualifier, the column name in the rowset must also have the qualifier.</span></span>

#### <a name="element-centric-mapping"></a><span data-ttu-id="6a47d-263">以元素为中心的映射</span><span class="sxs-lookup"><span data-stu-id="6a47d-263">Element-centric Mapping</span></span>
 <span data-ttu-id="6a47d-264">将 OPENXML 中的 *flags* 参数设置为 2 (XML_ELEMENTS) 将指定“**以元素为中心**”的映射。</span><span class="sxs-lookup"><span data-stu-id="6a47d-264">Setting the *flags* parameter in OPENXML to 2 (XML_ELEMENTS) specifies **element-centric** mapping.</span></span> <span data-ttu-id="6a47d-265"> 除了下列差异外，它与“以属性为中心”的映射相似：</span><span class="sxs-lookup"><span data-stu-id="6a47d-265">It is similar to **attribute-centric** mapping, except for the following differences:</span></span>

-   <span data-ttu-id="6a47d-266">除非指定列级模式，否则映射的名称对应（例如，映射到具有相同名称的 XML 元素的列）选择不复杂的子元素。</span><span class="sxs-lookup"><span data-stu-id="6a47d-266">The name correspondence of the mapping example, a column mapping to an XML element with the same name chooses the noncomplex subelements, unless a column-level pattern is specified.</span></span> <span data-ttu-id="6a47d-267">在检索过程中，如果子元素复杂（因为它包含其他子元素），则将列设置为 NULL。</span><span class="sxs-lookup"><span data-stu-id="6a47d-267">In the retrieval process, if the subelement is complex because it contains additional subelements, the column is set to NULL.</span></span> <span data-ttu-id="6a47d-268">然后忽略子元素的属性值。</span><span class="sxs-lookup"><span data-stu-id="6a47d-268">Attribute values of the subelements are then ignored.</span></span>

-   <span data-ttu-id="6a47d-269">对于具有相同名称的多个子元素，将返回第一个节点。</span><span class="sxs-lookup"><span data-stu-id="6a47d-269">For multiple subelements that have the same name, the first node is returned.</span></span>

## <a name="see-also"></a><span data-ttu-id="6a47d-270">另请参阅</span><span class="sxs-lookup"><span data-stu-id="6a47d-270">See Also</span></span>
 <span data-ttu-id="6a47d-271">[sp_xml_preparedocument &#40;transact-sql&#41;](/sql/relational-databases/system-stored-procedures/sp-xml-preparedocument-transact-sql) [sp_xml_removedocument &#40;](/sql/relational-databases/system-stored-procedures/sp-xml-removedocument-transact-sql) Transact-sql&#41;[OPENXML &#40;transact-sql](/sql/t-sql/functions/openxml-transact-sql)&#41;[xml 数据 &#40;SQL Server](../xml/xml-data-sql-server.md)&#41;</span><span class="sxs-lookup"><span data-stu-id="6a47d-271">[sp_xml_preparedocument &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-xml-preparedocument-transact-sql) [sp_xml_removedocument &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-xml-removedocument-transact-sql) [OPENXML &#40;Transact-SQL&#41;](/sql/t-sql/functions/openxml-transact-sql) [XML Data &#40;SQL Server&#41;](../xml/xml-data-sql-server.md)</span></span>


