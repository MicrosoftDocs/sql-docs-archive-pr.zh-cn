---
title: 示例：使用 AUTO 模式 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- AUTO FOR XML mode, examples
ms.assetid: 11e8d0e4-df8a-46f8-aa21-9602d4f26cad
author: rothja
ms.author: jroth
ms.openlocfilehash: b457bca6b7c25b9822e3dab2eba5f5cdb04b83e6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87577418"
---
# <a name="examples-using-auto-mode"></a><span data-ttu-id="dccc9-102">示例：使用 AUTO 模式</span><span class="sxs-lookup"><span data-stu-id="dccc9-102">Examples: Using AUTO Mode</span></span>
  <span data-ttu-id="dccc9-103">下列示例说明了 AUTO 模式的使用。</span><span class="sxs-lookup"><span data-stu-id="dccc9-103">The following examples illustrate the use of AUTO mode.</span></span> <span data-ttu-id="dccc9-104">这些查询中有许多都针对 [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)] 示例数据库的 ProductModel 表的 Instructions 列中存储的自行车生产说明 XML 文档指定的。</span><span class="sxs-lookup"><span data-stu-id="dccc9-104">Many of these queries are specified against bicycle manufacturing instructions XML documents that are stored in the Instructions column of the ProductModel table in the [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)] sample database.</span></span>  
  
## <a name="example-retrieving-customer-order-and-order-detail-information"></a><span data-ttu-id="dccc9-105">示例：检索客户、订单和订单详细信息</span><span class="sxs-lookup"><span data-stu-id="dccc9-105">Example: Retrieving customer, order, and order detail information</span></span>  
 <span data-ttu-id="dccc9-106">此查询检索特定客户的客户、订单和订单详细信息。</span><span class="sxs-lookup"><span data-stu-id="dccc9-106">This query retrieves customer, order, and order detail information for a specific customer.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
SELECT Cust.CustomerID,   
       OrderHeader.CustomerID,  
       OrderHeader.SalesOrderID,   
       Detail.SalesOrderID, Detail.LineTotal, Detail.ProductID,   
       Product.Name,  
       Detail.OrderQty  
FROM Sales.Customer AS Cust  
INNER JOIN Sales.SalesOrderHeader AS OrderHeader   
    ON Cust.CustomerID = OrderHeader.CustomerID  
INNER JOIN Sales.SalesOrderDetail AS Detail  
    ON OrderHeader.SalesOrderID = Detail.SalesOrderID  
INNER JOIN Production.Product AS Product  
    ON Product.ProductID = Detail.ProductID  
WHERE Cust.CustomerID IN (29672, 29734)  
ORDER BY OrderHeader.CustomerID,  
         OrderHeader.SalesOrderID  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="dccc9-107">由于查询标识了 `Cust`、 `OrderHeader`、 `Detail`和 `Product` 表别名，因此 `AUTO` 模式生成相应的元素。</span><span class="sxs-lookup"><span data-stu-id="dccc9-107">Because the query identifies, `Cust`, `OrderHeader`, `Detail`, and `Product` table aliases, corresponding elements are generated by the `AUTO` mode.</span></span> <span data-ttu-id="dccc9-108">同样，由 `SELECT` 子句中指定的列所标识的表的顺序确定这些元素的层次结构。</span><span class="sxs-lookup"><span data-stu-id="dccc9-108">Again, the order in which tables are identified by the columns specified in the `SELECT` clause determine the hierarchy of these elements.</span></span>  
  
 <span data-ttu-id="dccc9-109">下面是部分结果：</span><span class="sxs-lookup"><span data-stu-id="dccc9-109">This is the partial result.</span></span>  
  
 `<Cust CustomerID="29672">`  
  
 `<OrderHeader CustomerID="29672" SalesOrderID="43660">`  
  
 `<Detail SalesOrderID="43660" LineTotal="874.794000" ProductID="758" OrderQty="1">`  
  
 `<Product Name="Road-450 Red, 52" />`  
  
 `</Detail>`  
  
 `<Detail SalesOrderID="43660" LineTotal="419.458900" ProductID="762" OrderQty="1">`  
  
 `<Product Name="Road-650 Red, 44" />`  
  
 `</Detail>`  
  
 `</OrderHeader>`  
  
 `<OrderHeader CustomerID="29672" SalesOrderID="47660">`  
  
 `<Detail SalesOrderID="47660" LineTotal="469.794000" ProductID="765" OrderQty="1">`  
  
 `<Product Name="Road-650 Black, 58" />`  
  
 `</Detail>`  
  
 `</OrderHeader>`  
  
 `<OrderHeader CustomerID="29672" SalesOrderID="49857">`  
  
 `<Detail SalesOrderID="49857" LineTotal="44.994000" ProductID="852" OrderQty="1">`  
  
 `<Product Name="Women's Tights, S" />`  
  
 `</Detail>`  
  
 `</OrderHeader>`  
  
 `...`  
  
 `</Cust>`  
  
## <a name="example-specifying-group-by-and-aggregate-functions"></a><span data-ttu-id="dccc9-110">示例：指定 GROUP BY 和聚合函数</span><span class="sxs-lookup"><span data-stu-id="dccc9-110">Example: Specifying GROUP BY and aggregate functions</span></span>  
 <span data-ttu-id="dccc9-111">以下查询将返回各个客户 ID 以及客户已请求的订单数。</span><span class="sxs-lookup"><span data-stu-id="dccc9-111">The following query returns individual customer IDs and the number of orders that the customer has requested.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
SELECT C.CustomerID, COUNT(*) AS NoOfOrders  
FROM Sales.Customer AS C  
INNER JOIN Sales.SalesOrderHeader AS SOH  
On C.CustomerID = SOH.CustomerID  
GROUP BY C.CustomerID  
FOR XML AUTO;This is the partial result:  
```  
  
 `<I CustomerID="11000" NoOfOrders="3" />`  
  
 `<I CustomerID="11001" NoOfOrders="3" />`  
  
 `...`  
  
## <a name="example-specifying-computed-columns-in-auto-mode"></a><span data-ttu-id="dccc9-112">示例：在 AUTO 模式中指定计算列</span><span class="sxs-lookup"><span data-stu-id="dccc9-112">Example: Specifying computed columns in AUTO mode</span></span>  
 <span data-ttu-id="dccc9-113">此查询返回串联的各个客户名以及订单信息。</span><span class="sxs-lookup"><span data-stu-id="dccc9-113">This query returns concatenated individual customer names and the order information.</span></span> <span data-ttu-id="dccc9-114">因为计算列被分配到在该点（在此例中是 <`SOH`>）出现的最内层级别，</span><span class="sxs-lookup"><span data-stu-id="dccc9-114">Because the computed column is assigned to the innermost level encountered at that point, the <`SOH`> element in this example.</span></span> <span data-ttu-id="dccc9-115">因此，串联的客户名在结果中作为 <`SOH`> 元素的属性添加。</span><span class="sxs-lookup"><span data-stu-id="dccc9-115">The concatenated customer names are added as attributes of the <`SOH`> element in the result.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
SELECT P.FirstName + ' ' + P.LastName AS Name,  
       SOH.SalesOrderID  
FROM Sales.Customer AS C  
INNER JOIN Sales.SalesOrderHeader AS SOH  
    ON  C.CustomerID = SOH.CustomerID  
INNER JOIN Person.Person AS P  
    ON P.BusinessEntityID = C.PersonID  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="dccc9-116">下面是部分结果：</span><span class="sxs-lookup"><span data-stu-id="dccc9-116">This is the partial result:</span></span>  
  
```  
<SOH Name="Jon Yang" SalesOrderID="43793" />  
<SOH Name="Eugene Huang" SalesOrderID="43767" />  
```  
  
 <span data-ttu-id="dccc9-117">若要检索具有 `Name` 属性（包含销售订单表头信息，并将每条信息作为一个子元素）的 <`IndividualCustomer`> 元素，应使用嵌套的 SELECT 子句重写查询。</span><span class="sxs-lookup"><span data-stu-id="dccc9-117">To retrieve the <`IndividualCustomer`> elements having the `Name` attribute that contains each sales order header information as a subelement, the query is rewritten using a sub select.</span></span> <span data-ttu-id="dccc9-118">内部 SELECT 子句创建临时的 `IndividualCustomer` 表，此表具有计算列，其中包含各个客户的名称。</span><span class="sxs-lookup"><span data-stu-id="dccc9-118">The inner select creates a temporary `IndividualCustomer` table with the computed column that contains the names of the individual customers.</span></span> <span data-ttu-id="dccc9-119">然后，此表与 `SalesOrderHeader` 表联接以获得结果。</span><span class="sxs-lookup"><span data-stu-id="dccc9-119">This table is then joined to the `SalesOrderHeader` table to obtain the result.</span></span>  
  
 <span data-ttu-id="dccc9-120">请注意， `Sales.Customer` 表存储有单个客户信息，其中包括该客户的 `PersonID` 值。</span><span class="sxs-lookup"><span data-stu-id="dccc9-120">Note that the `Sales.Customer` table stores individual customer information, including the `PersonID` value for that customer.</span></span> <span data-ttu-id="dccc9-121">然后，此 `PersonID` 用于从 `Person.Person` 表中查找联系人姓名。</span><span class="sxs-lookup"><span data-stu-id="dccc9-121">This `PersonID` is then used to find the contact name from the `Person.Person` table.</span></span>  
  
```  
SELECT IndividualCustomer.Name, SOH.SalesOrderID  
FROM (SELECT FirstName+ ' '+LastName AS Name, C.PersonID, C.CustomerID  
      FROM Sales.Customer AS C, Person.Person AS P  
      WHERE C.PersonID = P.BusinessEntityID) AS IndividualCustomer  
LEFT OUTER JOIN  Sales.SalesOrderHeader AS SOH  
   ON IndividualCustomer.CustomerID = SOH.CustomerID  
ORDER BY IndividualCustomer.CustomerID, SOH.CustomerIDFOR XML AUTO;  
```  
  
 <span data-ttu-id="dccc9-122">下面是部分结果：</span><span class="sxs-lookup"><span data-stu-id="dccc9-122">This is the partial result:</span></span>  
  
 `<IndividualCustomer Name="Jon Yang">`  
  
 `<SOH SalesOrderID="43793" />`  
  
 `<SOH SalesOrderID="51522" />`  
  
 `<SOH SalesOrderID="57418" />`  
  
 `</IndividualCustomer>`  
  
 `...`  
  
 `...`  
  
## <a name="example-returning-binary-data"></a><span data-ttu-id="dccc9-123">示例：返回二进制数据</span><span class="sxs-lookup"><span data-stu-id="dccc9-123">Example: Returning binary data</span></span>  
 <span data-ttu-id="dccc9-124">此查询返回 `ProductPhoto` 表中的产品照片。</span><span class="sxs-lookup"><span data-stu-id="dccc9-124">This query returns a product photo from the `ProductPhoto` table.</span></span> <span data-ttu-id="dccc9-125">`ThumbNailPhoto` 是 `ProductPhoto` 表中的 `varbinary(max)` 列。</span><span class="sxs-lookup"><span data-stu-id="dccc9-125">`ThumbNailPhoto` is an `varbinary(max)` column in the `ProductPhoto` table.</span></span> <span data-ttu-id="dccc9-126">默认情况下， `AUTO` 模式向二进制数据返回一个引用，该引用为执行查询的数据库的虚拟根目录的相对 URL。</span><span class="sxs-lookup"><span data-stu-id="dccc9-126">By default, `AUTO` mode returns to the binary data a reference that is a relative URL to the virtual root of the database where the query is executed.</span></span> <span data-ttu-id="dccc9-127">必须指定 `ProductPhotoID` 键属性，才能标识图像。</span><span class="sxs-lookup"><span data-stu-id="dccc9-127">The `ProductPhotoID` key attribute must be specified to identify the image.</span></span> <span data-ttu-id="dccc9-128">如此示例中所示，检索图像引用时，还必须在 `SELECT` 子句中指定表的主键，才能唯一标识行。</span><span class="sxs-lookup"><span data-stu-id="dccc9-128">In retrieving an image reference as illustrated in this example, the primary key of the table must also be specified in the `SELECT` clause to uniquely identify a row.</span></span>  
  
```  
SELECT ProductPhotoID, ThumbNailPhoto  
FROM   Production.ProductPhoto   
WHERE ProductPhotoID=70  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="dccc9-129">结果如下：</span><span class="sxs-lookup"><span data-stu-id="dccc9-129">This is the result:</span></span>  
  
 `-- result`  
  
 `<Production.ProductPhoto`  
  
 `ProductPhotoID="70"`  
  
 `ThumbNailPhoto= "dbobject/Production.ProductPhoto[@ProductPhotoID='70']/@ThumbNailPhoto" />`  
  
 <span data-ttu-id="dccc9-130">用 `BINARY BASE64` 选项执行上述查询。</span><span class="sxs-lookup"><span data-stu-id="dccc9-130">The same query is executed with the `BINARY BASE64` option.</span></span> <span data-ttu-id="dccc9-131">查询以 base64 编码格式返回二进制数据。</span><span class="sxs-lookup"><span data-stu-id="dccc9-131">The query returns the binary data in base64-encoded format.</span></span>  
  
```  
SELECT ProductPhotoID, ThumbNailPhoto  
FROM   Production.ProductPhoto   
WHERE ProductPhotoID=70  
FOR XML AUTO, BINARY BASE64;  
```  
  
 <span data-ttu-id="dccc9-132">结果如下：</span><span class="sxs-lookup"><span data-stu-id="dccc9-132">This is the result:</span></span>  
  
 `-- result`  
  
 `<Production.ProductPhoto ProductPhotoID="70" ThumbNailPhoto="Base64 encoded photo" />`  
  
 <span data-ttu-id="dccc9-133">默认情况下，使用 AUTO 模式检索二进制数据时，将返回执行查询的数据库的虚拟根目录的相对 URL 的引用，而不返回二进制数据。</span><span class="sxs-lookup"><span data-stu-id="dccc9-133">By default, when you use AUTO mode to retrieve binary data, a reference to a relative URL to the virtual root of the database where the query was executed will be returned instead of the binary data.</span></span> <span data-ttu-id="dccc9-134">如果未指定 BINARY BASE64 选项，也会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="dccc9-134">This will occur if the BINARY BASE64 option is not specified.</span></span>  
  
 <span data-ttu-id="dccc9-135">当 AUTO 模式返回不区分大小写的数据库（查询中指定的表名或列名与数据库中的表名或列名不匹配）中的二进制数据的 URL 引用时，将执行查询。</span><span class="sxs-lookup"><span data-stu-id="dccc9-135">When AUTO mode returns a URL reference to the binary data in case-insensitive databases where a table or column name specified in the query does not match the table or column name in the database, the query executes.</span></span> <span data-ttu-id="dccc9-136">但是，引用中返回结果的大小写将不一致。</span><span class="sxs-lookup"><span data-stu-id="dccc9-136">However, the case returned in the reference will not be consistent.</span></span> <span data-ttu-id="dccc9-137">例如：</span><span class="sxs-lookup"><span data-stu-id="dccc9-137">For example:</span></span>  
  
```  
SELECT ProductPhotoID, ThumbnailPhoto  
FROM   Production.ProductPhoto   
WHERE  ProductPhotoID=70  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="dccc9-138">结果如下：</span><span class="sxs-lookup"><span data-stu-id="dccc9-138">This is the result:</span></span>  
  
 `<Production.PRODUCTPHOTO`  
  
 `PRODUCTPHOTOID="70"`  
  
 `THUMBNAILPHOTO= "dbobject/Production.PRODUCTPHOTO[@ProductPhotoID='70']/@ThumbNailPhoto" />`  
  
 <span data-ttu-id="dccc9-139">这可能成为一个问题，尤其是对区分大小写的数据库执行 dbobject 查询时。</span><span class="sxs-lookup"><span data-stu-id="dccc9-139">This can be a problem particularly when dbobject queries are executed against a case sensitive database.</span></span> <span data-ttu-id="dccc9-140">若要避免这个问题，查询中指定的表名或列名的大小写应该与数据库中表名或列名的大小写一致。</span><span class="sxs-lookup"><span data-stu-id="dccc9-140">To avoid this, the case of the table or column name that is specified in the queries should match the case of the table or column name in the database.</span></span>  
  
## <a name="example-understanding-the-encoding"></a><span data-ttu-id="dccc9-141">示例：了解编码</span><span class="sxs-lookup"><span data-stu-id="dccc9-141">Example: Understanding the encoding</span></span>  
 <span data-ttu-id="dccc9-142">下面的示例显示了结果中出现的各种编码。</span><span class="sxs-lookup"><span data-stu-id="dccc9-142">This example shows the various encoding that occurs in the result.</span></span>  
  
 <span data-ttu-id="dccc9-143">创建下表：</span><span class="sxs-lookup"><span data-stu-id="dccc9-143">Create this table:</span></span>  
  
```  
CREATE TABLE [Special Chars] (Col1 char(1) primary key, [Col#&2] varbinary(50));  
```  
  
 <span data-ttu-id="dccc9-144">将下列数据添加到表中：</span><span class="sxs-lookup"><span data-stu-id="dccc9-144">Add the following data to the table:</span></span>  
  
```  
INSERT INTO [Special Chars] VALUES ('&', 0x20), ('#', 0x20);  
```  
  
 <span data-ttu-id="dccc9-145">下面的查询将返回该表中的数据。</span><span class="sxs-lookup"><span data-stu-id="dccc9-145">This query returns the data from the table.</span></span> <span data-ttu-id="dccc9-146">指定了 FOR XML AUTO 模式。</span><span class="sxs-lookup"><span data-stu-id="dccc9-146">The FOR XML AUTO mode is specified.</span></span> <span data-ttu-id="dccc9-147">二进制数据作为引用返回。</span><span class="sxs-lookup"><span data-stu-id="dccc9-147">Binary data is returned as a reference.</span></span>  
  
```  
SELECT * FROM [Special Chars] FOR XML AUTO;  
```  
  
 <span data-ttu-id="dccc9-148">结果如下：</span><span class="sxs-lookup"><span data-stu-id="dccc9-148">This is the result:</span></span>  
  
 `<Special_x0020_Chars`  
  
 `Col1="#"`  
  
 `Col_x0023__x0026_2="dbobject/Special_x0020_Chars[@Col1='#']/@Col_x0023__x0026_2"`  
  
 `/>`  
  
 `<Special_x0020_Chars`  
  
 `Col1="&"`  
  
 `Col_x0023__x0026_2="dbobject/Special_x0020_Chars[@Col1='&']/@Col_x0023__x0026_2"`  
  
 `/>`  
  
 <span data-ttu-id="dccc9-149">下面是对结果中的特殊字符进行编码的过程：</span><span class="sxs-lookup"><span data-stu-id="dccc9-149">This is the process for encoding special characters in the result:</span></span>  
  
-   <span data-ttu-id="dccc9-150">通过使用相应的 Unicode 字符的十六进制值，对查询结果中返回的元素名及属性名中的特殊 XML 和 URL 字符进行编码。</span><span class="sxs-lookup"><span data-stu-id="dccc9-150">In the query result, the special XML and URL characters in the element and attribute names that are returned are encoded by using the hexadecimal value of the corresponding Unicode character.</span></span> <span data-ttu-id="dccc9-151">在上面的结果中，元素名 <`Special Chars`> 作为 <`Special_x0020_Chars`> 返回。</span><span class="sxs-lookup"><span data-stu-id="dccc9-151">In the previous result, the element name <`Special Chars`> is returned as <`Special_x0020_Chars`>.</span></span> <span data-ttu-id="dccc9-152">属性名称 <`Col#&2`> 作为 <`Col_x0023__x0026_2`> 返回。</span><span class="sxs-lookup"><span data-stu-id="dccc9-152">The attribute name <`Col#&2`> is returned as <`Col_x0023__x0026_2`>.</span></span> <span data-ttu-id="dccc9-153">XML 和 URL 特殊字符都进行了编码。</span><span class="sxs-lookup"><span data-stu-id="dccc9-153">Both XML and URL special characters are encoded.</span></span>  
  
-   <span data-ttu-id="dccc9-154">如果元素值或属性值包含 5 个标准 XML 字符实体（'、""、\<, > 和 &）中的任何一个，将始终使用 XML 字符编码对这些特殊 XML 字符进行编码。</span><span class="sxs-lookup"><span data-stu-id="dccc9-154">If the values of the elements or attribute contain any of the five standard XML character entities (', "", \<, >, and &), these special XML characters are always encoded using XML character encoding.</span></span> <span data-ttu-id="dccc9-155">在上面的结果中，属性 <`Col1`> 的值中的 `&` 值被编码为 `&`。</span><span class="sxs-lookup"><span data-stu-id="dccc9-155">In the previous result, the value `&` in the value of attribute <`Col1`> is encoded as `&`.</span></span> <span data-ttu-id="dccc9-156">但是，# 字符仍保留为 #，因为它是有效的 XML 字符，而不是特殊的 XML 字符。</span><span class="sxs-lookup"><span data-stu-id="dccc9-156">However, the # character remains #, because it is a valid XML character and not a special XML character.</span></span>  
  
-   <span data-ttu-id="dccc9-157">如果元素值或属性值包含 URL 中有特殊意义的任何特殊 URL 字符，则只能在 DBOBJECT URL 值中对它们进行编码，而且只有当该特殊字符是表名或列名的一部分时，才会对它们进行编码。</span><span class="sxs-lookup"><span data-stu-id="dccc9-157">If the values of the elements or attributes contain any special URL characters that have special meaning in the URL, they are encoded only in the DBOBJECT URL value and are encoded only when the special character is part of a table or column name.</span></span> <span data-ttu-id="dccc9-158">在结果中，作为表名 `#` 的一部分的字符 `Col#&2` 被编码为 `_x0023_ in the DBOJBECT URL`。</span><span class="sxs-lookup"><span data-stu-id="dccc9-158">In the result, the character `#` that is part of table name `Col#&2` is encoded as `_x0023_ in the DBOJBECT URL`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dccc9-159">另请参阅</span><span class="sxs-lookup"><span data-stu-id="dccc9-159">See Also</span></span>  
 [<span data-ttu-id="dccc9-160">将 AUTO 模式与 FOR XML 一起使用</span><span class="sxs-lookup"><span data-stu-id="dccc9-160">Use AUTO Mode with FOR XML</span></span>](use-auto-mode-with-for-xml.md)  
  
  
