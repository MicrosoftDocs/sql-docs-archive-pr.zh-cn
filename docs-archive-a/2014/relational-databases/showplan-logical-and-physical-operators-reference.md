---
title: Showplan 逻辑运算符和物理运算符参考 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
ms.openlocfilehash: bc45a5fa14785294093385e6f90b47a8bdb6dff3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87690458"
---
# <a name="showplan-logical-and-physical-operators-reference"></a><span data-ttu-id="0a3be-102">Showplan 逻辑运算符和物理运算符参考</span><span class="sxs-lookup"><span data-stu-id="0a3be-102">Showplan Logical and Physical Operators Reference</span></span>
  <span data-ttu-id="0a3be-103">运算符说明了 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 如何执行查询或数据操作语言 (DML) 语句。</span><span class="sxs-lookup"><span data-stu-id="0a3be-103">Operators describe how [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] executes a query or a Data Manipulation Language (DML) statement.</span></span> <span data-ttu-id="0a3be-104">查询优化器使用运算符生成查询计划，以创建在查询中指定的结果或执行在 DML 语句中指定的操作。</span><span class="sxs-lookup"><span data-stu-id="0a3be-104">The query optimizer uses operators to build a query plan to create the result specified in the query, or to perform the operation specified in the DML statement.</span></span> <span data-ttu-id="0a3be-105">查询计划是由物理运算符组成的一个树。</span><span class="sxs-lookup"><span data-stu-id="0a3be-105">The query plan is a tree consisting of physical operators.</span></span> <span data-ttu-id="0a3be-106">您可以使用 SET SHOWPLAN 语句、 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]中的图形执行计划选项或 SQL Server Profiler Showplan 事件类来查看查询计划。</span><span class="sxs-lookup"><span data-stu-id="0a3be-106">You can view the query plan by using the SET SHOWPLAN statements, the graphical execution plan options in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], or the SQL Server Profiler Showplan event classes.</span></span>  
  
 <span data-ttu-id="0a3be-107">运算符分为逻辑运算符和物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-107">Operators are classified as logical and physical operators.</span></span>  
  
 <span data-ttu-id="0a3be-108">**逻辑运算符**</span><span class="sxs-lookup"><span data-stu-id="0a3be-108">**Logical Operators**</span></span>  
 <span data-ttu-id="0a3be-109">逻辑运算符描述了用于处理语句的关系代数操作。</span><span class="sxs-lookup"><span data-stu-id="0a3be-109">Logical operators describe the relational algebraic operation used to process a statement.</span></span> <span data-ttu-id="0a3be-110">换言之，逻辑运算符从概念上描述了需要执行哪些操作。</span><span class="sxs-lookup"><span data-stu-id="0a3be-110">In other words, logical operators describe conceptually what operation needs to be performed.</span></span>  
  
 <span data-ttu-id="0a3be-111">**物理运算符**</span><span class="sxs-lookup"><span data-stu-id="0a3be-111">**Physical Operators**</span></span>  
 <span data-ttu-id="0a3be-112">物理运算符实施由逻辑运算符描述的操作。</span><span class="sxs-lookup"><span data-stu-id="0a3be-112">Physical operators implement the operation described by logical operators.</span></span> <span data-ttu-id="0a3be-113">每个物理运算符都是一个执行某项操作的对象或例程。</span><span class="sxs-lookup"><span data-stu-id="0a3be-113">Each physical operator is an object or routine that performs an operation.</span></span> <span data-ttu-id="0a3be-114">例如，某些物理运算符可访问表、索引或视图中的列或行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-114">For example, some physical operators access columns or rows from a table, index or view.</span></span> <span data-ttu-id="0a3be-115">其他物理运算符执行其他操作，如计算、聚合、数据完整性检查或联接。</span><span class="sxs-lookup"><span data-stu-id="0a3be-115">Other physical operators perform other operations such as calculations, aggregations, data integrity checks or joins.</span></span> <span data-ttu-id="0a3be-116">物理运算符具有与其关联的开销。</span><span class="sxs-lookup"><span data-stu-id="0a3be-116">Physical operators have costs associated with them.</span></span>  
  
 <span data-ttu-id="0a3be-117">物理运算符初始化、收集数据，然后关闭。</span><span class="sxs-lookup"><span data-stu-id="0a3be-117">The physical operators initialize, collect data, and close.</span></span> <span data-ttu-id="0a3be-118">具体来讲，物理运算符可以响应下列三种方法调用：</span><span class="sxs-lookup"><span data-stu-id="0a3be-118">Specifically, the physical operator can answer the following three method calls:</span></span>  
  
-   <span data-ttu-id="0a3be-119">**Init()** ：Init() 方法使物理运算符初始化自身并设置所有需要的数据结构。</span><span class="sxs-lookup"><span data-stu-id="0a3be-119">**Init()**: The **Init()** method causes a physical operator to initialize itself and set up any required data structures.</span></span> <span data-ttu-id="0a3be-120">尽管一个物理运算符通常只接收一次 **Init()** 调用，但也可以接收许多次调用。</span><span class="sxs-lookup"><span data-stu-id="0a3be-120">The physical operator may receive many **Init()** calls, though typically a physical operator receives only one.</span></span>  
  
-   <span data-ttu-id="0a3be-121">**GetNext()** ：GetNext() 方法使物理运算符获得数据的第一行或后续行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-121">**GetNext()**: The **GetNext()** method causes a physical operator to get the first, or subsequent row of data.</span></span> <span data-ttu-id="0a3be-122">物理运算符可以不接收 **GetNext()** 调用，也可以接收许多次调用。</span><span class="sxs-lookup"><span data-stu-id="0a3be-122">The physical operator may receive zero or many **GetNext()** calls.</span></span>  
  
-   <span data-ttu-id="0a3be-123">**Close()** ：Close() 方法使物理运算符执行某些清除操作，然后关闭。</span><span class="sxs-lookup"><span data-stu-id="0a3be-123">**Close()**: The **Close()** method causes a physical operator to perform some clean-up operations and shut itself down.</span></span> <span data-ttu-id="0a3be-124">一个物理运算符只接收一个 **Close()** 调用。</span><span class="sxs-lookup"><span data-stu-id="0a3be-124">A physical operator only receives one **Close()** call.</span></span>  
  
 <span data-ttu-id="0a3be-125">**GetNext()** 方法返回一个数据行，它的调用次数作为 **ActualRows** 显示在使用 SET STATISTICS PROFILE ON 或 SET STATISTICS XML ON 生成的显示计划输出中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-125">The **GetNext()** method returns one row of data, and the number of times it is called appears as **ActualRows** in the Showplan output that is produced by using SET STATISTICS PROFILE ON or SET STATISTICS XML ON.</span></span> <span data-ttu-id="0a3be-126">有关这些 SET 选项的详细信息，请参阅 [SET STATISTICS PROFILE (Transact-SQL)](/sql/t-sql/statements/set-statistics-profile-transact-sql) 和 [SET STATISTICS XML (Transact-SQL)](/sql/t-sql/statements/set-statistics-xml-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="0a3be-126">For more information about these SET options, see [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) and [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).</span></span>  
  
 <span data-ttu-id="0a3be-127">显示计划输出中显示的 **ActualRebinds** 和 **ActualRewinds** 计数是指 **Init()** 方法被调用的次数。</span><span class="sxs-lookup"><span data-stu-id="0a3be-127">The **ActualRebinds** and **ActualRewinds** counts that appear in Showplan output refer to the number of times that the **Init()** method is called.</span></span> <span data-ttu-id="0a3be-128">除非运算符位于循环联接的内侧，否则 **ActualRebinds** 等于一， **ActualRewinds** 等于零。</span><span class="sxs-lookup"><span data-stu-id="0a3be-128">Unless an operator is on the inner side of a loop join, **ActualRebinds** equals one and **ActualRewinds** equals zero.</span></span> <span data-ttu-id="0a3be-129">如果运算符位于循环联接的内侧，那么重新绑定次数和重绕次数之和应等于联接外侧所处理的行数。</span><span class="sxs-lookup"><span data-stu-id="0a3be-129">If an operator is on the inner side of a loop join, the sum of the number of rebinds and rewinds should equal the number of rows processed on the outer side of the join.</span></span> <span data-ttu-id="0a3be-130">重新绑定意味着联接的一个或多个相关参数发生更改后，必须重新计算联接的内侧。</span><span class="sxs-lookup"><span data-stu-id="0a3be-130">A rebind means that one or more of the correlated parameters of the join changed and the inner side must be reevaluated.</span></span> <span data-ttu-id="0a3be-131">重绕意味着任何相关参数都没有发生更改，可以重用之前的内侧结果集。</span><span class="sxs-lookup"><span data-stu-id="0a3be-131">A rewind means that none of the correlated parameters changed and the prior inner result set may be reused.</span></span>  
  
 <span data-ttu-id="0a3be-132">**ActualRebinds** 和 **ActualRewinds** 显示在使用 SET STATISTICS XML ON 生成的 XML 显示计划输出中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-132">**ActualRebinds** and **ActualRewinds** are present in XML Showplan output produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="0a3be-133">它们仅针对**非聚集索引假脱机**、 `Remote Query` **行计数假脱机**、 `Sort` **表假脱机**和**表值函数**运算符进行填充。</span><span class="sxs-lookup"><span data-stu-id="0a3be-133">They are only populated for the **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, and **Table-valued Function** operators.</span></span> <span data-ttu-id="0a3be-134">**ActualRebinds** **ActualRewinds** `Assert` 当**actualrebinds**属性设置为 TRUE 时，还可以为和**Filter**运算符填充 ActualRebinds 和 ActualRewinds。</span><span class="sxs-lookup"><span data-stu-id="0a3be-134">**ActualRebinds** and **ActualRewinds** may also be populated for the `Assert` and **Filter** operators when the **StartupExpression** attribute is set to TRUE.</span></span>  
  
 <span data-ttu-id="0a3be-135">当 **ActualRebinds** 和 **ActualRewinds** 显示在 XML 显示计划中时，它们可以与 **EstimateRebinds** 和 **EstimateRewinds**相比较。</span><span class="sxs-lookup"><span data-stu-id="0a3be-135">When **ActualRebinds** and **ActualRewinds** are present in an XML Showplan, they are comparable to **EstimateRebinds** and **EstimateRewinds**.</span></span> <span data-ttu-id="0a3be-136">如果它们没有显示，则预计的行数 (**EstimateRows**) 可以与实际的行数 (**ActualRows**) 相比较。</span><span class="sxs-lookup"><span data-stu-id="0a3be-136">When they are absent, the estimated number of rows (**EstimateRows**) is comparable to the actual number of rows (**ActualRows**).</span></span> <span data-ttu-id="0a3be-137">注意，如果它们没有显示，实际的图形显示计划输出中将实际的重新绑定次数和重绕次数均显示为零。</span><span class="sxs-lookup"><span data-stu-id="0a3be-137">Note that actual graphical Showplan output displays zeros for the actual rebinds and actual rewinds when they are absent.</span></span>  
  
 <span data-ttu-id="0a3be-138">只有在显示计划输出是使用 SET STATISTICS XML ON 生成的情况下，相关计数器 **ActualEndOfScans**才可用。</span><span class="sxs-lookup"><span data-stu-id="0a3be-138">A related counter, **ActualEndOfScans**, is available only when Showplan output is produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="0a3be-139">只要物理运算符到达其数据流的结尾，此计数器就增加一。</span><span class="sxs-lookup"><span data-stu-id="0a3be-139">Whenever a physical operator reaches the end of its data stream, this counter is incremented by one.</span></span> <span data-ttu-id="0a3be-140">物理运算符可以到达其数据流结尾零次、一次或多次。</span><span class="sxs-lookup"><span data-stu-id="0a3be-140">A physical operator can reach the end of its data stream zero, one, or multiple times.</span></span> <span data-ttu-id="0a3be-141">对于重新绑定次数和重绕次数，只有在运算符位于循环联接的内侧时，扫描结束的次数才可以多于一次。</span><span class="sxs-lookup"><span data-stu-id="0a3be-141">As with rebinds and rewinds, the number of end of scans can be more than one only if the operator is on the inner side of a loop join.</span></span> <span data-ttu-id="0a3be-142">扫描结束的次数应少于或等于重新绑定次数与重绕次数之和。</span><span class="sxs-lookup"><span data-stu-id="0a3be-142">The number of end of scans should be less than or equal to the sum of the number of rebinds and rewinds.</span></span>  
  
## <a name="mapping-physical-and-logical-operators"></a><span data-ttu-id="0a3be-143">映射物理运算符和逻辑运算符</span><span class="sxs-lookup"><span data-stu-id="0a3be-143">Mapping Physical and Logical Operators</span></span>  
 <span data-ttu-id="0a3be-144">查询优化器可以创建一个查询计划，该计划由逻辑运算符组成的树表示。</span><span class="sxs-lookup"><span data-stu-id="0a3be-144">The query optimizer creates a query plan as a tree consisting of logical operators.</span></span> <span data-ttu-id="0a3be-145">查询优化器创建计划后，将为每个逻辑运算符选择最有效的物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-145">After the query optimizer creates the plan, the query optimizer chooses the most efficient physical operator for each logical operator.</span></span> <span data-ttu-id="0a3be-146">查询优化器使用基于开销的方法确定将实施逻辑运算符的物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-146">The query optimizer uses a cost-based approach to determine which physical operator will implement a logical operator.</span></span>  
  
 <span data-ttu-id="0a3be-147">通常，一个逻辑运算符可由多个物理运算符实施。</span><span class="sxs-lookup"><span data-stu-id="0a3be-147">Usually, a logical operation can be implemented by multiple physical operators.</span></span> <span data-ttu-id="0a3be-148">但是在少数情况下，一个物理运算符也可以实施多个逻辑操作符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-148">However, in rare cases, a physical operator can implement multiple logical operations as well.</span></span>  
  
## <a name="operator-descriptions"></a><span data-ttu-id="0a3be-149">操作说明</span><span class="sxs-lookup"><span data-stu-id="0a3be-149">Operator Descriptions</span></span>  
 <span data-ttu-id="0a3be-150">本节介绍了各个逻辑运算符和物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-150">This section contains descriptions of the logical and physical operators.</span></span>  
  
|<span data-ttu-id="0a3be-151">图形执行计划图标</span><span class="sxs-lookup"><span data-stu-id="0a3be-151">Graphical Execution Plan Icon</span></span>|<span data-ttu-id="0a3be-152">Showplan 运算符</span><span class="sxs-lookup"><span data-stu-id="0a3be-152">Showplan Operator</span></span>|<span data-ttu-id="0a3be-153">说明</span><span class="sxs-lookup"><span data-stu-id="0a3be-153">Description</span></span>|  
|-----------------------------------|-----------------------|-----------------|  
|<span data-ttu-id="0a3be-154">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-154">None</span></span>|`Aggregate`|<span data-ttu-id="0a3be-155">`Aggregate` 运算符计算包含 MIN、MAX、SUM、COUNT 或 AVG 的表达式。</span><span class="sxs-lookup"><span data-stu-id="0a3be-155">The `Aggregate` operator calculates an expression containing MIN, MAX, SUM, COUNT or AVG.</span></span> <span data-ttu-id="0a3be-156">`Aggregate`运算符可以是逻辑运算符，也可以是物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-156">The `Aggregate` operator can be a logical operator or a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-157">![Arithmetic Expression 运算符图标](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Arithmetic Expression 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-157">![Arithmetic expression operator icon](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Arithmetic expression operator icon")</span></span>|`Arithmetic Expression`|<span data-ttu-id="0a3be-158">`Arithmetic Expression` 运算符根据行中的现有值计算新值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-158">The `Arithmetic Expression` operator computes a new value from existing values in a row.</span></span> <span data-ttu-id="0a3be-159">[!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] 中不使用 `Arithmetic Expression`，</span><span class="sxs-lookup"><span data-stu-id="0a3be-159">`Arithmetic Expression` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="0a3be-160">![Assert 运算符图标](../../2014/database-engine/media/assert-32x.gif "Assert 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-160">![Assert operator icon](../../2014/database-engine/media/assert-32x.gif "Assert operator icon")</span></span>|`Assert`|<span data-ttu-id="0a3be-161">`Assert` 运算符用于验证条件。</span><span class="sxs-lookup"><span data-stu-id="0a3be-161">The `Assert` operator verifies a condition.</span></span> <span data-ttu-id="0a3be-162">例如，验证引用完整性或确保标量子查询返回一行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-162">For example, it validates referential integrity or ensures that a scalar subquery returns one row.</span></span> <span data-ttu-id="0a3be-163">对于每个输入行， `Assert` 运算符计算执行计划的列中的表达式 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-163">For each input row, the `Assert` operator evaluates the expression in the `Argument` column of the execution plan.</span></span> <span data-ttu-id="0a3be-164">如果此表达式的值为 NULL，则通过 `Assert` 运算符传递该行，并且查询执行将继续。</span><span class="sxs-lookup"><span data-stu-id="0a3be-164">If this expression evaluates to NULL, the row is passed through the `Assert` operator and the query execution continues.</span></span> <span data-ttu-id="0a3be-165">如果此表达式的值非 Null，则将产生相应的错误。</span><span class="sxs-lookup"><span data-stu-id="0a3be-165">If this expression evaluates to a nonnull value, the appropriate error will be raised.</span></span> <span data-ttu-id="0a3be-166">`Assert` 运算符是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-166">The `Assert` operator is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-167">![Assign 语言元素图标](../../2014/database-engine/media/assign-32.gif "Assign 语言元素图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-167">![Assign language element icon](../../2014/database-engine/media/assign-32.gif "Assign language element icon")</span></span>|`Assign`|<span data-ttu-id="0a3be-168">`Assign` 运算符将表达式的值或常量分配给变量。</span><span class="sxs-lookup"><span data-stu-id="0a3be-168">The `Assign` operator assigns the value of an expression or a constant to a variable.</span></span> <span data-ttu-id="0a3be-169">`Assign` 是一个语言元素。</span><span class="sxs-lookup"><span data-stu-id="0a3be-169">`Assign` is a language element.</span></span>|  
|<span data-ttu-id="0a3be-170">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-170">None</span></span>|`Asnyc Concat`|<span data-ttu-id="0a3be-171">`Asnyc Concat` 运算符仅用于远程查询（分布式查询）。</span><span class="sxs-lookup"><span data-stu-id="0a3be-171">The `Asnyc Concat` operator is used only in remote queries (distributed queries).</span></span> <span data-ttu-id="0a3be-172">它有 *n* 个子节点和一个父节点。</span><span class="sxs-lookup"><span data-stu-id="0a3be-172">It has *n* children and one parent node.</span></span> <span data-ttu-id="0a3be-173">通常，某些子节点是参与分布式查询的远程计算机。</span><span class="sxs-lookup"><span data-stu-id="0a3be-173">Usually, some of the children are remote computers that participate in a distributed query.</span></span> <span data-ttu-id="0a3be-174">`Asnyc Concat` 同时向所有子节点发出 `open()` 调用，然后将位图应用于每个子节点。</span><span class="sxs-lookup"><span data-stu-id="0a3be-174">`Asnyc Concat` issues `open()` calls to all of the children simultaneously and then applies a bitmap to each child.</span></span> <span data-ttu-id="0a3be-175">对于为 1 的每个位，`Async Concat` 按需向父节点发送输出行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-175">For each bit that is a 1, `Async Concat` sends the output rows to the parent node on demand.</span></span>|  
|<span data-ttu-id="0a3be-176">![Bitmap 运算符图标](../../2014/database-engine/media/bitmap-32x.gif "Bitmap 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-176">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]<span data-ttu-id="0a3be-177">使用 `Bitmap` 运算符来实现并行查询计划中的位图筛选。</span><span class="sxs-lookup"><span data-stu-id="0a3be-177">uses the `Bitmap` operator to implement bitmap filtering in parallel query plans.</span></span> <span data-ttu-id="0a3be-178">通过在将行传递到另一个运算符（如运算符）之前，通过消除无法生成任何联接记录的键值的行，位图筛选可提高查询的执行速度 `Parallelism` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-178">Bitmap filtering speeds up query execution by eliminating rows with key values that cannot produce any join records before passing rows through another operator such as the `Parallelism` operator.</span></span> <span data-ttu-id="0a3be-179">位图筛选器使用运算符树某部分的表中一组值的简洁表示形式来筛选位于该树另一部分的第二张表中的行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-179">A bitmap filter uses a compact representation of a set of values from a table in one part of the operator tree to filter rows from a second table in another part of the tree.</span></span> <span data-ttu-id="0a3be-180">通过在查询中预先删除不必要的行，后续运算符将处理较少的行，从而提高查询的整体性能。</span><span class="sxs-lookup"><span data-stu-id="0a3be-180">By removing unnecessary rows early in the query, subsequent operators have fewer rows to work with, and the overall performance of the query improves.</span></span> <span data-ttu-id="0a3be-181">优化器将确定位图的选择性何时可满足使用条件以及在哪些运算符上应用筛选器。</span><span class="sxs-lookup"><span data-stu-id="0a3be-181">The optimizer determines when a bitmap is selective enough to be useful and in which operators to apply the filter.</span></span> <span data-ttu-id="0a3be-182">`Bitmap` 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-182">`Bitmap` is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-183">![Bitmap 运算符图标](../../2014/database-engine/media/bitmap-32x.gif "Bitmap 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-183">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap Create`|<span data-ttu-id="0a3be-184">`Bitmap Create` 运算符出现在创建位图的显示计划输出中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-184">The `Bitmap Create` operator appears in the Showplan output where bitmaps are built.</span></span> <span data-ttu-id="0a3be-185">`Bitmap Create` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-185">`Bitmap Create` is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-186">![Bookmark Lookup 运算符图标](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark Lookup 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-186">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Bookmark Lookup`|<span data-ttu-id="0a3be-187">`Bookmark Lookup` 运算符使用书签（行 ID 或聚集键）在表或聚集索引内查找相应的行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-187">The `Bookmark Lookup` operator uses a bookmark (row ID or clustering key) to look up the corresponding row in the table or clustered index.</span></span> <span data-ttu-id="0a3be-188">`Argument`列包含用于查找表或聚集索引中的行的书签标签。</span><span class="sxs-lookup"><span data-stu-id="0a3be-188">The `Argument` column contains the bookmark label used to look up the row in the table or clustered index.</span></span> <span data-ttu-id="0a3be-189">`Argument`列还包含在其中查找行的表或聚集索引的名称。</span><span class="sxs-lookup"><span data-stu-id="0a3be-189">The `Argument` column also contains the name of the table or clustered index in which the row is looked up.</span></span> <span data-ttu-id="0a3be-190">如果列中出现 WITH 预取子句 `Argument` ，则查询处理器已决定在表或聚集索引中查找书签时，使用异步预提取 (预读) 是最佳的。</span><span class="sxs-lookup"><span data-stu-id="0a3be-190">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the table or clustered index.</span></span><br /><br /> <span data-ttu-id="0a3be-191">[!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] 中不使用 `Bookmark Lookup`，</span><span class="sxs-lookup"><span data-stu-id="0a3be-191">`Bookmark Lookup` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span> <span data-ttu-id="0a3be-192">而由 `Clustered Index Seek` 和 `RID Lookup` 提供书签查找功能。</span><span class="sxs-lookup"><span data-stu-id="0a3be-192">Instead, `Clustered Index Seek` and `RID Lookup` provide bookmark lookup functionality.</span></span> <span data-ttu-id="0a3be-193">`Key Lookup` 运算符也提供此功能。</span><span class="sxs-lookup"><span data-stu-id="0a3be-193">The `Key Lookup` operator also provides this functionality.</span></span>|  
|<span data-ttu-id="0a3be-194">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-194">None</span></span>|`Branch Repartition`|<span data-ttu-id="0a3be-195">在并行查询计划中，有时存在迭代器的概念性区域。</span><span class="sxs-lookup"><span data-stu-id="0a3be-195">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="0a3be-196">此类区域中的所有迭代器都可通过并行线程执行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-196">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="0a3be-197">这些区域本身必须串行执行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-197">The regions themselves must be executed serially.</span></span> <span data-ttu-id="0a3be-198">单个区域内的某些 `Parallelism` 迭代器称为 `Branch Repartition`。</span><span class="sxs-lookup"><span data-stu-id="0a3be-198">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="0a3be-199">两个这样的区域边界上的 `Parallelism` 迭代器称为 `Segment Repartition`。</span><span class="sxs-lookup"><span data-stu-id="0a3be-199">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="0a3be-200">`Branch Repartition` 和 `Segment Repartition` 是逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-200">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="0a3be-201">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-201">None</span></span>|`Broadcast`|<span data-ttu-id="0a3be-202">`Broadcast`有一个子节点和*n*个父节点。</span><span class="sxs-lookup"><span data-stu-id="0a3be-202">`Broadcast` has one child node and *n* parent nodes.</span></span> <span data-ttu-id="0a3be-203">`Broadcast` 根据使用者的请求将其输入行发送给多个使用者。</span><span class="sxs-lookup"><span data-stu-id="0a3be-203">`Broadcast` sends its input rows to multiple consumers on demand.</span></span> <span data-ttu-id="0a3be-204">每个使用者都将获得所有行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-204">Each consumer gets all of the rows.</span></span> <span data-ttu-id="0a3be-205">例如，如果所有使用者都是哈希联接的生成端，则将生成 *n* 份哈希表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-205">For example, if all of the consumers are build sides of a hash join, then *n* copies of the hash tables will be built.</span></span>|  
|<span data-ttu-id="0a3be-206">![Build hash 运算符图标](../../2014/database-engine/media/build-hash.gif "Build hash 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-206">![Build hash operator icon](../../2014/database-engine/media/build-hash.gif "Build hash operator icon")</span></span>|`Build Hash`|<span data-ttu-id="0a3be-207">指示为 xVelocity 内存优化的列存储索引生成批处理哈希表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-207">Indicates the build of a batch hash table for an xVelocity memory optimized columnstore index.</span></span>|  
|<span data-ttu-id="0a3be-208">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-208">None</span></span>|`Cache`|<span data-ttu-id="0a3be-209">`Cache`是**假脱机**运算符的专用版本。</span><span class="sxs-lookup"><span data-stu-id="0a3be-209">`Cache` is a specialized version of the **Spool** operator.</span></span> <span data-ttu-id="0a3be-210">它仅存储一行数据。</span><span class="sxs-lookup"><span data-stu-id="0a3be-210">It stores only one row of data.</span></span> <span data-ttu-id="0a3be-211">`Cache` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-211">`Cache` is a logical operator.</span></span> <span data-ttu-id="0a3be-212">[!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] 中不使用 `Cache`，</span><span class="sxs-lookup"><span data-stu-id="0a3be-212">`Cache` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="0a3be-213">![Clustered Index Delete 运算符图标](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered Index Delete 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-213">![Clustered index delete operator icon](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered index delete operator icon")</span></span>|`Clustered Index Delete`|<span data-ttu-id="0a3be-214">`Clustered Index Delete` 运算符从查询执行计划的 Argument 列指定的聚集索引中删除行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-214">The `Clustered Index Delete` operator deletes rows from the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="0a3be-215">如果 Argument 列中存在 WHERE:() 谓词，则仅删除满足该谓词要求的行。`Clustered Index Delete`</span><span class="sxs-lookup"><span data-stu-id="0a3be-215">If a WHERE:() predicate is present in the Argument column, then only those rows that satisfy the predicate are deleted.`Clustered Index Delete`</span></span> <span data-ttu-id="0a3be-216"> 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-216">is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-217">![Clustered Index Insert 运算符图标](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered Index Insert 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-217">![Clustered index insert operator icon](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered index insert operator icon")</span></span>|`Clustered Index Insert`|<span data-ttu-id="0a3be-218">`Clustered Index Insert` Showplan 运算符可将其输入行插入到 Argument 列所指定的聚集索引中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-218">The `Clustered Index Insert` Showplan operator inserts rows from its input into the clustered index specified in the Argument column.</span></span> <span data-ttu-id="0a3be-219">Argument 列还包含一个 SET:() 谓词，用于指示为每一列设置的值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-219">The Argument column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="0a3be-220">如果 `Clustered Index Insert` 插入值没有子项，则插入的行来自 `Insert` 运算符本身。`Clustered Index Insert`</span><span class="sxs-lookup"><span data-stu-id="0a3be-220">If `Clustered Index Insert` has no children for insert values, the row inserted is taken from the `Insert` operator itself.`Clustered Index Insert`</span></span> <span data-ttu-id="0a3be-221"> 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-221">is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-222">![Clustered Index Merge 运算符](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered Index Delete 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-222">![Clustered index merge operator](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered index merge operator")</span></span>|<span data-ttu-id="0a3be-223">**Clustered Index Merge**</span><span class="sxs-lookup"><span data-stu-id="0a3be-223">**Clustered Index Merge**</span></span>|<span data-ttu-id="0a3be-224">**Clustered Index Merge** 运算符可将合并数据流应用于聚集索引。</span><span class="sxs-lookup"><span data-stu-id="0a3be-224">The **Clustered Index Merge** operator applies a merge data stream to a clustered index.</span></span> <span data-ttu-id="0a3be-225">运算符从运算符的列中指定的聚集索引中删除、更新或插入行 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-225">The operator deletes, updates, or inserts rows from the clustered index specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="0a3be-226">执行的实际操作取决于在运算符的列中指定的**ACTION**列的运行时值 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-226">The actual operation performed depends on the runtime value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="0a3be-227">**Clustered Index Merge** 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-227">**Clustered Index Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-228">![Clustered Index Scan 运算符图标](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered Index Insert 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-228">![Clustered index scan operator icon](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered index scan operator icon")</span></span>|`Clustered Index Scan`|<span data-ttu-id="0a3be-229">`Clustered Index Scan` 运算符会扫描查询执行计划的 Argument 列中指定的聚集索引。</span><span class="sxs-lookup"><span data-stu-id="0a3be-229">The `Clustered Index Scan` operator scans the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="0a3be-230">存在可选 WHERE:() 谓词时，则只返回满足该谓词的那些行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-230">When an optional WHERE:() predicate is present, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="0a3be-231">如果 Argument 列包含 ORDERED 子句，则表示查询处理器已请求按聚集索引排列行的顺序返回行输出。</span><span class="sxs-lookup"><span data-stu-id="0a3be-231">If the Argument column contains the ORDERED clause, the query processor has requested that the output of the rows be returned in the order in which the clustered index has sorted it.</span></span> <span data-ttu-id="0a3be-232">如果没有 ORDERED 子句，存储引擎将以最佳方式扫描索引，而无需对输出进行排序。</span><span class="sxs-lookup"><span data-stu-id="0a3be-232">If the ORDERED clause is not present, the storage engine scans the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="0a3be-233">`Clustered Index Scan` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-233">`Clustered Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-234">![Clustered Index Seek 运算符图标](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered Index Seek 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-234">![Clustered index seek operator icon](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered index seek operator icon")</span></span>|`Clustered Index Seek`|<span data-ttu-id="0a3be-235">`Clustered Index Seek` 运算符利用索引的查找功能从聚集索引中检索行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-235">The `Clustered Index Seek` operator uses the seeking ability of indexes to retrieve rows from a clustered index.</span></span> <span data-ttu-id="0a3be-236">`Argument`列包含所使用的聚集索引的名称和 SEEK： ( # A1 谓词。</span><span class="sxs-lookup"><span data-stu-id="0a3be-236">The `Argument` column contains the name of the clustered index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="0a3be-237">存储引擎仅使用索引来处理满足此 SEEK:() 谓词的行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-237">The storage engine uses the index to process only those rows that satisfy this SEEK:() predicate.</span></span> <span data-ttu-id="0a3be-238">它还包括 WHERE:() 谓词，其中存储引擎对满足 SEEK:() 谓词的所有行进行计算，但此操作是可选的，并且不使用索引来完成此过程。</span><span class="sxs-lookup"><span data-stu-id="0a3be-238">It can also include a WHERE:() predicate where the storage engine evaluates against all rows that satisfy the SEEK:() predicate, but this is optional and does not use indexes to complete this process.</span></span><br /><br /> <span data-ttu-id="0a3be-239">如果 `Argument` 该列包含有序子句，则查询处理器已决定必须按聚集索引排序行的顺序返回行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-239">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the clustered index has sorted them.</span></span> <span data-ttu-id="0a3be-240">如果没有 ORDERED 子句，存储引擎将以最佳方式搜索索引，而不对输出进行必要的排序。</span><span class="sxs-lookup"><span data-stu-id="0a3be-240">If the ORDERED clause is not present, the storage engine searches the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="0a3be-241">若允许输出保持顺序，则效率可能比生成非排序输出的效率低。</span><span class="sxs-lookup"><span data-stu-id="0a3be-241">Allowing the output to retain its ordering can be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="0a3be-242">出现关键字 LOOKUP 时，将执行书签查找。</span><span class="sxs-lookup"><span data-stu-id="0a3be-242">When the keyword LOOKUP appears, then a bookmark lookup is being performed.</span></span> <span data-ttu-id="0a3be-243">在 [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] 和更高版本中， `Key Lookup` 运算符提供书签查找功能。</span><span class="sxs-lookup"><span data-stu-id="0a3be-243">In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and later versions, the `Key Lookup` operator provides bookmark lookup functionality.</span></span> <span data-ttu-id="0a3be-244">`Clustered Index Seek` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-244">`Clustered Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-245">![Clustered Index Update 运算符图标](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered Index Insert 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-245">![Clustered index update operator icon](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered index update operator icon")</span></span>|`Clustered Index Update`|<span data-ttu-id="0a3be-246">`Clustered Index Update`运算符更新列中指定的聚集索引中的输入行 `Argument` 。如果出现 WHERE： ( # A1 谓词，则只更新满足此谓词的那些行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-246">The `Clustered Index Update` operator updates input rows in the clustered index specified in the `Argument` column.If a WHERE:() predicate is present, only those rows that satisfy this predicate are updated.</span></span> <span data-ttu-id="0a3be-247">如果存在 SET:() 谓词，则将每个更新的列设置为该值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-247">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="0a3be-248">如果存在 DEFINE:() 谓词，则列出此运算符定义的值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-248">If a DEFINE:() predicate is present, the values that this operator defines are listed.</span></span> <span data-ttu-id="0a3be-249">可以在 SET 子句中、该运算符内的其他位置和该查询内的其他位置引用这些值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-249">These values may be referenced in the SET clause or elsewhere within this operator and elsewhere within this query.</span></span> <span data-ttu-id="0a3be-250">`Clustered Index Update` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-250">`Clustered Index Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-251">![Collapse 运算符图标](../../2014/database-engine/media/collapse-32x.gif "Collapse 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-251">![Collapse operator icon](../../2014/database-engine/media/collapse-32x.gif "Collapse operator icon")</span></span>|`Collapse`|<span data-ttu-id="0a3be-252">`Collapse` 运算符用于优化更新处理。</span><span class="sxs-lookup"><span data-stu-id="0a3be-252">The `Collapse` operator optimizes update processing.</span></span> <span data-ttu-id="0a3be-253">执行更新时，可以将该更新操作拆分（使用 `Split` 运算符）成为删除和插入操作。</span><span class="sxs-lookup"><span data-stu-id="0a3be-253">When an update is performed, it can be split (using the `Split` operator) into a delete and an insert.</span></span> <span data-ttu-id="0a3be-254">`Argument`列包含分组依据： ( # A1 子句，用于指定键列的列表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-254">The `Argument` column contains a GROUP BY:() clause that specifies a list of key columns.</span></span> <span data-ttu-id="0a3be-255">如果查询处理器遇到删除和插入相同键值的相邻行，则会用一个更有效的更新操作替换这些单独的操作。</span><span class="sxs-lookup"><span data-stu-id="0a3be-255">If the query processor encounters adjacent rows that delete and insert the same key values, it replaces these separate operations with a single more efficient update operation.</span></span> <span data-ttu-id="0a3be-256">`Collapse` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-256">`Collapse` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-257">![Columnstore Index Scan](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore Index Scan")</span><span class="sxs-lookup"><span data-stu-id="0a3be-257">![Columnstore Index Scan](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore Index Scan")</span></span>|`Columnstore Index Scan`|<span data-ttu-id="0a3be-258">`Columnstore Index Scan`运算符扫描查询执行计划的列中指定的列存储索引 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-258">The `Columnstore Index Scan` operator scans the columnstore index specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="0a3be-259">![Compute Scalar 运算符图标](../../2014/database-engine/media/compute-scalar-32x.gif "Compute Scalar 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-259">![Compute scalar operator icon](../../2014/database-engine/media/compute-scalar-32x.gif "Compute scalar operator icon")</span></span>|`Compute Scalar`|<span data-ttu-id="0a3be-260">`Compute Scalar`运算符对表达式进行计算，以生成计算出的标量值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-260">The `Compute Scalar` operator evaluates an expression to produce a computed scalar value.</span></span> <span data-ttu-id="0a3be-261">该值可以返回给用户、在查询中的其他位置引用或二者皆可。</span><span class="sxs-lookup"><span data-stu-id="0a3be-261">This may then be returned to the user, referenced elsewhere in the query, or both.</span></span> <span data-ttu-id="0a3be-262">例如，在筛选谓词或联接谓词中就会出现二者皆可的情况。</span><span class="sxs-lookup"><span data-stu-id="0a3be-262">An example of both is in a filter predicate or join predicate.</span></span> <span data-ttu-id="0a3be-263">`Compute Scalar` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-263">`Compute Scalar` is a logical and physical operator.</span></span><br /><br /> <span data-ttu-id="0a3be-264">`Compute Scalar`在 SET STATISTICS XML 生成的显示计划中显示的运算符可能不包含 `RunTimeInformation` 元素。</span><span class="sxs-lookup"><span data-stu-id="0a3be-264">`Compute Scalar` operators that appear in Showplans generated by SET STATISTICS XML might not contain the `RunTimeInformation` element.</span></span> <span data-ttu-id="0a3be-265">在图形显示计划中，当已在 **中选中**“包括实际的执行计划” **选项时，** “实际行” **、** “实际重新绑定次数” **和** “实际重绕次数” **可能不会出现在** “属性” [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]窗口中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-265">In graphical Showplans, **Actual Rows**, **Actual Rebinds**, and **Actual Rewinds** might be absent from the **Properties** window when the **Include Actual Execution Plan** option is selected in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="0a3be-266">当出现这种情况时，意味着虽然编译过的查询计划中使用了这些运算符，但在运行时查询计划中，它们的作用是由其他运算符实现的。</span><span class="sxs-lookup"><span data-stu-id="0a3be-266">When this occurs, it means that although these operators were used in the compiled query plan, their work was performed by other operators in the run-time query plan.</span></span> <span data-ttu-id="0a3be-267">另外，请注意，SET STATISTICS PROFILE 生成的显示计划输出中的执行数等于 SET STATISTICS XML 生成的显示计划中的重新绑定次数和重绕次数的总和。</span><span class="sxs-lookup"><span data-stu-id="0a3be-267">Also note that the number of executes in Showplan output generated by SET STATISTICS PROFILE is equivalent to the sum of rebinds and rewinds in Showplans generated by SET STATISTICS XML.</span></span>|  
|<span data-ttu-id="0a3be-268">![Concatenation 运算符图标](../../2014/database-engine/media/concatenation-32x.gif "Concatenation 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-268">![Concatenation operator icon](../../2014/database-engine/media/concatenation-32x.gif "Concatenation operator icon")</span></span>|<span data-ttu-id="0a3be-269">**Concatenation**</span><span class="sxs-lookup"><span data-stu-id="0a3be-269">**Concatenation**</span></span>|<span data-ttu-id="0a3be-270">**Concatenation** 运算符扫描多个输入，并返回每个扫描的行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-270">The **Concatenation** operator scans multiple inputs, returning each row scanned.</span></span> <span data-ttu-id="0a3be-271">**Concatenation** 通常用于实现 [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL 结构。</span><span class="sxs-lookup"><span data-stu-id="0a3be-271">**Concatenation** is typically used to implement the [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL construct.</span></span> <span data-ttu-id="0a3be-272">**Concatenation** 物理运算符有两个或多个输入，有一个输出。</span><span class="sxs-lookup"><span data-stu-id="0a3be-272">The **Concatenation** physical operator has two or more inputs and one output.</span></span> <span data-ttu-id="0a3be-273">Concatenation 将行从第一个输入流复制到输出流，然后对其他输入流重复进行此操作。</span><span class="sxs-lookup"><span data-stu-id="0a3be-273">Concatenation copies rows from the first input stream to the output stream, then repeats this operation for each additional input stream.</span></span> <span data-ttu-id="0a3be-274">**Concatenation** 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-274">**Concatenation** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-275">![Constant Scan 运算符图标](../../2014/database-engine/media/constant-scan-32x.gif "Constant Scan 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-275">![Constant scan operator icon](../../2014/database-engine/media/constant-scan-32x.gif "Constant scan operator icon")</span></span>|`Constant Scan`|<span data-ttu-id="0a3be-276">`Constant Scan`运算符将一个或多个常量行引入到查询中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-276">The `Constant Scan` operator introduces one or more constant rows into a query.</span></span> <span data-ttu-id="0a3be-277">`Compute Scalar`运算符通常用于 `Constant Scan` 将列添加到由运算符生成的行中 `Constant Scan` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-277">A `Compute Scalar` operator is often used after a `Constant Scan` to add columns to a row produced by the `Constant Scan` operator.</span></span>|  
|<span data-ttu-id="0a3be-278">![Convert（数据库引擎）语言元素图标](../../2014/database-engine/media/convert-32x.gif "Convert（数据库引擎）语言元素图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-278">![Convert (Database Engine) language element icon](../../2014/database-engine/media/convert-32x.gif "Convert (Database Engine) language element icon")</span></span>|`Convert`|<span data-ttu-id="0a3be-279">`Convert` 运算符将标量数据类型转换为另一种类型。</span><span class="sxs-lookup"><span data-stu-id="0a3be-279">The `Convert` operator converts one scalar data type to another.</span></span> <span data-ttu-id="0a3be-280">`Convert` 是一个语言元素。</span><span class="sxs-lookup"><span data-stu-id="0a3be-280">`Convert` is a language element.</span></span>|  
|<span data-ttu-id="0a3be-281">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-281">None</span></span>|`Cross Join`|<span data-ttu-id="0a3be-282">`Cross Join` 运算符将第一个（顶端）输入中的每一行与第二个（底端）输入中的每一行联接在一起。</span><span class="sxs-lookup"><span data-stu-id="0a3be-282">The `Cross Join` operator joins each row from the first (top) input with each row from the second (bottom) input.</span></span> <span data-ttu-id="0a3be-283">`Cross Join` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-283">`Cross Join` is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-284">![Cursor catchall cursor 运算符图标](../../2014/database-engine/media/cursor-catch-all.gif "Cursor catchall cursor 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-284">![Cursor catchall cursor operator icon](../../2014/database-engine/media/cursor-catch-all.gif "Cursor catchall cursor operator icon")</span></span>|`catchall`|<span data-ttu-id="0a3be-285">生成图形显示计划的逻辑找不到迭代器的合适图标时，将显示通用图标。</span><span class="sxs-lookup"><span data-stu-id="0a3be-285">The catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical showplans.</span></span> <span data-ttu-id="0a3be-286">通用图标不一定指示存在错误。</span><span class="sxs-lookup"><span data-stu-id="0a3be-286">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="0a3be-287">有三种通用图标：蓝色（用于迭代器）、橙色（用于游标）和绿色（用于 [!INCLUDE[tsql](../includes/tsql-md.md)] 语言元素）。</span><span class="sxs-lookup"><span data-stu-id="0a3be-287">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language elements).</span></span>|  
|<span data-ttu-id="0a3be-288">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-288">None</span></span>|<span data-ttu-id="0a3be-289">**游标**</span><span class="sxs-lookup"><span data-stu-id="0a3be-289">**Cursor**</span></span>|<span data-ttu-id="0a3be-290">**Cursor** 逻辑运算符和物理运算符用于描述涉及游标操作的查询或更新的执行方式。</span><span class="sxs-lookup"><span data-stu-id="0a3be-290">The **Cursor** logical and physical operators are used to describe how a query or update involving cursor operations is executed.</span></span> <span data-ttu-id="0a3be-291">其中物理运算符描述用于处理游标（如使用键集驱动游标）的物理实现算法。</span><span class="sxs-lookup"><span data-stu-id="0a3be-291">The physical operators describe the physical implementation algorithm used to process the cursor; for example, using a keyset-driven cursor.</span></span> <span data-ttu-id="0a3be-292">游标执行过程的每一步都涉及物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-292">Each step in the execution of a cursor involves a physical operator.</span></span> <span data-ttu-id="0a3be-293">而逻辑运算符描述游标的属性，如游标是只读。</span><span class="sxs-lookup"><span data-stu-id="0a3be-293">The logical operators describe a property of the cursor, such as the cursor is read only.</span></span><br /><br /> <span data-ttu-id="0a3be-294">逻辑运算符包括 Asynchronous、Optimistic、Primary、Read Only、Scroll Locks、Secondary 和 Synchronous。</span><span class="sxs-lookup"><span data-stu-id="0a3be-294">Logical operators include Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, and Secondary and Synchronous.</span></span><br /><br /> <span data-ttu-id="0a3be-295">物理运算符包括 Dynamic、Fetch Query、Keyset、Population Query、Refresh Query 和 Snapshot。</span><span class="sxs-lookup"><span data-stu-id="0a3be-295">Physical operators include Dynamic, Fetch Query, Keyset, Population Query, Refresh Query and Snapshot.</span></span>|  
|<span data-ttu-id="0a3be-296">![Declare 语言元素图标](../../2014/database-engine/media/declare-32x.gif "Declare 语言元素图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-296">![Declare language element icon](../../2014/database-engine/media/declare-32x.gif "Declare language element icon")</span></span>|`Declare`|<span data-ttu-id="0a3be-297">`Declare`运算符分配查询计划中的局部变量。</span><span class="sxs-lookup"><span data-stu-id="0a3be-297">The `Declare`  operator allocates a local variable in the query plan.</span></span> <span data-ttu-id="0a3be-298">`Declare` 是一个语言元素。</span><span class="sxs-lookup"><span data-stu-id="0a3be-298">`Declare` is a language element.</span></span>|  
|<span data-ttu-id="0a3be-299">![Delete（数据库引擎）运算符图标](../../2014/database-engine/media/delete-32x.gif "Delete（数据库引擎）运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-299">![Delete (Database Engine) operator icon](../../2014/database-engine/media/delete-32x.gif "Delete (Database Engine) operator icon")</span></span>|`Delete`|<span data-ttu-id="0a3be-300">`Delete`运算符从满足列中的可选谓词的对象行中删除 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-300">The `Delete` operator deletes from an object rows that satisfy the optional predicate in the `Argument` column.</span></span>|  
|<span data-ttu-id="0a3be-301">![Delete Scan 运算符图标](../../2014/database-engine/media/delete-scan-32x.gif "Delete Scan 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-301">![Delete scan operator icon](../../2014/database-engine/media/delete-scan-32x.gif "Delete scan operator icon")</span></span>|`Deleted Scan`|<span data-ttu-id="0a3be-302">`Deleted Scan` 运算符在触发器中扫描删除的表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-302">The `Deleted Scan` operator scans the deleted table within a trigger.</span></span>|  
|<span data-ttu-id="0a3be-303">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-303">None</span></span>|`Distinct`|<span data-ttu-id="0a3be-304">`Distinct` 运算符可以从行集或值集中删除重复项。</span><span class="sxs-lookup"><span data-stu-id="0a3be-304">The `Distinct` operator removes duplicates from a rowset or from a collection of values.</span></span> <span data-ttu-id="0a3be-305">`Distinct` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-305">`Distinct` is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-306">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-306">None</span></span>|`Distinct Sort`|<span data-ttu-id="0a3be-307">`Distinct Sort`逻辑运算符扫描输入，删除重复项并按指定的列中指定的列进行排序：列的 ( # A1 谓词 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-307">The `Distinct Sort` logical operator scans the input, removing duplicates and sorting by the columns specified in the DISTINCT ORDER BY:() predicate of the `Argument` column.</span></span> <span data-ttu-id="0a3be-308">`Distinct Sort` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-308">`Distinct Sort` is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-309">![Distribute Streams parallelism 运算符图标](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute Streams Parallelism 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-309">![Distribute streams parallelism operator icon](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute streams parallelism operator icon")</span></span>|<span data-ttu-id="0a3be-310">**Distribute Streams**</span><span class="sxs-lookup"><span data-stu-id="0a3be-310">**Distribute Streams**</span></span>|<span data-ttu-id="0a3be-311">**Distribute Streams** 运算符仅用于并行查询计划。</span><span class="sxs-lookup"><span data-stu-id="0a3be-311">The **Distribute Streams** operator is used only in parallel query plans.</span></span> <span data-ttu-id="0a3be-312">**Distribute Streams** 运算符接收记录的单个输入流，并生成多个输出流。</span><span class="sxs-lookup"><span data-stu-id="0a3be-312">The **Distribute Streams** operator takes a single input stream of records and produces multiple output streams.</span></span> <span data-ttu-id="0a3be-313">记录的内容和格式不会改变。</span><span class="sxs-lookup"><span data-stu-id="0a3be-313">The record contents and format are not changed.</span></span> <span data-ttu-id="0a3be-314">输入流中的每个记录都将在某个输出流中显示。</span><span class="sxs-lookup"><span data-stu-id="0a3be-314">Each record from the input stream appears in one of the output streams.</span></span> <span data-ttu-id="0a3be-315">此运算符在输出流中自动保留输入记录的相对顺序。</span><span class="sxs-lookup"><span data-stu-id="0a3be-315">This operator automatically preserves the relative order of the input records in the output streams.</span></span> <span data-ttu-id="0a3be-316">通常情况下，使用哈希操作确定特定输入记录所属的输出流。</span><span class="sxs-lookup"><span data-stu-id="0a3be-316">Usually, hashing is used to decide to which output stream a particular input record belongs.</span></span><br /><br /> <span data-ttu-id="0a3be-317">如果对输出进行了分区，则 `Argument` 列包含分区列： ( # A1 谓词和分区列。</span><span class="sxs-lookup"><span data-stu-id="0a3be-317">If the output is partitioned, then the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.</span></span> <span data-ttu-id="0a3be-318">**Distribute Streams** 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-318">**Distribute Streams** is a logical operator</span></span>|  
|<span data-ttu-id="0a3be-319">![Dynamic Cursor 运算符图标](../../2014/database-engine/media/dynamic-32x.gif "Dynamic Cursor 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-319">![Dynamic cursor operator icon](../../2014/database-engine/media/dynamic-32x.gif "Dynamic cursor operator icon")</span></span>|`Dynamic`|<span data-ttu-id="0a3be-320">`Dynamic` 运算符使用可以查看其他游标所做的任何更改的游标。</span><span class="sxs-lookup"><span data-stu-id="0a3be-320">The `Dynamic` operator uses a cursor that can see all changes made by others.</span></span>|  
|<span data-ttu-id="0a3be-321">![Spool 运算符图标](../../2014/database-engine/media/spool-32x.gif "Spool 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-321">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="0a3be-322">**Eager Spool**</span><span class="sxs-lookup"><span data-stu-id="0a3be-322">**Eager Spool**</span></span>|<span data-ttu-id="0a3be-323">**预先假脱机**运算符获取整个输入，并将每行存储在数据库中存储的隐藏临时对象中 `tempdb` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-323">The **Eager Spool** operator takes the entire input, storing each row in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="0a3be-324">如果对运算符进行倒带 (例如， `Nested Loops` 运算符) 但不需要重新绑定，则使用假脱机数据，而不是重新扫描输入。</span><span class="sxs-lookup"><span data-stu-id="0a3be-324">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="0a3be-325">如果需要重新绑定，则将放弃假脱机数据，并通过重新扫描（重新绑定的）输入重新生成假脱机对象。</span><span class="sxs-lookup"><span data-stu-id="0a3be-325">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="0a3be-326">**Eager Spool** 运算符按“急切”方式生成自己的假脱机文件：当假脱机的父运算符请求第一行时，假脱机运算符将获取所有来自其输入运算符的行并将其存储在假脱机中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-326">The **Eager Spool** operator builds its spool file in an "eager" manner: when the spool's parent operator asks for the first row, the spool operator consumes all rows from its input operator and stores them in the spool.</span></span> <span data-ttu-id="0a3be-327">**Eager Spool** 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-327">**Eager Spool** is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-328">![Fetch Query Cursor 运算符图标](../../2014/database-engine/media/fetch-query-32x.gif "Fetch Query Cursor 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-328">![Fetch query cursor operator icon](../../2014/database-engine/media/fetch-query-32x.gif "Fetch query cursor operator icon")</span></span>|`Fetch Query`|<span data-ttu-id="0a3be-329">当对游标发出提取命令时，`Fetch Query` 运算符将检索行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-329">The `Fetch Query` operator retrieves rows when a fetch is issued against a cursor.</span></span>|  
|<span data-ttu-id="0a3be-330">![Filter（数据库引擎）运算符图标](../../2014/database-engine/media/filter-32x.gif "Filter（数据库引擎）运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-330">![Filter (Database Engine) operator icon](../../2014/database-engine/media/filter-32x.gif "Filter (Database Engine) operator icon")</span></span>|<span data-ttu-id="0a3be-331">**筛选器**</span><span class="sxs-lookup"><span data-stu-id="0a3be-331">**Filter**</span></span>|<span data-ttu-id="0a3be-332">**Filter**运算符扫描输入，仅返回满足列中出现 (谓词) 的筛选表达式的那些行 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-332">The **Filter** operator scans the input, returning only those rows that satisfy the filter expression (predicate) that appears in the `Argument` column.</span></span>|  
|<span data-ttu-id="0a3be-333">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-333">None</span></span>|`Flow Distinct`|<span data-ttu-id="0a3be-334">`Flow Distinct` 逻辑运算符用于通过扫描输入来删除重复项。</span><span class="sxs-lookup"><span data-stu-id="0a3be-334">The `Flow Distinct` logical operator scans the input, removing duplicates.</span></span> <span data-ttu-id="0a3be-335">虽然 `Distinct` 运算符在生成任何输出之前都使用所有输入，但**FlowDistinct**运算符会在从输入 (获取行时返回每行，除非该行是重复的（在这种情况下，它将被丢弃) 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-335">Whereas the `Distinct` operator consumes all input before producing any output, the **FlowDistinct** operator returns each row as it is obtained from the input (unless that row is a duplicate, in which case it is discarded).</span></span>|  
|<span data-ttu-id="0a3be-336">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-336">None</span></span>|`Full Outer Join`|<span data-ttu-id="0a3be-337">`Full Outer Join` 逻辑运算符从第一个（顶端）输入中与第二个（底端）输入相联接的行中返回每个满足联接谓词的行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-337">The `Full Outer Join` logical operator returns each row satisfying the join predicate from the first (top) input joined with each row from the second (bottom) input.</span></span> <span data-ttu-id="0a3be-338">它还可以从下列输入返回行：</span><span class="sxs-lookup"><span data-stu-id="0a3be-338">It also returns rows from:</span></span><br /><br /> <span data-ttu-id="0a3be-339">\- 在第二个输入中没有匹配项的第一个输入。</span><span class="sxs-lookup"><span data-stu-id="0a3be-339">-The first input that had no matches in the second input.</span></span><br /><br /> <span data-ttu-id="0a3be-340">\- 在第一个输入中没有匹配项的第二个输入。</span><span class="sxs-lookup"><span data-stu-id="0a3be-340">-The second input that had no matches in the first input.</span></span><br /><br /> <br /><br /> <span data-ttu-id="0a3be-341">不包含匹配值的输入将作为空值返回。</span><span class="sxs-lookup"><span data-stu-id="0a3be-341">The input that does not contain the matching values is returned as a null value.</span></span> <span data-ttu-id="0a3be-342">`Full Outer Join` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-342">`Full Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-343">![Gather Streams parallelism 运算符图标](../../2014/database-engine/media/parallelism-32x.gif "Gather Streams Parallelism 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-343">![Gather streams parallelism operator icon](../../2014/database-engine/media/parallelism-32x.gif "Gather streams parallelism operator icon")</span></span>|<span data-ttu-id="0a3be-344">**Gather Streams**</span><span class="sxs-lookup"><span data-stu-id="0a3be-344">**Gather Streams**</span></span>|<span data-ttu-id="0a3be-345">**Gather Streams** 运算符仅用在并行查询计划中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-345">The **Gather Streams** operator is only used in parallel query plans.</span></span> <span data-ttu-id="0a3be-346">**Gather Streams** 运算符处理几个输入流并通过组合这几个输入流生成单个记录输出流。</span><span class="sxs-lookup"><span data-stu-id="0a3be-346">The **Gather Streams** operator consumes several input streams and produces a single output stream of records by combining the input streams.</span></span> <span data-ttu-id="0a3be-347">记录的内容和格式不会改变。</span><span class="sxs-lookup"><span data-stu-id="0a3be-347">The record contents and format are not changed.</span></span> <span data-ttu-id="0a3be-348">如果此运算符保留顺序，则所有的输入流都必须有序。</span><span class="sxs-lookup"><span data-stu-id="0a3be-348">If this operator is order preserving, all input streams must be ordered.</span></span> <span data-ttu-id="0a3be-349">如果输出已排序，则 `Argument` 列包含 ORDER BY： ( # A1 谓词以及要排序的列的名称。</span><span class="sxs-lookup"><span data-stu-id="0a3be-349">If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the names of columns being ordered.</span></span> <span data-ttu-id="0a3be-350">**Gather Streams** 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-350">**Gather Streams** is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-351">![Hash Match 运算符图标](../../2014/database-engine/media/hash-match-32x.gif "Hash Match 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-351">![Hash match operator icon](../../2014/database-engine/media/hash-match-32x.gif "Hash match operator icon")</span></span>|`Hash Match`|<span data-ttu-id="0a3be-352">`Hash Match` 运算符通过计算其生成输入中每行的哈希值生成哈希表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-352">The `Hash Match` operator builds a hash table by computing a hash value for each row from its build input.</span></span> <span data-ttu-id="0a3be-353">哈希： ( # A1 谓词，其中包含用于创建哈希值的列的列表显示在 `Argument` 列中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-353">A HASH:() predicate with a list of columns used to create a hash value appears in the `Argument` column.</span></span> <span data-ttu-id="0a3be-354">然后，该谓词为每个探测行（如果适用）计算哈希值（使用相同的哈希函数）并在哈希表内查找匹配项。</span><span class="sxs-lookup"><span data-stu-id="0a3be-354">Then, for each probe row (as applicable), it computes a hash value (using the same hash function) and looks in the hash table for matches.</span></span> <span data-ttu-id="0a3be-355">如果存在残留谓词 (由残留标识 ( # A2 `Argument`) ，则还必须对要视为匹配的行满足此谓词。</span><span class="sxs-lookup"><span data-stu-id="0a3be-355">If a residual predicate is present (identified by RESIDUAL:() in the `Argument` column), that predicate must also be satisfied for rows to be considered a match.</span></span> <span data-ttu-id="0a3be-356">行为取决于所执行的逻辑操作：</span><span class="sxs-lookup"><span data-stu-id="0a3be-356">Behavior depends on the logical operation being performed:</span></span><br /><br /> <span data-ttu-id="0a3be-357">对于联接，使用第一个（顶端）输入生成哈希表，使用第二个（底端）输入探测哈希表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-357">For any joins, use the first (top) input to build the hash table and the second (bottom) input to probe the hash table.</span></span> <span data-ttu-id="0a3be-358">按联接类型规定的模式输出匹配项（或不匹配项）。</span><span class="sxs-lookup"><span data-stu-id="0a3be-358">Output matches (or nonmatches) as dictated by the join type.</span></span> <span data-ttu-id="0a3be-359">如果多个联接使用相同的联接列，这些操作将分组为一个哈希组。</span><span class="sxs-lookup"><span data-stu-id="0a3be-359">If multiple joins use the same join column, these operations are grouped into a hash team.</span></span><br /><br /> <span data-ttu-id="0a3be-360">对于非重复或聚合运算符，使用输入生成哈希表（删除重复项并计算聚合表达式）。</span><span class="sxs-lookup"><span data-stu-id="0a3be-360">For the distinct or aggregate operators, use the input to build the hash table (removing duplicates and computing any aggregate expressions).</span></span> <span data-ttu-id="0a3be-361">生成哈希表时，扫描该表并输出所有项。</span><span class="sxs-lookup"><span data-stu-id="0a3be-361">When the hash table is built, scan the table and output all entries.</span></span><br /><br /> <span data-ttu-id="0a3be-362">对于 union 运算符，使用第一个输入生成哈希表（删除重复项）。</span><span class="sxs-lookup"><span data-stu-id="0a3be-362">For the union operator, use the first input to build the hash table (removing duplicates).</span></span> <span data-ttu-id="0a3be-363">使用第二个输入（它必须没有重复项）探测哈希表，返回所有没有匹配项的行，然后扫描该哈希表并返回所有项。</span><span class="sxs-lookup"><span data-stu-id="0a3be-363">Use the second input (which must have no duplicates) to probe the hash table, returning all rows that have no matches, then scan the hash table and return all entries.</span></span><br /><br /> <br /><br /> <span data-ttu-id="0a3be-364">`Hash Match` 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-364">`Hash Match` is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-365">![If 语言元素图标](../../2014/database-engine/media/if-32x.gif "If 语言元素图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-365">![If language element icon](../../2014/database-engine/media/if-32x.gif "If language element icon")</span></span>|`If`|<span data-ttu-id="0a3be-366">`If` 运算符执行基于表达式的有条件处理。</span><span class="sxs-lookup"><span data-stu-id="0a3be-366">The `If` operator carries out conditional processing based on an expression.</span></span> <span data-ttu-id="0a3be-367">`If` 是一个语言元素。</span><span class="sxs-lookup"><span data-stu-id="0a3be-367">`If` is a language element.</span></span>|  
|<span data-ttu-id="0a3be-368">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-368">None</span></span>|`Inner Join`|<span data-ttu-id="0a3be-369">`Inner Join` 逻辑运算符返回满足第一个（顶端）输入与第二个（底端）输入所组成的联接的每一行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-369">The `Inner Join` logical operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span>|  
|<span data-ttu-id="0a3be-370">![Insert（数据库引擎）运算符图标](../../2014/database-engine/media/insert-32x.gif "Insert（数据库引擎）运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-370">![Insert (Database Engine) operator icon](../../2014/database-engine/media/insert-32x.gif "Insert (Database Engine) operator icon")</span></span>|`Insert`|<span data-ttu-id="0a3be-371">`Insert`逻辑运算符将其输入中的每一行插入到在列中指定的对象 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-371">The `Insert` logical operator inserts each row from its input into the object specified in the `Argument` column.</span></span> <span data-ttu-id="0a3be-372">相应的物理运算符为 `Table Insert`、`Index Insert` 或 `Clustered Index Insert` 运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-372">The physical operator is either the `Table Insert`, `Index Insert`, or `Clustered Index Insert` operator.</span></span>|  
|<span data-ttu-id="0a3be-373">![Inserted Scan 运算符图标](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted Scan 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-373">![Inserted scan operator icon](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted scan operator icon")</span></span>|<span data-ttu-id="0a3be-374">**Inserted Scan**</span><span class="sxs-lookup"><span data-stu-id="0a3be-374">**Inserted Scan**</span></span>|<span data-ttu-id="0a3be-375">**Inserted Scan** 运算符扫描 **插入的** 表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-375">The **Inserted Scan** operator scans the **inserted** table.</span></span> <span data-ttu-id="0a3be-376">**Inserted Scan** 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-376">**Inserted Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-377">![Intrinsic 语言元素图标](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic 语言元素图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-377">![Intrinsic language element icon](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic language element icon")</span></span>|`Intrinsic`|<span data-ttu-id="0a3be-378">`Intrinsic` 运算符调用内部 [!INCLUDE[tsql](../includes/tsql-md.md)] 函数。</span><span class="sxs-lookup"><span data-stu-id="0a3be-378">The `Intrinsic` operator invokes an internal [!INCLUDE[tsql](../includes/tsql-md.md)] function.</span></span> <span data-ttu-id="0a3be-379">`Intrinsic` 是一个语言元素。</span><span class="sxs-lookup"><span data-stu-id="0a3be-379">`Intrinsic` is a language element.</span></span>|  
|<span data-ttu-id="0a3be-380">![Iterator Catchall 运算符图标](../../2014/database-engine/media/iterator-catch-all.gif "Iterator Catchall 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-380">![Iterator catchall operator icon](../../2014/database-engine/media/iterator-catch-all.gif "Iterator catchall operator icon")</span></span>|`Iterator`|<span data-ttu-id="0a3be-381">生成图形显示计划的逻辑找不到 `Iterator` 的合适图标时，将显示通用图标。</span><span class="sxs-lookup"><span data-stu-id="0a3be-381">The `Iterator` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="0a3be-382">通用图标不一定指示存在错误。</span><span class="sxs-lookup"><span data-stu-id="0a3be-382">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="0a3be-383">有三种通用图标：蓝色（用于迭代器）、橙色（用于游标）和绿色（用于 [!INCLUDE[tsql](../includes/tsql-md.md)] 语言构造）。</span><span class="sxs-lookup"><span data-stu-id="0a3be-383">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="0a3be-384">![Bookmark Lookup 运算符图标](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark Lookup 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-384">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Key Lookup`|<span data-ttu-id="0a3be-385">`Key Lookup`运算符是对具有聚集索引的表的书签查找。</span><span class="sxs-lookup"><span data-stu-id="0a3be-385">The `Key Lookup` operator is a bookmark lookup on a table with a clustered index.</span></span> <span data-ttu-id="0a3be-386">`Argument`列包含聚集索引的名称和用于在聚集索引中查找行的聚集键。</span><span class="sxs-lookup"><span data-stu-id="0a3be-386">The `Argument` column contains the name of the clustered index and the clustering key used to look up the row in the clustered index.</span></span> <span data-ttu-id="0a3be-387">`Key Lookup`始终附带 `Nested Loops` 运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-387">`Key Lookup` is always accompanied by a `Nested Loops` operator.</span></span> <span data-ttu-id="0a3be-388">如果列中显示了 WITH 预取子句 `Argument` ，则查询处理器已决定在聚集索引中查找书签时，最好使用异步预提取 (预读) 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-388">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the clustered index.</span></span><br /><br /> <span data-ttu-id="0a3be-389">`Key Lookup`在查询计划中使用运算符指示查询可能会从性能优化中获益。</span><span class="sxs-lookup"><span data-stu-id="0a3be-389">The use of a `Key Lookup` operator in a query plan indicates that the query might benefit from performance tuning.</span></span> <span data-ttu-id="0a3be-390">例如，添加涵盖索引可能会提高查询性能。</span><span class="sxs-lookup"><span data-stu-id="0a3be-390">For example, query performance might be improved by adding a covering index.</span></span>|  
|<span data-ttu-id="0a3be-391">![Keyset Cursor 运算符图标](../../2014/database-engine/media/keyset-32x.gif "Keyset Cursor 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-391">![Keyset cursor operator icon](../../2014/database-engine/media/keyset-32x.gif "Keyset cursor operator icon")</span></span>|`Keyset`|<span data-ttu-id="0a3be-392">`Keyset` 运算符使用的游标可用于查看其他用户所做的更新，而不能查看其他用户所做的插入。</span><span class="sxs-lookup"><span data-stu-id="0a3be-392">The `Keyset` operator uses a cursor that can see updates, but not inserts made by others.</span></span>|  
|<span data-ttu-id="0a3be-393">![语言元素通用图标](../../2014/database-engine/media/language-construct-catch-all.gif "语言元素通用图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-393">![Language element catchall icon](../../2014/database-engine/media/language-construct-catch-all.gif "Language element catchall icon")</span></span>|`Language Element`|<span data-ttu-id="0a3be-394">生成图形显示计划的逻辑找不到 `Language Element` 的合适图标时，将显示通用图标。</span><span class="sxs-lookup"><span data-stu-id="0a3be-394">The `Language Element` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="0a3be-395">通用图标不一定指示存在错误。</span><span class="sxs-lookup"><span data-stu-id="0a3be-395">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="0a3be-396">有三种通用图标：蓝色（用于迭代器）、橙色（用于游标）和绿色（用于 [!INCLUDE[tsql](../includes/tsql-md.md)] 语言构造）。</span><span class="sxs-lookup"><span data-stu-id="0a3be-396">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="0a3be-397">![Spool 运算符图标](../../2014/database-engine/media/spool-32x.gif "Spool 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-397">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="0a3be-398">**Lazy Spool**</span><span class="sxs-lookup"><span data-stu-id="0a3be-398">**Lazy Spool**</span></span>|<span data-ttu-id="0a3be-399">**惰性假脱机**逻辑运算符将其输入中的每一行存储到数据库中存储的隐藏临时对象中 `tempdb` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-399">The **Lazy Spool** logical operator stores each row from its input in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="0a3be-400">如果对运算符进行倒带 (例如， `Nested Loops` 运算符) 但不需要重新绑定，则使用假脱机数据，而不是重新扫描输入。</span><span class="sxs-lookup"><span data-stu-id="0a3be-400">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="0a3be-401">如果需要重新绑定，则将放弃假脱机数据，并通过重新扫描（重新绑定的）输入重新生成假脱机对象。</span><span class="sxs-lookup"><span data-stu-id="0a3be-401">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="0a3be-402">**Lazy Spool** 运算符以“迟缓”方式生成其假脱机文件，即每当假脱机父运算符请求一行时，假脱机运算符便从其输入运算符获取一行，然后将该行存储在假脱机中，而不是一次处理所有行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-402">The **Lazy Spool** operator builds its spool file in a "lazy" manner, that is, each time the spool's parent operator asks for a row, the spool operator gets a row from its input operator and stores it in the spool, rather than consuming all rows at once.</span></span> <span data-ttu-id="0a3be-403">Lazy Spool 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-403">Lazy Spool is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-404">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-404">None</span></span>|`Left Anti Semi Join`|<span data-ttu-id="0a3be-405">当第二个（底端）输入中没有匹配行时，`Left Anti Semi Join` 运算符返回第一个（顶端）输入中的每一行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-405">The `Left Anti Semi Join` operator returns each row from the first (top) input when there is no matching row in the second (bottom) input.</span></span> <span data-ttu-id="0a3be-406">如果列中不存在任何联接谓词 `Argument` ，则每行都是一个匹配行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-406">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="0a3be-407">`Left Anti Semi Join` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-407">`Left Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-408">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-408">None</span></span>|`Left Outer Join`|<span data-ttu-id="0a3be-409">`Left Outer Join` 运算符返回满足第一个（顶端）输入与第二个（底端）输入联接的每一行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-409">The `Left Outer Join` operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span> <span data-ttu-id="0a3be-410">它还返回任何在第二个输入中没有匹配行的第一个输入中的行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-410">It also returns any rows from the first input that had no matching rows in the second input.</span></span> <span data-ttu-id="0a3be-411">第二个输入中的非匹配行作为空值返回。</span><span class="sxs-lookup"><span data-stu-id="0a3be-411">The nonmatching rows in the second input are returned as null values.</span></span> <span data-ttu-id="0a3be-412">如果列中不存在任何联接谓词 `Argument` ，则每行都是一个匹配行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-412">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="0a3be-413">`Left Outer Join` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-413">`Left Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-414">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-414">None</span></span>|`Left Semi Join`|<span data-ttu-id="0a3be-415">当第二个（底端）输入中有匹配行时，`Left Semi Join` 运算符返回第一个（顶端）输入中的每行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-415">The `Left Semi Join` operator returns each row from the first (top) input when there is a matching row in the second (bottom) input.</span></span> <span data-ttu-id="0a3be-416">如果列中不存在任何联接谓词 `Argument` ，则每行都是一个匹配行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-416">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="0a3be-417">`Left Semi Join` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-417">`Left Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-418">![Log Row Scan 运算符图标](../../2014/database-engine/media/log-row-scan-32x.gif "Log Row Scan 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-418">![Log row scan operator icon](../../2014/database-engine/media/log-row-scan-32x.gif "Log row scan operator icon")</span></span>|`Log Row Scan`|<span data-ttu-id="0a3be-419">`Log Row Scan` 运算符用于扫描事务日志。</span><span class="sxs-lookup"><span data-stu-id="0a3be-419">The `Log Row Scan` operator scans the transaction log.</span></span> <span data-ttu-id="0a3be-420">`Log Row Scan` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-420">`Log Row Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-421">![Merge Interval 运算符图标](../../2014/database-engine/media/merge-interval-32x.gif "Merge Interval 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-421">![Merge interval operator icon](../../2014/database-engine/media/merge-interval-32x.gif "Merge interval operator icon")</span></span>|`Merge Interval`|<span data-ttu-id="0a3be-422">`Merge Interval` 运算符可合并多个（可能重叠的）间隔以得出最小的不重叠间隔，然后将其用于查找索引项。</span><span class="sxs-lookup"><span data-stu-id="0a3be-422">The `Merge Interval` operator merges multiple (potentially overlapping) intervals to produce minimal, nonoverlapping intervals that are then used to seek index entries.</span></span> <span data-ttu-id="0a3be-423">此运算符通常出现在一个或多个运算符 `Compute Scalar` 上 `Constant Scan` ，后者用于构造此运算符所合并)  (表示为行中的列的间隔。</span><span class="sxs-lookup"><span data-stu-id="0a3be-423">This operator typically appears above one or more `Compute Scalar` operators over `Constant Scan` operators, which construct the intervals (represented as columns in a row) that this operator merges.</span></span> <span data-ttu-id="0a3be-424">`Merge Interval` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-424">`Merge Interval` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-425">![Merge Join 运算符图标](../../2014/database-engine/media/merge-join-32x.gif "Merge Join 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-425">![Merge join operator icon](../../2014/database-engine/media/merge-join-32x.gif "Merge join operator icon")</span></span>|<span data-ttu-id="0a3be-426">**合并联接**</span><span class="sxs-lookup"><span data-stu-id="0a3be-426">**Merge Join**</span></span>|<span data-ttu-id="0a3be-427">**Merge Join** 运算符执行内部联接、左外部联接、左半部联接、左反半部联接、右外部联接、右半部联接、右反半部联接和联合逻辑运算。</span><span class="sxs-lookup"><span data-stu-id="0a3be-427">The **Merge Join** operator performs the inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join, and union logical operations.</span></span><br /><br /> <span data-ttu-id="0a3be-428">在 `Argument` 列中， **merge Join**运算符包含 merge：如果操作执行一对多联接或多对多合并，则 ( # A1 谓词：如果操作执行多对多联接，则 ( # A3 谓词。</span><span class="sxs-lookup"><span data-stu-id="0a3be-428">In the `Argument` column, the **Merge Join** operator contains a MERGE:() predicate if the operation is performing a one-to-many join, or a MANY-TO-MANY MERGE:() predicate if the operation is performing a many-to-many join.</span></span> <span data-ttu-id="0a3be-429">`Argument`列还包括用于执行操作的列的逗号分隔列表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-429">The `Argument` column also includes a comma-separated list of columns used to perform the operation.</span></span> <span data-ttu-id="0a3be-430">**Merge Join** 运算符要求在各自的列上对两个输入进行排序，这可以通过在查询计划中插入显式排序操作来实现。</span><span class="sxs-lookup"><span data-stu-id="0a3be-430">The **Merge Join** operator requires two inputs sorted on their respective columns, possibly by inserting explicit sort operations into the query plan.</span></span> <span data-ttu-id="0a3be-431">如果不需要显式排序（例如，如果数据库内有合适的 B 树索引或可以对多个操作（如合并联接和对汇总分组）使用排序顺序），则合并联接尤其有效。</span><span class="sxs-lookup"><span data-stu-id="0a3be-431">Merge join is particularly effective if explicit sorting is not required, for example, if there is a suitable B-tree index in the database or if the sort order can be exploited for multiple operations, such as a merge join and grouping with roll up.</span></span> <span data-ttu-id="0a3be-432">**Merge Join** 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-432">**Merge Join** is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-433">![Nested Loops 运算符图标](../../2014/database-engine/media/nested-loops-32x.gif "Nested Loops 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-433">![Nested loops operator icon](../../2014/database-engine/media/nested-loops-32x.gif "Nested loops operator icon")</span></span>|`Nested Loops`|<span data-ttu-id="0a3be-434">`Nested Loops` 运算符执行内部联接、左外部联接、左半部联接和左反半部联接逻辑运算。</span><span class="sxs-lookup"><span data-stu-id="0a3be-434">The `Nested Loops` operator performs the inner join, left outer join, left semi join, and left anti semi join logical operations.</span></span> <span data-ttu-id="0a3be-435">嵌套循环联接通常使用索引，针对外部表的每一行在内部表中执行搜索。</span><span class="sxs-lookup"><span data-stu-id="0a3be-435">Nested loops joins perform a search on the inner table for each row of the outer table, typically using an index.</span></span> <span data-ttu-id="0a3be-436">查询处理器根据预计的开销来决定是否对外部输入进行排序，以改进内部输入索引上的搜索定位。</span><span class="sxs-lookup"><span data-stu-id="0a3be-436">The query processor decides, based on anticipated costs, whether to sort the outer input in order to improve locality of the searches on the index over the inner input.</span></span> <span data-ttu-id="0a3be-437">根据所执行的逻辑操作，满足列中的 (可选) 谓词的所有行 `Argument` 都将返回。</span><span class="sxs-lookup"><span data-stu-id="0a3be-437">Any rows that satisfy the (optional) predicate in the `Argument` column are returned as applicable, based on the logical operation being performed.</span></span> <span data-ttu-id="0a3be-438">`Nested Loops` 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-438">`Nested Loops` is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-439">![Nonclustered Index Delete 运算符图标](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered Index Delete 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-439">![Nonclustered index delete operator icon](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered index delete operator icon")</span></span>|`Nonclustered Index Delete`|<span data-ttu-id="0a3be-440">`Nonclustered Index Delete`运算符删除列中指定的非聚集索引中的输入行 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-440">The `Nonclustered Index Delete` operator deletes input rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="0a3be-441">`Nonclustered Index Delete` 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-441">`Nonclustered Index Delete` is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-442">![Nonclustered Index Insert 运算符图标](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered Index Insert 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-442">![Nonclustered index insert operator icon](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered index insert operator icon")</span></span>|`Index Insert`|<span data-ttu-id="0a3be-443">`Index Insert`运算符将其输入中的行插入列中指定的非聚集索引 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-443">The `Index Insert` operator inserts rows from its input into the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="0a3be-444">`Argument` 列还包含一个 SET:() 谓词，用于指示为每一列设置的值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-444">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="0a3be-445">`Index Insert` 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-445">`Index Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-446">![Nonclustered Index Scan 运算符图标](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered Index Scan 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-446">![Nonclustered index scan operator icon](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered index scan operator icon")</span></span>|`Index Scan`|<span data-ttu-id="0a3be-447">`Index Scan`运算符从列中指定的非聚集索引中检索所有行 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-447">The `Index Scan` operator retrieves all rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="0a3be-448">如果列中出现可选 WHERE： ( # A1 谓词 `Argument` ，则仅返回满足该谓词的那些行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-448">If an optional WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="0a3be-449">`Index Scan` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-449">`Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-450">![Nonclustered Index Seek 运算符图标](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered Index Seek 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-450">![Nonclustered index seek operator icon](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered index seek operator icon")</span></span>|`Index Seek`|<span data-ttu-id="0a3be-451">`Index Seek` 运算符利用索引的查找功能从非聚集索引中检索行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-451">The `Index Seek` operator uses the seeking ability of indexes to retrieve rows from a nonclustered index.</span></span> <span data-ttu-id="0a3be-452">`Argument`列包含所使用的非聚集索引的名称。</span><span class="sxs-lookup"><span data-stu-id="0a3be-452">The `Argument` column contains the name of the nonclustered index being used.</span></span> <span data-ttu-id="0a3be-453">它还包括 SEEK:() 谓词。</span><span class="sxs-lookup"><span data-stu-id="0a3be-453">It also contains the SEEK:() predicate.</span></span> <span data-ttu-id="0a3be-454">存储引擎仅使用索引来处理满足 SEEK:() 谓词的行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-454">The storage engine uses the index to process only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="0a3be-455">它可能还包含一个 WHERE:() 谓词，其中存储引擎对满足 SEEK:() 谓词的所有行进行计算（不使用索引来完成）。</span><span class="sxs-lookup"><span data-stu-id="0a3be-455">It optionally may include a WHERE:() predicate, which the storage engine will evaluate against all rows that satisfy the SEEK:() predicate (it does not use the indexes to do this).</span></span> <span data-ttu-id="0a3be-456">如果 `Argument` 该列包含有序子句，则查询处理器已决定必须按非聚集索引排序行的顺序返回行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-456">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the nonclustered index has sorted them.</span></span> <span data-ttu-id="0a3be-457">如果没有 ORDERED 子句，则存储引擎将以最佳方式（不保证对输出排序）搜索索引。</span><span class="sxs-lookup"><span data-stu-id="0a3be-457">If the ORDERED clause is not present, the storage engine searches the index in the optimal way (which does not guarantee that the output will be sorted).</span></span> <span data-ttu-id="0a3be-458">如果让输出保持其顺序，则效率可能低于生成非排序输出。</span><span class="sxs-lookup"><span data-stu-id="0a3be-458">Allowing the output to retain its ordering may be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="0a3be-459">`Index Seek` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-459">`Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-460">![Nonclustered Index Spool 运算符图标](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered Index Spool 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-460">![Nonclustered index spool operator icon](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered index spool operator icon")</span></span>|<span data-ttu-id="0a3be-461">**Index Spool**</span><span class="sxs-lookup"><span data-stu-id="0a3be-461">**Index Spool**</span></span>|<span data-ttu-id="0a3be-462">**索引假脱机**运算符包含查找：列中 ( # A1 谓词 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-462">The **Index Spool** physical operator contains a SEEK:() predicate in the `Argument` column.</span></span> <span data-ttu-id="0a3be-463">**索引假脱机**运算符扫描其输入行，将每行的副本放入隐藏的假脱机文件中 (存储在数据库中， `tempdb` 并且仅在查询) 的生存期内存在，并为行生成非聚集索引。</span><span class="sxs-lookup"><span data-stu-id="0a3be-463">The **Index Spool** operator scans its input rows, placing a copy of each row in a hidden spool file (stored in the `tempdb` database and existing only for the lifetime of the query), and builds a nonclustered index on the rows.</span></span> <span data-ttu-id="0a3be-464">这样可以使用索引的查找功能来仅输出那些满足 SEEK:() 谓词的行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-464">This allows you to use the seeking capability of indexes to output only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="0a3be-465">如果对运算符进行倒带 (例如， `Nested Loops` 运算符) 但不需要重新绑定，则使用假脱机数据，而不是重新扫描输入。</span><span class="sxs-lookup"><span data-stu-id="0a3be-465">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span>|  
|<span data-ttu-id="0a3be-466">![Nonclustered Index Update 运算符图标](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered Index Update 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-466">![Nonclustered index update operator icon](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered index update operator icon")</span></span>|`Nonclustered Index Update`|<span data-ttu-id="0a3be-467">`Nonclustered Index Update`物理运算符在列中指定的非聚集索引中更新其输入中的行 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-467">The `Nonclustered Index Update` physical operator updates rows from its input in the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="0a3be-468">如果存在 SET:() 谓词，则将每个更新的列设置为该值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-468">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="0a3be-469">`Nonclustered Index Update` 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-469">`Nonclustered Index Update` is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-470">![Online Index Insert 运算符图标](../../2014/database-engine/media/online-index-32x.gif "Online Index Insert 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-470">![Online index insert operator icon](../../2014/database-engine/media/online-index-32x.gif "Online index insert operator icon")</span></span>|<span data-ttu-id="0a3be-471">**Online Index Insert**</span><span class="sxs-lookup"><span data-stu-id="0a3be-471">**Online Index Insert**</span></span>|<span data-ttu-id="0a3be-472">**Online Index Insert** 物理运算符指示索引创建、更改或删除操作是在线执行的。</span><span class="sxs-lookup"><span data-stu-id="0a3be-472">The **Online Index Insert** physical operator indicates that an index create, alter, or drop operation is performed online.</span></span> <span data-ttu-id="0a3be-473">也就是说，基础表数据在索引操作期间仍然对用户可用。</span><span class="sxs-lookup"><span data-stu-id="0a3be-473">That is, the underlying table data remains available to users during the index operation.</span></span>|  
|<span data-ttu-id="0a3be-474">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-474">None</span></span>|`Parallelism`|<span data-ttu-id="0a3be-475">`Parallelism`运算符执行分发流、收集流和对流进行逻辑操作。</span><span class="sxs-lookup"><span data-stu-id="0a3be-475">The `Parallelism` operator performs the distribute streams, gather streams, and repartition streams logical operations.</span></span> <span data-ttu-id="0a3be-476">`Argument`列可以包含分区列： ( # A1 谓词，其中包含要分区的列的逗号分隔列表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-476">The `Argument` columns can contain a PARTITION COLUMNS:() predicate with a comma-separated list of the columns being partitioned.</span></span> <span data-ttu-id="0a3be-477">`Argument`列还可以包含 ORDER BY： ( # A1 谓词，其中列出了在分区过程中要保留排序顺序的列。</span><span class="sxs-lookup"><span data-stu-id="0a3be-477">The `Argument` columns can also contain an ORDER BY:() predicate, listing the columns to preserve the sort order for during partitioning.</span></span> <span data-ttu-id="0a3be-478">`Parallelism` 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-478">`Parallelism` is a physical operator.</span></span><br /><br /> <span data-ttu-id="0a3be-479">注意：如果查询已编译为并行查询，但在运行时它作为串行查询运行，则通过 SET STATISTICS XML 或使用中的 "**包括实际执行计划**" 选项生成的显示计划输出 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] 将不包含 `RunTimeInformation` 该运算符的元素 `Parallelism` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-479">Note: If a query has been compiled as a parallel query, but at run time it is run as a serial query, the Showplan output generated by SET STATISTICS XML or by using the **Include Actual Execution Plan** option in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] will not contain the `RunTimeInformation` element for the `Parallelism` operator.</span></span> <span data-ttu-id="0a3be-480">在 SET STATISTICS PROFILE 输出中，实际行计数和实际执行数将为运算符显示零 `Parallelism` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-480">In SET STATISTICS PROFILE output, the actual row counts and actual number of executes will display zeroes for the `Parallelism` operator.</span></span> <span data-ttu-id="0a3be-481">出现任一条件时，这意味着 `Parallelism` 运算符仅在查询编译期间使用，而不是在运行时查询计划中使用。</span><span class="sxs-lookup"><span data-stu-id="0a3be-481">When either condition occurs, it means that the `Parallelism` operator was only used during query compilation and not in the run-time query plan.</span></span> <span data-ttu-id="0a3be-482">请注意，如果服务器上的并发负荷很高，则并行查询计划有时会以串行方式运行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-482">Note that sometimes parallel query plans are run in serial if there is a high concurrent load on the server.</span></span>|  
|<span data-ttu-id="0a3be-483">![Parameter Table Scan 运算符图标](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter Table Scan 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-483">![Parameter table scan operator icon](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter table scan operator icon")</span></span>|`Parameter Table Scan`|<span data-ttu-id="0a3be-484">`Parameter Table Scan` 运算符扫描在当前查询中用作参数的表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-484">The `Parameter Table Scan` operator scans a table that is acting as a parameter in the current query.</span></span> <span data-ttu-id="0a3be-485">该运算符一般用于存储过程内的 INSERT 查询。</span><span class="sxs-lookup"><span data-stu-id="0a3be-485">Typically, this is used for INSERT queries within a stored procedure.</span></span> <span data-ttu-id="0a3be-486">`Parameter Table Scan` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-486">`Parameter Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-487">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-487">None</span></span>|<span data-ttu-id="0a3be-488">**Partial Aggregate**</span><span class="sxs-lookup"><span data-stu-id="0a3be-488">**Partial Aggregate**</span></span>|<span data-ttu-id="0a3be-489">**Partial Aggregate** 用于并行计划中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-489">**Partial Aggregate** is used in parallel plans.</span></span> <span data-ttu-id="0a3be-490">它将聚合功能应用到尽可能多的输入行中，以便不必执行向磁盘写入数据的操作（称为“溢出”）。</span><span class="sxs-lookup"><span data-stu-id="0a3be-490">It applies an aggregation function to as many input rows as possible so that writing to disk (known as a "spill") is not necessary.</span></span> <span data-ttu-id="0a3be-491">`Hash Match`是实现分区聚合的唯一物理运算符 (迭代器) 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-491">`Hash Match` is the only physical operator (iterator) that implements partition aggregation.</span></span> <span data-ttu-id="0a3be-492">**Partial Aggregate** 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-492">**Partial Aggregate** is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-493">![Population Query Cursor 运算符图标](../../2014/database-engine/media/poulation-query-32x.gif "Population Query Cursor 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-493">![Population query cursor operator icon](../../2014/database-engine/media/poulation-query-32x.gif "Population query cursor operator icon")</span></span>|`Population Query`|<span data-ttu-id="0a3be-494">`Population Query` 运算符在打开游标时填充游标的工作表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-494">The `Population Query` operator populates the work table of a cursor when the cursor is opened.</span></span>|  
|<span data-ttu-id="0a3be-495">![Refresh Query Cursor 运算符图标](../../2014/database-engine/media/refresh-query-32x.gif "Refresh Query Cursor 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-495">![Refresh query cursor operator icon](../../2014/database-engine/media/refresh-query-32x.gif "Refresh query cursor operator icon")</span></span>|`Refresh Query`|<span data-ttu-id="0a3be-496">`Refresh Query` 运算符为提取缓冲区中的行提取当前数据。</span><span class="sxs-lookup"><span data-stu-id="0a3be-496">The `Refresh Query` operator fetches current data for rows in the fetch buffer.</span></span>|  
|<span data-ttu-id="0a3be-497">![Remote Delete 运算符图标](../../2014/database-engine/media/remote-delete-32x.gif "Remote Delete 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-497">![Remote delete operator icon](../../2014/database-engine/media/remote-delete-32x.gif "Remote delete operator icon")</span></span>|`Remote Delete`|<span data-ttu-id="0a3be-498">`Remote Delete` 运算符用于从远程对象中删除输入行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-498">The `Remote Delete` operator deletes the input rows from a remote object.</span></span> <span data-ttu-id="0a3be-499">`Remote Delete` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-499">`Remote Delete` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-500">![远程索引查找显示计划运算符](../../2014/database-engine/media/remote-index-scan-32x.gif "Remote Index Seek Showplan 运算符")</span><span class="sxs-lookup"><span data-stu-id="0a3be-500">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-scan-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="0a3be-501">**Remote Index Scan**</span><span class="sxs-lookup"><span data-stu-id="0a3be-501">**Remote Index Scan**</span></span>|<span data-ttu-id="0a3be-502">**Remote Index Scan** 运算符可以扫描在 Argument 列中指定的远程索引。</span><span class="sxs-lookup"><span data-stu-id="0a3be-502">The **Remote Index Scan** operator scans the remote index specified in the Argument column.</span></span> <span data-ttu-id="0a3be-503">**Remote Index Scan** 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-503">**Remote Index Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-504">![远程索引查找显示计划运算符](../../2014/database-engine/media/remote-index-seek-32x.gif "Remote Index Seek Showplan 运算符")</span><span class="sxs-lookup"><span data-stu-id="0a3be-504">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-seek-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="0a3be-505">**Remote Index Seek**</span><span class="sxs-lookup"><span data-stu-id="0a3be-505">**Remote Index Seek**</span></span>|<span data-ttu-id="0a3be-506">**Remote Index Seek** 运算符利用远程索引对象的查找功能来检索行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-506">The **Remote Index Seek** operator uses the seeking ability of a remote index object to retrieve rows.</span></span> <span data-ttu-id="0a3be-507">`Argument`列包含所使用的远程索引的名称和 SEEK： ( # A1 谓词。</span><span class="sxs-lookup"><span data-stu-id="0a3be-507">The `Argument` column contains the name of the remote index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="0a3be-508">**Remote Index Seek** 是一个逻辑物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-508">**Remote Index Seek** is a logical physical operator.</span></span>|  
|<span data-ttu-id="0a3be-509">![Remote Insert 运算符图标](../../2014/database-engine/media/remote-insert-32x.gif "Remote Insert 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-509">![Remote insert operator icon](../../2014/database-engine/media/remote-insert-32x.gif "Remote insert operator icon")</span></span>|<span data-ttu-id="0a3be-510">**Remote Insert**</span><span class="sxs-lookup"><span data-stu-id="0a3be-510">**Remote Insert**</span></span>|<span data-ttu-id="0a3be-511">**Remote Insert** 运算符将输入行插入到远程对象。</span><span class="sxs-lookup"><span data-stu-id="0a3be-511">The **Remote Insert** operator inserts the input rows into a remote object.</span></span> <span data-ttu-id="0a3be-512">**Remote Insert** 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-512">**Remote Insert** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-513">![Remote Query 运算符图标](../../2014/database-engine/media/remote-query-32x.gif "Remote Query 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-513">![Remote query operator icon](../../2014/database-engine/media/remote-query-32x.gif "Remote query operator icon")</span></span>|`Remote Query`|<span data-ttu-id="0a3be-514">`Remote Query` 运算符将查询提交给远程源。</span><span class="sxs-lookup"><span data-stu-id="0a3be-514">The `Remote Query` operator submits a query to a remote source.</span></span> <span data-ttu-id="0a3be-515">发送到远程服务器的查询文本显示在 `Argument` 列中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-515">The text of the query sent to the remote server appears in the `Argument` column.</span></span> <span data-ttu-id="0a3be-516">`Remote Query` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-516">`Remote Query` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-517">![Remote Scan 运算符图标](../../2014/database-engine/media/remote-scan-32x.gif "Remote Scan 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-517">![Remote scan operator icon](../../2014/database-engine/media/remote-scan-32x.gif "Remote scan operator icon")</span></span>|`Remote Scan`|<span data-ttu-id="0a3be-518">`Remote Scan` 运算符扫描远程对象。</span><span class="sxs-lookup"><span data-stu-id="0a3be-518">The `Remote Scan` operator scans a remote object.</span></span> <span data-ttu-id="0a3be-519">远程对象的名称显示在 `Argument` 列中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-519">The name of the remote object appears in the `Argument` column.</span></span> <span data-ttu-id="0a3be-520">`Remote Scan` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-520">`Remote Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-521">![Remote Update 运算符图标](../../2014/database-engine/media/remote-update-32x.gif "Remote Update 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-521">![Remote update operator icon](../../2014/database-engine/media/remote-update-32x.gif "Remote update operator icon")</span></span>|`Remote Update`|<span data-ttu-id="0a3be-522">`Remote Update` 运算符将更新远程对象中的输入行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-522">The `Remote Update` operator updates the input rows in a remote object.</span></span> <span data-ttu-id="0a3be-523">`Remote Update` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-523">`Remote Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-524">![Repartition Streams Parallelism 运算符图标](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition Streams Parallelism 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-524">![Repartition streams parallelism operator icon](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition streams parallelism operator icon")</span></span>|<span data-ttu-id="0a3be-525">**Repartition Streams**</span><span class="sxs-lookup"><span data-stu-id="0a3be-525">**Repartition Streams**</span></span>|<span data-ttu-id="0a3be-526">**Repartition Streams** 运算符使用多个流并生成多个记录流。</span><span class="sxs-lookup"><span data-stu-id="0a3be-526">The **Repartition Streams** operator consumes multiple streams and produces multiple streams of records.</span></span> <span data-ttu-id="0a3be-527">记录的内容和格式不会改变。</span><span class="sxs-lookup"><span data-stu-id="0a3be-527">The record contents and format are not changed.</span></span> <span data-ttu-id="0a3be-528">如果查询优化器使用位图筛选器，则输出流中行的数量将减少。</span><span class="sxs-lookup"><span data-stu-id="0a3be-528">If the query optimizer uses a bitmap filter, the number of rows in the output stream is reduced.</span></span> <span data-ttu-id="0a3be-529">输入流中的每个记录都放入一个输出流中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-529">Each record from an input stream is placed into one output stream.</span></span> <span data-ttu-id="0a3be-530">如果该运算符保留次序，则必须对所有输入流排序并将它们合并到几个有序的输出流中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-530">If this operator is order preserving, all input streams must be ordered and merged into several ordered output streams.</span></span> <span data-ttu-id="0a3be-531">如果对输出进行了分区，则 `Argument` 列包含分区列： ( # A1 谓词和分区列。如果输出已排序，则 `Argument` 列包含 ORDER BY： ( # A3 谓词和要排序的列。</span><span class="sxs-lookup"><span data-stu-id="0a3be-531">If the output is partitioned, the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the columns being ordered.</span></span> <span data-ttu-id="0a3be-532">**Repartition Streams** 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-532">**Repartition Streams** is a logical operator.</span></span> <span data-ttu-id="0a3be-533">该运算符只用于并行查询计划中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-533">The operator is used only in parallel query plans.</span></span>|  
|<span data-ttu-id="0a3be-534">![Result 语言元素图标](../../2014/database-engine/media/result-32x.gif "Result 语言元素图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-534">![Result language element icon](../../2014/database-engine/media/result-32x.gif "Result language element icon")</span></span>|`Result`|<span data-ttu-id="0a3be-535">`Result` 运算符是查询计划结束时返回的数据。</span><span class="sxs-lookup"><span data-stu-id="0a3be-535">The `Result` operator is the data returned at the end of a query plan.</span></span> <span data-ttu-id="0a3be-536">它通常是显示计划的根元素。</span><span class="sxs-lookup"><span data-stu-id="0a3be-536">This is usually the root element of a Showplan.</span></span> <span data-ttu-id="0a3be-537">`Result` 是一个语言元素。</span><span class="sxs-lookup"><span data-stu-id="0a3be-537">`Result` is a language element.</span></span>|  
|<span data-ttu-id="0a3be-538">![RID Lookup 运算符图标](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID Lookup 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-538">![RID lookup operator icon](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID lookup operator icon")</span></span>|`RID Lookup`|<span data-ttu-id="0a3be-539">`RID Lookup` 是使用提供的行标识符 (RID) 在堆上进行的书签查找。</span><span class="sxs-lookup"><span data-stu-id="0a3be-539">`RID Lookup` is a bookmark lookup on a heap using a supplied row identifier (RID).</span></span> <span data-ttu-id="0a3be-540">`Argument`列包含用于查找表中的行的书签标签和从中查找行的表的名称。</span><span class="sxs-lookup"><span data-stu-id="0a3be-540">The `Argument` column contains the bookmark label used to look up the row in the table and the name of the table in which the row is looked up.</span></span> <span data-ttu-id="0a3be-541">`RID Lookup` 通常带有 NESTED LOOP JOIN。</span><span class="sxs-lookup"><span data-stu-id="0a3be-541">`RID Lookup` is always accompanied by a NESTED LOOP JOIN.</span></span> <span data-ttu-id="0a3be-542">`RID Lookup` 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-542">`RID Lookup` is a physical operator.</span></span> <span data-ttu-id="0a3be-543">有关书签查找的详细信息，请参阅 MSDN SQL Server 博客中的[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)（书签查找）。</span><span class="sxs-lookup"><span data-stu-id="0a3be-543">For more information about bookmark lookups, see "[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)" on the MSDN SQL Server blog.</span></span>|  
|<span data-ttu-id="0a3be-544">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-544">None</span></span>|`Right Anti Semi Join`|<span data-ttu-id="0a3be-545">`Right Anti Semi Join` 运算符输出第二个（底端）输入中与第一个（顶端）输入中的任何行都不匹配的每一行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-545">The `Right Anti Semi Join` operator outputs each row from the second (bottom) input when a matching row in the first (top) input does not exist.</span></span> <span data-ttu-id="0a3be-546">匹配的行定义为满足列 (中的谓词的行 `Argument` 。如果不存在谓词，则每行都是一个匹配行) 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-546">A matching row is defined as a row that satisfies the predicate in the `Argument` column (if no predicate exists, each row is a matching row).</span></span> <span data-ttu-id="0a3be-547">`Right Anti Semi Join` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-547">`Right Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-548">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-548">None</span></span>|`Right Outer Join`|<span data-ttu-id="0a3be-549">`Right Outer Join` 运算符返回满足第二个（底端）输入与第一个（顶端）输入的每个匹配行的联接的每行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-549">The `Right Outer Join` operator returns each row that satisfies the join of the second (bottom) input with each matching row from the first (top) input.</span></span> <span data-ttu-id="0a3be-550">此外，它还返回第二个输入中在第一个输入中没有匹配行的任何行，即与 NULL 联接。</span><span class="sxs-lookup"><span data-stu-id="0a3be-550">It also returns any rows from the second input that had no matching rows in the first input, joined with NULL.</span></span> <span data-ttu-id="0a3be-551">如果列中不存在任何联接谓词 `Argument` ，则每行都是一个匹配行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-551">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="0a3be-552">`Right Outer Join` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-552">`Right Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-553">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-553">None</span></span>|`Right Semi Join`|<span data-ttu-id="0a3be-554">第一个（顶端）输入有匹配行时，`Right Semi Join` 运算符返回第二个（底端）输入中的每一行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-554">The `Right Semi Join` operator returns each row from the second (bottom) input when there is a matching row in the first (top) input.</span></span> <span data-ttu-id="0a3be-555">如果列中不存在任何联接谓词 `Argument` ，则每行都是一个匹配行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-555">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="0a3be-556">`Right Semi Join` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-556">`Right Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-557">![Row Count Spool 运算符图标](../../2014/database-engine/media/remote-count-spool-32x.gif "Row Count Spool 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-557">![Row count spool operator icon](../../2014/database-engine/media/remote-count-spool-32x.gif "Row count spool operator icon")</span></span>|<span data-ttu-id="0a3be-558">**Row Count Spool**</span><span class="sxs-lookup"><span data-stu-id="0a3be-558">**Row Count Spool**</span></span>|<span data-ttu-id="0a3be-559">**Row Count Spool** 运算符扫描输入，计算现有的行数并返回相同数目的不包含任何数据的行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-559">The **Row Count Spool** operator scans the input, counting how many rows are present and returning the same number of rows without any data in them.</span></span> <span data-ttu-id="0a3be-560">必须检查现有行数（而非行中包含的数据）时，使用此运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-560">This operator is used when it is important to check for the existence of rows, rather than the data contained in the rows.</span></span> <span data-ttu-id="0a3be-561">例如，如果 `Nested Loops` 运算符执行左半联接操作且联接谓词应用于内部输入，则可以在运算符的内部输入的顶部放置行计数假脱机 `Nested Loops` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-561">For example, if a `Nested Loops` operator performs a left semi join operation and the join predicate applies to inner input, a row count spool may be placed at the top of the inner input of the `Nested Loops` operator.</span></span> <span data-ttu-id="0a3be-562">然后， `Nested Loops` 运算符可以确定行计数假脱机输出的行数 (因为不需要内部方的实际数据) 确定是否返回外部行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-562">Then the `Nested Loops` operator can determine how many rows are output by the row count spool (because the actual data from the inner side is not needed) to determine whether to return the outer row.</span></span> <span data-ttu-id="0a3be-563">**Row Count Spool** 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-563">**Row Count Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-564">![Segment 运算符图标](../../2014/database-engine/media/segment-32x.gif "Segment 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-564">![Segment operator icon](../../2014/database-engine/media/segment-32x.gif "Segment operator icon")</span></span>|<span data-ttu-id="0a3be-565">**段**</span><span class="sxs-lookup"><span data-stu-id="0a3be-565">**Segment**</span></span>|<span data-ttu-id="0a3be-566">**Segment** 既是一个物理运算符，也是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-566">**Segment** is a physical and a logical operator.</span></span> <span data-ttu-id="0a3be-567">它基于一个或多个列的值将输入集划分成多个段。</span><span class="sxs-lookup"><span data-stu-id="0a3be-567">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="0a3be-568">这些列显示为 **Segment** 运算符中的参数。</span><span class="sxs-lookup"><span data-stu-id="0a3be-568">These columns are shown as arguments in the **Segment** operator.</span></span> <span data-ttu-id="0a3be-569">然后此运算符每次输出一个段。</span><span class="sxs-lookup"><span data-stu-id="0a3be-569">The operator then outputs one segment at a time.</span></span>|  
|<span data-ttu-id="0a3be-570">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-570">None</span></span>|`Segment Repartition`|<span data-ttu-id="0a3be-571">在并行查询计划中，有时存在迭代器的概念性区域。</span><span class="sxs-lookup"><span data-stu-id="0a3be-571">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="0a3be-572">此类区域中的所有迭代器都可通过并行线程执行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-572">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="0a3be-573">这些区域本身必须串行执行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-573">The regions themselves must be executed serially.</span></span> <span data-ttu-id="0a3be-574">单个区域内的某些 `Parallelism` 迭代器称为 `Branch Repartition`。</span><span class="sxs-lookup"><span data-stu-id="0a3be-574">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="0a3be-575">两个这样的区域边界上的 `Parallelism` 迭代器称为 `Segment Repartition`。</span><span class="sxs-lookup"><span data-stu-id="0a3be-575">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="0a3be-576">`Branch Repartition` 和 `Segment Repartition` 是逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-576">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="0a3be-577">![Sequence 运算符图标](../../2014/database-engine/media/sequence-32x.gif "Sequence 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-577">![Sequence operator icon](../../2014/database-engine/media/sequence-32x.gif "Sequence operator icon")</span></span>|`Sequence`|<span data-ttu-id="0a3be-578">`Sequence` 运算符驱动大范围的更新计划。</span><span class="sxs-lookup"><span data-stu-id="0a3be-578">The `Sequence` operator drives wide update plans.</span></span> <span data-ttu-id="0a3be-579">就其功能而言，该运算符按顺序（从上到下）执行每个输入。</span><span class="sxs-lookup"><span data-stu-id="0a3be-579">Functionally, it executes each input in sequence (top to bottom).</span></span> <span data-ttu-id="0a3be-580">每个输入通常是不同对象的更新。</span><span class="sxs-lookup"><span data-stu-id="0a3be-580">Each input is usually an update of a different object.</span></span> <span data-ttu-id="0a3be-581">该运算符只返回其上一个（底端）输入中的行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-581">It returns only those rows that come from its last (bottom) input.</span></span> <span data-ttu-id="0a3be-582">`Sequence` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-582">`Sequence` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-583">![Sequence Project 运算符图标](../../2014/database-engine/media/sequence-project-32x.gif "Sequence Project 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-583">![Sequence project operator icon](../../2014/database-engine/media/sequence-project-32x.gif "Sequence project operator icon")</span></span>|`Sequence Project`|<span data-ttu-id="0a3be-584">`Sequence Project` 运算符将添加列以便计算有序集。</span><span class="sxs-lookup"><span data-stu-id="0a3be-584">The `Sequence Project` operator adds columns to perform computations over an ordered set.</span></span> <span data-ttu-id="0a3be-585">它基于一个或多个列的值将输入集划分成多个段。</span><span class="sxs-lookup"><span data-stu-id="0a3be-585">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="0a3be-586">然后此运算符每次输出一个段。</span><span class="sxs-lookup"><span data-stu-id="0a3be-586">The operator then outputs one segment at a time.</span></span> <span data-ttu-id="0a3be-587">这些列在 `Sequence Project` 运算符中作为参数显示。</span><span class="sxs-lookup"><span data-stu-id="0a3be-587">These columns are shown as arguments in the `Sequence Project` operator.</span></span> <span data-ttu-id="0a3be-588">`Sequence Project` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-588">`Sequence Project` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-589">![Snapshot Cursor 运算符图标](../../2014/database-engine/media/snapshot-32x.gif "Snapshot Cursor 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-589">![Snapshot cursor operator icon](../../2014/database-engine/media/snapshot-32x.gif "Snapshot cursor operator icon")</span></span>|<span data-ttu-id="0a3be-590">**快照**</span><span class="sxs-lookup"><span data-stu-id="0a3be-590">**Snapshot**</span></span>|<span data-ttu-id="0a3be-591">**Snapshot** 运算符创建一个看不到其他人所做更改的游标。</span><span class="sxs-lookup"><span data-stu-id="0a3be-591">The **Snapshot** operator creates a cursor that does not see changes made by others.</span></span>|  
|<span data-ttu-id="0a3be-592">![Sort 运算符图标](../../2014/database-engine/media/sort-32x.gif "Sort 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-592">![Sort operator icon](../../2014/database-engine/media/sort-32x.gif "Sort operator icon")</span></span>|`Sort`|<span data-ttu-id="0a3be-593">`Sort`运算符对所有传入的行进行排序。</span><span class="sxs-lookup"><span data-stu-id="0a3be-593">The `Sort` operator sorts all incoming rows.</span></span> <span data-ttu-id="0a3be-594">`Argument`列包含不同的 ORDER by： ( # A1 谓词（如果此操作删除了重复项），或 ORDER BY： ( # A3 谓词，其中包含要排序的列的逗号分隔列表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-594">The `Argument` column contains either a DISTINCT ORDER BY:() predicate if duplicates are removed by this operation, or an ORDER BY:() predicate with a comma-separated list of the columns being sorted.</span></span> <span data-ttu-id="0a3be-595">如果按升序对列排序，则使用值 ASC 作为列的前缀；如果按降序对列排序，则使用值 DESC 作为列的前缀。</span><span class="sxs-lookup"><span data-stu-id="0a3be-595">The columns are prefixed with the value ASC if the columns are sorted in ascending order, or the value DESC if the columns are sorted in descending order.</span></span> <span data-ttu-id="0a3be-596">`Sort` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-596">`Sort` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-597">![Split 运算符图标](../../2014/database-engine/media/split-32x.gif "Split 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-597">![Split operator icon](../../2014/database-engine/media/split-32x.gif "Split operator icon")</span></span>|`Split`|<span data-ttu-id="0a3be-598">`Split`运算符用于优化更新处理。</span><span class="sxs-lookup"><span data-stu-id="0a3be-598">The `Split` operator is used to optimize update processing.</span></span> <span data-ttu-id="0a3be-599">它将每个更新操作拆分成删除和插入操作。</span><span class="sxs-lookup"><span data-stu-id="0a3be-599">It splits each update operation into a delete and an insert operation.</span></span> <span data-ttu-id="0a3be-600">`Split` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-600">`Split` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-601">![Spool 运算符图标](../../2014/database-engine/media/spool-32x.gif "Spool 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-601">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="0a3be-602">**Spool**</span><span class="sxs-lookup"><span data-stu-id="0a3be-602">**Spool**</span></span>|<span data-ttu-id="0a3be-603">**线轴**运算符将中间查询结果保存到 `tempdb` 数据库。</span><span class="sxs-lookup"><span data-stu-id="0a3be-603">The **Spool** operator saves an intermediate query result to the `tempdb` database.</span></span>|  
|<span data-ttu-id="0a3be-604">![Stream Aggregate 运算符图标](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream Aggregate 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-604">![Stream aggregate operator icon](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream aggregate operator icon")</span></span>|`Stream Aggregate`|<span data-ttu-id="0a3be-605">`Stream Aggregate` 运算符按一列或多列对行分组，然后计算由查询返回的一个或多个聚合表达式。</span><span class="sxs-lookup"><span data-stu-id="0a3be-605">The `Stream Aggregate` operator groups rows by one or more columns and then calculates one or more aggregate expressions returned by the query.</span></span> <span data-ttu-id="0a3be-606">此运算符的输出可供查询中的后续运算符引用和/或返回到客户端。</span><span class="sxs-lookup"><span data-stu-id="0a3be-606">The output of this operator can be referenced by later operators in the query, returned to the client, or both.</span></span> <span data-ttu-id="0a3be-607">`Stream Aggregate` 运算符要求输入在组中按列进行排序。</span><span class="sxs-lookup"><span data-stu-id="0a3be-607">The `Stream Aggregate` operator requires input ordered by the columns within its groups.</span></span> <span data-ttu-id="0a3be-608">如果由于前面的 `Sort` 运算符或已排序的索引查找或扫描导致数据尚未排序，则优化器将在此运算符前面使用一个 `Sort` 运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-608">The optimizer will use a `Sort` operator prior to this operator if the data is not already sorted due to a prior `Sort` operator or due to an ordered index seek or scan.</span></span> <span data-ttu-id="0a3be-609">在中的 SHOWPLAN_ALL 语句或图形执行计划中 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] ，GROUP BY 谓词中的列会列在列中 `Argument` ，而聚合表达式则列在 "定义的**值**" 列中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-609">In the SHOWPLAN_ALL statement or the graphical execution plan in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], the columns in the GROUP BY predicate are listed in the `Argument` column, and the aggregate expressions are listed in the **Defined Values** column.</span></span> <span data-ttu-id="0a3be-610">`Stream Aggregate` 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-610">`Stream Aggregate` is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-611">![Switch 运算符图标](../../2014/database-engine/media/switch-32x.gif "Switch 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-611">![Switch operator icon](../../2014/database-engine/media/switch-32x.gif "Switch operator icon")</span></span>|<span data-ttu-id="0a3be-612">**开关**</span><span class="sxs-lookup"><span data-stu-id="0a3be-612">**Switch**</span></span>|<span data-ttu-id="0a3be-613">**Switch** 是一种特殊类型的串联迭代器，它具有 *n* 个输入。</span><span class="sxs-lookup"><span data-stu-id="0a3be-613">**Switch** is a special type of concatenation iterator that has *n* inputs.</span></span> <span data-ttu-id="0a3be-614">有一个表达式与每个 **Switch** 运算符关联。</span><span class="sxs-lookup"><span data-stu-id="0a3be-614">An expression is associated with each **Switch** operator.</span></span> <span data-ttu-id="0a3be-615">根据表达式的返回值（在 0 到 *n*-1 之间）， **Switch** 将适当的输入流复制到输出流中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-615">Depending on the return value of the expression (between 0 and *n*-1), **Switch** copies the appropriate input stream to the output stream.</span></span> <span data-ttu-id="0a3be-616">**Switch** 的一种用途是与某些运算符（如 **TOP** 运算符）一起实现涉及快进游标的查询计划。</span><span class="sxs-lookup"><span data-stu-id="0a3be-616">One use of **Switch** is to implement query plans involving fast forward cursors with certain operators such as the **TOP** operator.</span></span> <span data-ttu-id="0a3be-617">**Switch** 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-617">**Switch** is both a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-618">![Table Delete 运算符图标](../../2014/database-engine/media/table-delete-32x.gif "Table Delete 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-618">![Table delete operator icon](../../2014/database-engine/media/table-delete-32x.gif "Table delete operator icon")</span></span>|`Table Delete`|<span data-ttu-id="0a3be-619">`Table Delete`物理运算符从 `Argument` 查询执行计划的列中指定的表中删除行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-619">The `Table Delete` physical operator deletes rows from the table specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="0a3be-620">![Table Insert 运算符图标](../../2014/database-engine/media/table-insert-32x.gif "Table Insert 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-620">![Table insert operator icon](../../2014/database-engine/media/table-insert-32x.gif "Table insert operator icon")</span></span>|`Table Insert`|<span data-ttu-id="0a3be-621">`Table Insert`运算符将其输入中的行插入到在 `Argument` 查询执行计划的列中指定的表中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-621">The `Table Insert` operator inserts rows from its input into the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="0a3be-622">`Argument` 列还包含一个 SET:() 谓词，用于指示为每一列设置的值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-622">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="0a3be-623">如果 `Table Insert` 的插入值没有子项，插入的行则来自 Insert 运算符本身。</span><span class="sxs-lookup"><span data-stu-id="0a3be-623">If `Table Insert` has no children for insert values, then the row inserted is taken from the Insert operator itself.</span></span> <span data-ttu-id="0a3be-624">`Table Insert` 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-624">`Table Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-625">![Table Merge 运算符](../../2014/database-engine/media/table-merge-32x.gif "Table Merge 运算符")</span><span class="sxs-lookup"><span data-stu-id="0a3be-625">![Table merge operator](../../2014/database-engine/media/table-merge-32x.gif "Table merge operator")</span></span>|<span data-ttu-id="0a3be-626">**Table Merge**</span><span class="sxs-lookup"><span data-stu-id="0a3be-626">**Table Merge**</span></span>|<span data-ttu-id="0a3be-627">**Table Merge** 运算符可将合并数据流应用到堆。</span><span class="sxs-lookup"><span data-stu-id="0a3be-627">The **Table Merge** operator applies a merge data stream to a heap.</span></span> <span data-ttu-id="0a3be-628">运算符在运算符的列中指定的表中删除、更新或插入行 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-628">The operator deletes, updates, or inserts rows in the table specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="0a3be-629">执行的实际操作取决于在运算符的列中指定的**ACTION**列的运行时值 `Argument` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-629">The actual operation performed depends on the run-time value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="0a3be-630">**Table Merge** 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-630">**Table Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-631">![Table Scan 运算符图标](../../2014/database-engine/media/table-scan-32x.gif "Table Scan 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-631">![Table scan operator icon](../../2014/database-engine/media/table-scan-32x.gif "Table scan operator icon")</span></span>|`Table Scan`|<span data-ttu-id="0a3be-632">`Table Scan`运算符从 `Argument` 查询执行计划的列中指定的表中检索所有行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-632">The `Table Scan` operator retrieves all rows from the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="0a3be-633">如果列中出现 WHERE： ( # A1 谓词 `Argument` ，则只返回满足该谓词的那些行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-633">If a WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="0a3be-634">`Table Scan` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-634">`Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-635">![Table Spool 运算符图标](../../2014/database-engine/media/table-spool-32x.gif "Table Spool 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-635">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|<span data-ttu-id="0a3be-636">**Table Spool**</span><span class="sxs-lookup"><span data-stu-id="0a3be-636">**Table Spool**</span></span>|<span data-ttu-id="0a3be-637">**Table Spool** 运算符扫描输入，并将各行的一个副本放入隐藏的假脱机表中，此表存储在 [tempdb](../relational-databases/databases/tempdb-database.md) 数据库中并且仅在查询的生存期内存在。</span><span class="sxs-lookup"><span data-stu-id="0a3be-637">The **Table Spool** operator scans the input and places a copy of each row in a hidden spool table that is stored in the [tempdb](../relational-databases/databases/tempdb-database.md) database and existing only for the lifetime of the query.</span></span> <span data-ttu-id="0a3be-638">如果对运算符进行倒带 (例如， `Nested Loops` 运算符) 但不需要重新绑定，则使用假脱机数据，而不是重新扫描输入。</span><span class="sxs-lookup"><span data-stu-id="0a3be-638">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="0a3be-639">**Table Spool** 是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-639">**Table Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="0a3be-640">![Table Update 运算符图标](../../2014/database-engine/media/table-update-32x.gif "Table Update 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-640">![Table update operator icon](../../2014/database-engine/media/table-update-32x.gif "Table update operator icon")</span></span>|`Table Update`|<span data-ttu-id="0a3be-641">`Table Update`物理运算符更新 `Argument` 查询执行计划的列中指定的表中的输入行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-641">The `Table Update` physical operator updates input rows in the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="0a3be-642">SET:() 谓词确定每个更新列的值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-642">The SET:() predicate determines the value of each updated column.</span></span> <span data-ttu-id="0a3be-643">可以在 SET 子句中、此运算符内的其他位置以及此查询内的其他位置引用这些值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-643">These values may be referenced in the SET clause or elsewhere within this operator as well as elsewhere within this query.</span></span>|  
|<span data-ttu-id="0a3be-644">![Table-valued Function 运算符图标](../../2014/database-engine/media/table-valued-function-32x.gif "Table-valued Function 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-644">![Table-valued function operator icon](../../2014/database-engine/media/table-valued-function-32x.gif "Table-valued function operator icon")</span></span>|<span data-ttu-id="0a3be-645">**Table-valued Function**</span><span class="sxs-lookup"><span data-stu-id="0a3be-645">**Table-valued Function**</span></span>|<span data-ttu-id="0a3be-646">**Table-valued Function** 运算符计算表值函数（ [!INCLUDE[tsql](../includes/tsql-md.md)] 或 CLR）并将结果行存储在 [tempdb](../relational-databases/databases/tempdb-database.md) 数据库中。</span><span class="sxs-lookup"><span data-stu-id="0a3be-646">The **Table-valued Function** operator evaluates a table-valued function (either [!INCLUDE[tsql](../includes/tsql-md.md)] or CLR), and stores the resulting rows in the [tempdb](../relational-databases/databases/tempdb-database.md) database.</span></span> <span data-ttu-id="0a3be-647">当父迭代器请求行时，**表值函数**将返回中的行 `tempdb` 。</span><span class="sxs-lookup"><span data-stu-id="0a3be-647">When the parent iterators request the rows, **Table-valued Function** returns the rows from `tempdb`.</span></span><br /><br /> <span data-ttu-id="0a3be-648">调用表值函数的查询生成具有 **Table-valued Function** 迭代器的查询计划。</span><span class="sxs-lookup"><span data-stu-id="0a3be-648">Queries with calls to table-valued functions generate query plans with the **Table-valued Function** iterator.</span></span> <span data-ttu-id="0a3be-649">可以使用不同的参数值计算**Table-valued Function** ：</span><span class="sxs-lookup"><span data-stu-id="0a3be-649">**Table-valued Function** can be evaluated with different parameter values:</span></span><br /><br /> <span data-ttu-id="0a3be-650">**Table-valued Function XML Reader** 输入 XML BLOB 作为参数，并生成一个按 XML 文档顺序表示 XML 节点的行集。</span><span class="sxs-lookup"><span data-stu-id="0a3be-650">**Table-valued Function XML Reader** inputs an XML BLOB as a parameter and produces a rowset representing XML nodes in XML document order.</span></span> <span data-ttu-id="0a3be-651">其他输入参数可能会将返回的 XML 节点限于 XML 文档的子集。</span><span class="sxs-lookup"><span data-stu-id="0a3be-651">Other input parameters may restrict XML nodes returned to a subset of XML document.</span></span><br /><br /> <span data-ttu-id="0a3be-652">**Table Valued Function XML Reader with XPath filter** 是一种特殊类型的 **XML Reader Table-valued Function** ，它将输出限于满足 XPath 表达式的 XML 节点。</span><span class="sxs-lookup"><span data-stu-id="0a3be-652">**Table Valued Function XML Reader with XPath filter** is a special type of **XML Reader Table-valued Function** that restricts output to XML nodes satisfying an XPath expression.</span></span><br /><br /> <br /><br /> <span data-ttu-id="0a3be-653">**Table-valued Function** 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-653">**Table-valued Function** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-654">![Top 运算符图标](../../2014/database-engine/media/top-32x.gif "Top 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-654">![Top operator icon](../../2014/database-engine/media/top-32x.gif "Top operator icon")</span></span>|<span data-ttu-id="0a3be-655">顶部</span><span class="sxs-lookup"><span data-stu-id="0a3be-655">**Top**</span></span>|<span data-ttu-id="0a3be-656">**Top** 运算符扫描输入，但仅基于排序顺序返回最前面的指定行数或行百分比。</span><span class="sxs-lookup"><span data-stu-id="0a3be-656">The **Top** operator scans the input, returning only the first specified number or percent of rows, possibly based on a sort order.</span></span> <span data-ttu-id="0a3be-657">`Argument`列可以包含要检查其并列的列的列表。</span><span class="sxs-lookup"><span data-stu-id="0a3be-657">The `Argument` column can contain a list of the columns that are being checked for ties.</span></span> <span data-ttu-id="0a3be-658">在更新计划中， **Top** 运算符用于强制实施行计数限制。</span><span class="sxs-lookup"><span data-stu-id="0a3be-658">In update plans, the **Top** operator is used to enforce row count limits.</span></span> <span data-ttu-id="0a3be-659">**Top** 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-659">**Top** is a logical and physical operator.</span></span> <span data-ttu-id="0a3be-660">**Top** 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-660">**Top** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="0a3be-661">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-661">None</span></span>|<span data-ttu-id="0a3be-662">**Top N Sort**</span><span class="sxs-lookup"><span data-stu-id="0a3be-662">**Top N Sort**</span></span>|<span data-ttu-id="0a3be-663">**Top N Sort**与 `Sort` 迭代器类似，只不过只需要前*n*行，而不是整个结果集。</span><span class="sxs-lookup"><span data-stu-id="0a3be-663">**Top N Sort** is similar to the `Sort` iterator, except that only the first *N* rows are needed, and not the entire result set.</span></span> <span data-ttu-id="0a3be-664">如果 *N*的值较小， [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 查询执行引擎将尝试在内存中执行整个排序操作。</span><span class="sxs-lookup"><span data-stu-id="0a3be-664">For small values of *N*, the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] query execution engine attempts to perform the entire sort operation in memory.</span></span> <span data-ttu-id="0a3be-665">如果 *N*的值较大，查询执行引擎将使用更通用的排序方法（该方法不采用 *N* 作为参数）重新排序。</span><span class="sxs-lookup"><span data-stu-id="0a3be-665">For large values of *N*, the query execution engine resorts to the more generic method of sorting to which *N* is not a parameter.</span></span>|  
|<span data-ttu-id="0a3be-666">![Extended 运算符 (UDX) 图标](../../2014/database-engine/media/udx-32x.gif "Extended 运算符 (UDX) 图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-666">![Extended operator (UDX) icon](../../2014/database-engine/media/udx-32x.gif "Extended operator (UDX) icon")</span></span>|`UDX`|<span data-ttu-id="0a3be-667">扩展运算符 (UDX) 可以实现 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]中的一种 XQuery 或 XPath 操作。</span><span class="sxs-lookup"><span data-stu-id="0a3be-667">Extended Operators (UDX) implement one of many XQuery and XPath operations in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="0a3be-668">所有 UDX 运算符既是逻辑运算符，又是物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-668">All UDX operators are both logical and physical operators.</span></span><br /><br /> <span data-ttu-id="0a3be-669">扩展运算符 (UDX) `FOR XML` 用于将其输入的关系行集序列化为 XML 表示形式，并以单个输出行、单个 BLOB 列的形式存储。</span><span class="sxs-lookup"><span data-stu-id="0a3be-669">Extended operator (UDX) `FOR XML` is used to serialize the relational row set it inputs into XML representation in a single BLOB column in a single output row.</span></span> <span data-ttu-id="0a3be-670">它是区分顺序的 XML 聚合运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-670">It is an order sensitive XML aggregation operator.</span></span><br /><br /> <span data-ttu-id="0a3be-671">扩展运算符 (UDX) `XML SERIALIZER` 是区分顺序的一种 XML 聚合运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-671">Extended operator (UDX) `XML SERIALIZER` is an order sensitive XML aggregation operator.</span></span> <span data-ttu-id="0a3be-672">它以 XML 文档顺序输入表示 XML 节点或 XQuery 标量的行，并在单个输出行、单个 XML 列中生成序列化的 XML BLOB。</span><span class="sxs-lookup"><span data-stu-id="0a3be-672">It inputs rows representing XML nodes or XQuery scalars in XML document order and produces a serialized XML BLOB in a single XML column in a single output row.</span></span><br /><br /> <span data-ttu-id="0a3be-673">扩展运算符 (UDX) `XML FRAGMENT SERIALIZER` 是一种特殊类型的 `XML SERIALIZER`，用于处理表示在 XQuery 插入数据修改扩展中插入的 XML 片断的输入行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-673">Extended operator (UDX) `XML FRAGMENT SERIALIZER` is a special type of `XML SERIALIZER` that is used for processing input rows representing XML fragments being inserted in XQuery insert data modification extension.</span></span><br /><br /> <span data-ttu-id="0a3be-674">扩展运算符 (UDX) `XQUERY STRING` 计算表示 XML 节点的输入行的 XQuery 字符串值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-674">Extended operator (UDX) `XQUERY STRING` evaluates the XQuery string value of input rows representing XML nodes.</span></span> <span data-ttu-id="0a3be-675">它是一个区分顺序的字符串聚合运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-675">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="0a3be-676">它输出一行多列，表示包含输入字符串值的 XQuery 标量。</span><span class="sxs-lookup"><span data-stu-id="0a3be-676">It outputs one row with columns representing the XQuery scalar that contains string value of the input.</span></span><br /><br /> <span data-ttu-id="0a3be-677">扩展运算符 (UDX) `XQUERY LIST DECOMPOSER` 是一个 XQuery 列表分解运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-677">Extended operator (UDX) `XQUERY LIST DECOMPOSER` is an XQuery list decomposition operator.</span></span> <span data-ttu-id="0a3be-678">对于表示 XML 节点的每个输入行，它至少生成表示 XQuery 标量的一个行，如果输入的是 XSD 列表类型的行，则每个行都包含一个列表元素值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-678">For each input row representing an XML node it produces one or more rows each representing XQuery scalar containing a list element value if the input is of XSD list type.</span></span><br /><br /> <span data-ttu-id="0a3be-679">扩展运算符 (UDX) `XQUERY DATA` 在表示 XML 节点的输入行上计算 XQuery fn:data() 函数的值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-679">Extended operator (UDX) `XQUERY DATA` evaluates the XQuery fn:data() function on input representing XML nodes.</span></span> <span data-ttu-id="0a3be-680">它是一个区分顺序的字符串聚合运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-680">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="0a3be-681">它输出一行多列，表示包含 **fn:data()** 结果的 XQuery 标量。</span><span class="sxs-lookup"><span data-stu-id="0a3be-681">It outputs one row with columns representing XQuery scalar that contains the result of **fn:data()**.</span></span><br /><br /> <span data-ttu-id="0a3be-682">扩展运算符 `XQUERY CONTAINS` 在表示 XML 节点的输入行上计算 XQuery fn:contains() 函数的值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-682">Extended operator `XQUERY CONTAINS` evaluates the XQuery fn:contains() function on input representing XML nodes.</span></span> <span data-ttu-id="0a3be-683">它是一个区分顺序的字符串聚合运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-683">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="0a3be-684">它输出一行多列，表示包含 **fn:contains()** 结果的 XQuery 标量。</span><span class="sxs-lookup"><span data-stu-id="0a3be-684">It outputs one row with columns representing XQuery scalar that contains the result of **fn:contains()**.</span></span><br /><br /> <span data-ttu-id="0a3be-685">扩展运算符 `UPDATE XML NODE` 更新 xml 类型的**modify ( # B1**方法中的 XQuery replace data 修改扩展中的 xml 节点。</span><span class="sxs-lookup"><span data-stu-id="0a3be-685">Extended operator `UPDATE XML NODE` updates XML node in the XQuery replace data modification extension in the **modify()** method on XML type.</span></span>|  
|<span data-ttu-id="0a3be-686">无</span><span class="sxs-lookup"><span data-stu-id="0a3be-686">None</span></span>|<span data-ttu-id="0a3be-687">**Union**</span><span class="sxs-lookup"><span data-stu-id="0a3be-687">**Union**</span></span>|<span data-ttu-id="0a3be-688">**Union** 运算符扫描多个输入，输出扫描的每一行并删除重复项。</span><span class="sxs-lookup"><span data-stu-id="0a3be-688">The **Union** operator scans multiple inputs, outputting each row scanned and removing duplicates.</span></span> <span data-ttu-id="0a3be-689">**Union** 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-689">**Union** is a logical operator.</span></span>|  
|<span data-ttu-id="0a3be-690">![Update（数据库引擎）运算符图标](../../2014/database-engine/media/update-32x.gif "Update（数据库引擎）运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-690">![Update (Database Engine) operator icon](../../2014/database-engine/media/update-32x.gif "Update (Database Engine) operator icon")</span></span>|`Update`|<span data-ttu-id="0a3be-691">`Update`运算符从 `Argument` 查询执行计划的列中指定的对象中的输入更新每行。</span><span class="sxs-lookup"><span data-stu-id="0a3be-691">The `Update` operator updates each row from its input in the object specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="0a3be-692">`Update` 是一个逻辑运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-692">`Update` is a logical operator.</span></span> <span data-ttu-id="0a3be-693">物理运算符为 `Table Update`、`Index Update` 或 `Clustered Index Update`。</span><span class="sxs-lookup"><span data-stu-id="0a3be-693">The physical operator is `Table Update`, `Index Update`, or `Clustered Index Update`.</span></span>|  
|<span data-ttu-id="0a3be-694">![While 语言元素图标](../../2014/database-engine/media/while-32x.gif "While 语言元素图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-694">![While language element icon](../../2014/database-engine/media/while-32x.gif "While language element icon")</span></span>|`While`|<span data-ttu-id="0a3be-695">`While` 运算符实现 [!INCLUDE[tsql](../includes/tsql-md.md)] while 循环。</span><span class="sxs-lookup"><span data-stu-id="0a3be-695">The `While` operator implements the [!INCLUDE[tsql](../includes/tsql-md.md)] while loop.</span></span> <span data-ttu-id="0a3be-696">`While`是语言元素</span><span class="sxs-lookup"><span data-stu-id="0a3be-696">`While` is a language element</span></span>|  
|<span data-ttu-id="0a3be-697">![Table Spool 运算符图标](../../2014/database-engine/media/table-spool-32x.gif "Table Spool 运算符图标")</span><span class="sxs-lookup"><span data-stu-id="0a3be-697">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|`Window Spool`|<span data-ttu-id="0a3be-698">`Window Spool` 运算符将每个行扩展为表示与行关联的窗口的行集。</span><span class="sxs-lookup"><span data-stu-id="0a3be-698">The `Window Spool` operator expands each row into the set of rows that represents the window associated with it.</span></span> <span data-ttu-id="0a3be-699">在查询中，OVER 子句定义查询结果集内的窗口和窗口函数，然后计算窗口中的每个行的值。</span><span class="sxs-lookup"><span data-stu-id="0a3be-699">In a query, the OVER clause defines the window within a query result set and a window function then computes a value for each row in the window.</span></span> <span data-ttu-id="0a3be-700">`Window Spool` 既是一个逻辑运算符，也是一个物理运算符。</span><span class="sxs-lookup"><span data-stu-id="0a3be-700">`Window Spool` is a logical and physical operator.</span></span>|  
  
  
