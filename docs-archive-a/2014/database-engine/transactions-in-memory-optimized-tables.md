---
title: 内存优化表中的事务 |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 2cd07d26-a1f1-4034-8d6f-f196eed1b763
author: stevestein
ms.author: sstein
ms.openlocfilehash: bc9109c7243e609e5ddd820b61386183761167bf
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87694074"
---
# <a name="transactions-in-memory-optimized-tables"></a><span data-ttu-id="ceb85-102">内存优化表中的事务</span><span class="sxs-lookup"><span data-stu-id="ceb85-102">Transactions in Memory-Optimized Tables</span></span>
  <span data-ttu-id="ceb85-103">基于磁盘的表的行版本控制（使用 SNAPSHOT 隔离或 READ_COMMITTED_SNAPSHOT）提供了一种乐观并发控制形式。</span><span class="sxs-lookup"><span data-stu-id="ceb85-103">Row versioning on disk-based tables (using SNAPSHOT isolation or READ_COMMITTED_SNAPSHOT) provides a form of optimistic concurrency control.</span></span> <span data-ttu-id="ceb85-104">读取器和编写器不会相互阻止。</span><span class="sxs-lookup"><span data-stu-id="ceb85-104">Readers and writers do not block each other.</span></span> <span data-ttu-id="ceb85-105">对于内存优化表，编写器不会阻止编写器。</span><span class="sxs-lookup"><span data-stu-id="ceb85-105">With memory-optimized tables, writers do not block writers.</span></span> <span data-ttu-id="ceb85-106">使用基于磁盘的表的行版本控制时，一个事务会锁定行，而尝试更新行的并发事务会被阻塞。</span><span class="sxs-lookup"><span data-stu-id="ceb85-106">With row versioning on disk-based tables, one transaction locks the row and concurrent transactions attempting to update the row are blocked.</span></span> <span data-ttu-id="ceb85-107">对于内存优化表则没有锁定。</span><span class="sxs-lookup"><span data-stu-id="ceb85-107">There is no locking with memory-optimized tables.</span></span> <span data-ttu-id="ceb85-108">如果两个事务尝试更新同一行，则会发生写/写冲突（错误 41302）。</span><span class="sxs-lookup"><span data-stu-id="ceb85-108">Instead, if two transactions attempt to update the same row, a write/write conflict (error 41302) will occur.</span></span>

 <span data-ttu-id="ceb85-109">与基于磁盘的表不同，内存优化表允许具有更高隔离级别、可重复读和可序列化的乐观并发控制。</span><span class="sxs-lookup"><span data-stu-id="ceb85-109">Unlike disk-based tables, memory-optimized tables allow optimistic concurrency control with the higher isolation levels, REPEATABLE READ and SERIALIZABLE.</span></span> <span data-ttu-id="ceb85-110">不会使用锁来强制实现隔离级别。</span><span class="sxs-lookup"><span data-stu-id="ceb85-110">Locks are not taken to enforce the isolation levels.</span></span> <span data-ttu-id="ceb85-111">而是在事务验证结束时使用锁，以确保可重复读或可序列化假定。</span><span class="sxs-lookup"><span data-stu-id="ceb85-111">Instead, at the end of the transaction validation ensures the repeatable read or serializability assumptions.</span></span> <span data-ttu-id="ceb85-112">如果违反了假定，则事务将会终止。</span><span class="sxs-lookup"><span data-stu-id="ceb85-112">If the assumptions are violated, the transaction is terminated.</span></span> <span data-ttu-id="ceb85-113">有关详细信息，请参阅 [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md)。</span><span class="sxs-lookup"><span data-stu-id="ceb85-113">For more information, see [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md).</span></span>

 <span data-ttu-id="ceb85-114">内存优化表的重要事务语义如下：</span><span class="sxs-lookup"><span data-stu-id="ceb85-114">The important transaction semantics for memory-optimized tables are:</span></span>

-   <span data-ttu-id="ceb85-115">多版本控制</span><span class="sxs-lookup"><span data-stu-id="ceb85-115">Multi-versioning</span></span>

-   <span data-ttu-id="ceb85-116">基于快照的事务隔离</span><span class="sxs-lookup"><span data-stu-id="ceb85-116">Snapshot-based transaction isolation</span></span>

-   <span data-ttu-id="ceb85-117">乐观</span><span class="sxs-lookup"><span data-stu-id="ceb85-117">Optimistic</span></span>

-   <span data-ttu-id="ceb85-118">冲突检测</span><span class="sxs-lookup"><span data-stu-id="ceb85-118">Conflict detection</span></span>

 <span data-ttu-id="ceb85-119">以下各部分说明了每个语义。</span><span class="sxs-lookup"><span data-stu-id="ceb85-119">Each of these semantics is explained in the following sections.</span></span>

## <a name="multi-versioning-in-memory-optimized-tables"></a><span data-ttu-id="ceb85-120">内存优化表中的多版本控制</span><span class="sxs-lookup"><span data-stu-id="ceb85-120">Multi-Versioning in Memory-Optimized Tables</span></span>
 <span data-ttu-id="ceb85-121">内存优化表中的行可具有不同版本。</span><span class="sxs-lookup"><span data-stu-id="ceb85-121">Rows in memory-optimized tables can have different versions.</span></span> <span data-ttu-id="ceb85-122">并发事务可以访问同一行的不同版本。</span><span class="sxs-lookup"><span data-stu-id="ceb85-122">Concurrent transactions access potentially different versions of the same row.</span></span>

 <span data-ttu-id="ceb85-123">内存优化表数据基于版本。</span><span class="sxs-lookup"><span data-stu-id="ceb85-123">Memory-optimized table data is version-based.</span></span> <span data-ttu-id="ceb85-124">对于任何行，可能具有在不同时间点有效的不同行版本。</span><span class="sxs-lookup"><span data-stu-id="ceb85-124">For any row there may be different row versions that are valid at different points in time.</span></span> <span data-ttu-id="ceb85-125">当 READ_COMMITTED_SNAPSHOT 或 ALLOW_SNAPSHOT_ISOLATION 设置为 ON 时，基于磁盘的表会保留不同的行版本。</span><span class="sxs-lookup"><span data-stu-id="ceb85-125">Disk-based tables maintain different row versions when READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION is ON.</span></span> <span data-ttu-id="ceb85-126">内存优化表会保留不同的行版本，即使 READ_COMMITTED_SNAPSHOT 和 ALLOW_SNAPSHOT_ISOLATION 设置为 OFF 时也是如此。</span><span class="sxs-lookup"><span data-stu-id="ceb85-126">Memory-optimized tables maintain different row versions, even if READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION are OFF.</span></span> <span data-ttu-id="ceb85-127">内存优化表的行版本不保持在 tempdb 中。</span><span class="sxs-lookup"><span data-stu-id="ceb85-127">The row versions of memory-optimized tables are not maintained in tempdb.</span></span> <span data-ttu-id="ceb85-128">而行版本以内联方式作为在内存中存储行的内存优化数据结构的一部分来保留。</span><span class="sxs-lookup"><span data-stu-id="ceb85-128">Instead, the row versions are maintained in-line, as part of the memory-optimized data structures storing the rows in memory.</span></span>

## <a name="snapshot-based-transaction-isolation-for-memory-optimized-tables"></a><span data-ttu-id="ceb85-129">内存优化表的基于快照的事务隔离</span><span class="sxs-lookup"><span data-stu-id="ceb85-129">Snapshot-Based Transaction Isolation for Memory-Optimized Tables</span></span>
 <span data-ttu-id="ceb85-130">单个事务中的所有操作都使用内存优化表的相同事务一致快照。</span><span class="sxs-lookup"><span data-stu-id="ceb85-130">All operations in a single transaction use the same transactionally-consistent snapshot of the memory-optimized tables.</span></span> <span data-ttu-id="ceb85-131">内存优化表的所有事务隔离都基于快照的事务隔离。</span><span class="sxs-lookup"><span data-stu-id="ceb85-131">All transaction isolation for memory-optimized tables is snapshot-based.</span></span> <span data-ttu-id="ceb85-132">例如，使用可序列化隔离级别来访问内存优化表的事务将对同一个事务一致快照执行所有操作。</span><span class="sxs-lookup"><span data-stu-id="ceb85-132">For example, a transaction using the serializable isolation level to access memory-optimized tables will perform all operations on the same transactionally consistent snapshot.</span></span>

 <span data-ttu-id="ceb85-133">访问内存优化表的事务使用此行版本控制来获取表中行的事务一致快照。</span><span class="sxs-lookup"><span data-stu-id="ceb85-133">Transactions that access memory-optimized tables use this row versioning to obtain a transactionally consistent snapshot of the rows in the tables.</span></span> <span data-ttu-id="ceb85-134">事务中由任何语句读取的数据是在该事务启动时就存在的事务一致版本数据。</span><span class="sxs-lookup"><span data-stu-id="ceb85-134">The data read by any statement in the transaction will be the transactionally consistent version of the data that existed at the time the transaction started.</span></span> <span data-ttu-id="ceb85-135">因此，并发运行的事务所进行的任何修改都对当前事务中的语句不可见。</span><span class="sxs-lookup"><span data-stu-id="ceb85-135">Therefore, any modifications made by concurrently running transactions are not visible to statements in the current transaction.</span></span>

## <a name="optimistic-concurrency-control-for-memory-optimized-tables"></a><span data-ttu-id="ceb85-136">内存优化表的乐观并发控制</span><span class="sxs-lookup"><span data-stu-id="ceb85-136">Optimistic Concurrency Control for Memory-Optimized Tables</span></span>
 <span data-ttu-id="ceb85-137">冲突和失败很少出现，并且有关内存优化表的事务会假定与同时发生的事务间不存在冲突且操作成功。</span><span class="sxs-lookup"><span data-stu-id="ceb85-137">Conflicts and failures are rare and transactions on memory-optimized tables assume there are no conflicts with concurrent transactions and operations succeed.</span></span> <span data-ttu-id="ceb85-138">事务不会对内存优化表使用锁和闩锁，以保证事务隔离。</span><span class="sxs-lookup"><span data-stu-id="ceb85-138">Transactions do not take locks or latches on memory-optimized table to guarantee transaction isolation.</span></span> <span data-ttu-id="ceb85-139">编写器不会阻止读取器。</span><span class="sxs-lookup"><span data-stu-id="ceb85-139">Writers do not block readers.</span></span> <span data-ttu-id="ceb85-140">编写器不会阻止编写器。</span><span class="sxs-lookup"><span data-stu-id="ceb85-140">Writers do not block writers.</span></span> <span data-ttu-id="ceb85-141">相反，事务将在与其他事务不存在冲突的（乐观）假定下继续。</span><span class="sxs-lookup"><span data-stu-id="ceb85-141">Instead, transactions proceed under the (optimistic) assumption that there will be no conflicts with other transactions.</span></span> <span data-ttu-id="ceb85-142">不使用锁和闩锁，也无需等待其他事务完成对相同行的处理，因此能提高性能。</span><span class="sxs-lookup"><span data-stu-id="ceb85-142">Not using locks and latches and not waiting for other transactions to finish processing the same rows improves performance.</span></span>

 <span data-ttu-id="ceb85-143">此外，如果某一事务 (TxA) 读取处于提交过程中的其他事务 (TxB) 已插入或修改的行，则该事务会乐观地假设其他事务将提交而不等待提交发生。</span><span class="sxs-lookup"><span data-stu-id="ceb85-143">In addition, if a transaction (TxA) reads rows that have been inserted or modified by another transaction (TxB) that is in the process of committing, it will optimistically assume the other transaction will commit rather than wait for the commit to occur.</span></span> <span data-ttu-id="ceb85-144">在此情况下，事务 TxA 将对事务 TxB 具有提交依赖关系。</span><span class="sxs-lookup"><span data-stu-id="ceb85-144">In this case, transaction TxA will take a commit dependency on transaction TxB.</span></span>

## <a name="conflict-detection-validation-and-commit-dependency-checks"></a><span data-ttu-id="ceb85-145">冲突检测、验证和提交依赖关系检查</span><span class="sxs-lookup"><span data-stu-id="ceb85-145">Conflict Detection, Validation, and Commit Dependency Checks</span></span>
 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="ceb85-146">检测并发事务之间的冲突以及隔离级别冲突，并终止冲突事务中的一个事务。</span><span class="sxs-lookup"><span data-stu-id="ceb85-146">detects conflicts between concurrent transactions, as well as isolation level violations, and will doom one of the conflicting transactions.</span></span> <span data-ttu-id="ceb85-147">此事务将需要重试。</span><span class="sxs-lookup"><span data-stu-id="ceb85-147">This transaction will need to be retried.</span></span> <span data-ttu-id="ceb85-148"> (有关详细信息，请参阅[内存优化表上的事务重试逻辑指南](../relational-databases/in-memory-oltp/memory-optimized-tables.md)。 ) </span><span class="sxs-lookup"><span data-stu-id="ceb85-148">(For more information, see [Guidelines for Retry Logic for Transactions on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).)</span></span>

 <span data-ttu-id="ceb85-149">系统乐观地假定不存在冲突并且未违反事务隔离。</span><span class="sxs-lookup"><span data-stu-id="ceb85-149">The system optimistically assumes there are no conflicts and no violations of transaction isolation.</span></span> <span data-ttu-id="ceb85-150">如果发生可能在数据库中导致不一致或可能违反事务隔离的任何冲突，则会检测到这些冲突，并且事务终止。</span><span class="sxs-lookup"><span data-stu-id="ceb85-150">If any conflicts occur that may cause inconsistencies in the database or that may violate transaction isolation, these conflicts are detected, and the transaction is terminated.</span></span>

 <span data-ttu-id="ceb85-151">如果检测到冲突，则会终止事务，并且客户端需要重试。</span><span class="sxs-lookup"><span data-stu-id="ceb85-151">If a conflict is detected, the transaction is terminated and the client needs to retry.</span></span>

 <span data-ttu-id="ceb85-152">下表总结了与访问内存优化表的事务相关的错误情况。</span><span class="sxs-lookup"><span data-stu-id="ceb85-152">The following table summarizes the error conditions for transactions that accesses memory-optimized tables.</span></span>

### <a name="error-conditions-for-transactions-accessing-memory-optimized-tables"></a><span data-ttu-id="ceb85-153">访问内存优化表的事务的错误情况。</span><span class="sxs-lookup"><span data-stu-id="ceb85-153">Error conditions for transactions accessing memory-optimized tables.</span></span>

|<span data-ttu-id="ceb85-154">错误</span><span class="sxs-lookup"><span data-stu-id="ceb85-154">Error</span></span>|<span data-ttu-id="ceb85-155">方案</span><span class="sxs-lookup"><span data-stu-id="ceb85-155">Scenario</span></span>|
|-----------|--------------|
|<span data-ttu-id="ceb85-156">写冲突。</span><span class="sxs-lookup"><span data-stu-id="ceb85-156">Write conflict.</span></span> <span data-ttu-id="ceb85-157">尝试更新自该事务启动以来已更新的记录。</span><span class="sxs-lookup"><span data-stu-id="ceb85-157">Attempting to update a record that has been updated since the transaction started.</span></span>|<span data-ttu-id="ceb85-158">对由并发事务更新或删除的行执行 UPDATE 或 DELETE 操作。</span><span class="sxs-lookup"><span data-stu-id="ceb85-158">UPDATE or DELETE a row that has been updated or deleted by a concurrent transaction.</span></span>|
|<span data-ttu-id="ceb85-159">可重复读验证失败。</span><span class="sxs-lookup"><span data-stu-id="ceb85-159">Repeatable read validation failure.</span></span>|<span data-ttu-id="ceb85-160">由事务读取的行自该事务启动以来已更改（更新或删除）。</span><span class="sxs-lookup"><span data-stu-id="ceb85-160">A row that was read by the transaction has changed (updated or deleted) since the transaction started.</span></span> <span data-ttu-id="ceb85-161">可重复读验证通常在使用 REPEATABLE READ 和 SERIALIZABLE 事务隔离级别时进行。</span><span class="sxs-lookup"><span data-stu-id="ceb85-161">Repeatable read validation is typically occurs when using REPEATABLE READ and SERIALIZABLE transaction isolation levels.</span></span>|
|<span data-ttu-id="ceb85-162">可序列化验证失败。</span><span class="sxs-lookup"><span data-stu-id="ceb85-162">Serializable validation failure.</span></span>|<span data-ttu-id="ceb85-163">新的（虚拟）行自事务启动以来已插入到该事务中的一个扫描范围内。</span><span class="sxs-lookup"><span data-stu-id="ceb85-163">A new (phantom) row has been inserted in one of the scan ranges in the transaction, since the transaction started.</span></span> <span data-ttu-id="ceb85-164">如果行在事务启动之前已提交给数据库，则该行应该对该事务可见。</span><span class="sxs-lookup"><span data-stu-id="ceb85-164">The row would have been visible to the transaction if the row had been committed to the database before the transaction started.</span></span> <span data-ttu-id="ceb85-165">SERIALIZABLE 验证通常在使用 SERIALIZABLE 隔离并验证 PRIMARY KEY 约束时进行。</span><span class="sxs-lookup"><span data-stu-id="ceb85-165">SERIALIZABLE validation typically occurs when using SERIALIZABLE isolation and validating PRIMARY KEY constraints.</span></span>|
|<span data-ttu-id="ceb85-166">提交依赖关系失败。</span><span class="sxs-lookup"><span data-stu-id="ceb85-166">Commit dependency failure.</span></span>|<span data-ttu-id="ceb85-167">该事务依赖于其他事务，而后者由于此表中的一个失败、内存不足的情况或由于未能提交到事务日志而未能提交。</span><span class="sxs-lookup"><span data-stu-id="ceb85-167">The transaction took a dependency on another transaction that failed to commit, either due to one of the failures in this table, an out-of-memory condition, or due to failure to commit to the transaction log.</span></span> <span data-ttu-id="ceb85-168">读/写事务和只读事务可能会发生此失败。</span><span class="sxs-lookup"><span data-stu-id="ceb85-168">This failure can occur with both read/write and read-only transactions.</span></span>|

### <a name="transaction-lifetime"></a><span data-ttu-id="ceb85-169">事务生存期</span><span class="sxs-lookup"><span data-stu-id="ceb85-169">Transaction Lifetime</span></span>
 <span data-ttu-id="ceb85-170">上表中提及的失败可能会在事务的不同时间点发生。</span><span class="sxs-lookup"><span data-stu-id="ceb85-170">The failures mentioned in the previous table can occur at different points during a transaction.</span></span> <span data-ttu-id="ceb85-171">下图说明了访问内存优化表的事务的各个阶段。</span><span class="sxs-lookup"><span data-stu-id="ceb85-171">The following figure illustrates the phases of a transaction that accesses memory-optimized tables.</span></span>

 <span data-ttu-id="ceb85-172">![事务的生存期。](../../2014/database-engine/media/hekaton-transactions.gif "事务的生存期。")</span><span class="sxs-lookup"><span data-stu-id="ceb85-172">![Lifetime of a transaction.](../../2014/database-engine/media/hekaton-transactions.gif "Lifetime of a transaction.")</span></span>
<span data-ttu-id="ceb85-173">访问内存优化表的事务的生存期。</span><span class="sxs-lookup"><span data-stu-id="ceb85-173">Lifetime of a transaction that accesses memory-optimized tables.</span></span>

#### <a name="regular-processing"></a><span data-ttu-id="ceb85-174">常规处理</span><span class="sxs-lookup"><span data-stu-id="ceb85-174">Regular Processing</span></span>
 <span data-ttu-id="ceb85-175">在此阶段中，将会执行用户发出的 [!INCLUDE[tsql](../includes/tsql-md.md)] 语句。</span><span class="sxs-lookup"><span data-stu-id="ceb85-175">During this phase, the user-issued [!INCLUDE[tsql](../includes/tsql-md.md)] statements are executed.</span></span> <span data-ttu-id="ceb85-176">从表读取行，然后将新行版本写入数据库。</span><span class="sxs-lookup"><span data-stu-id="ceb85-176">Rows are read from the tables, and new row versions are written to the database.</span></span> <span data-ttu-id="ceb85-177">该事务与所有其他并发事务隔离。</span><span class="sxs-lookup"><span data-stu-id="ceb85-177">The transaction is isolated from all other concurrent transactions.</span></span> <span data-ttu-id="ceb85-178">该事务使用自该事务启动以来存在的内存优化表的快照。</span><span class="sxs-lookup"><span data-stu-id="ceb85-178">The transaction uses the snapshot of the memory-optimized tables that exists at the start of the transaction.</span></span>

 <span data-ttu-id="ceb85-179">在事务的此阶段对表进行的写入对其他事务尚不可见，不过有一个例外：行更新和删除对其他事务中的更新和删除操作可见，以便检测写冲突。</span><span class="sxs-lookup"><span data-stu-id="ceb85-179">Writes to the tables in this phase of the transaction are not yet visible to other transactions, with one exception: row updates and deletes are visible to update and delete operations in other transactions, in order to detect write conflicts.</span></span>

 <span data-ttu-id="ceb85-180">如果删除或更新操作发现自该事务逻辑启动以来已更新或删除一行，则操作会失败，并显示错误为 41302。</span><span class="sxs-lookup"><span data-stu-id="ceb85-180">If an update or delete operation sees that a row has been updated or deleted since the logical start of the transaction, the operation will fail with error 41302.</span></span> <span data-ttu-id="ceb85-181">错误 41302 的消息为“当前事务尝试更新的 X 表中的记录自此事务启动后已更新。</span><span class="sxs-lookup"><span data-stu-id="ceb85-181">The message for error 41302 is "The current transaction attempted to update a record in table X that has been updated since this transaction started.</span></span> <span data-ttu-id="ceb85-182">该事务已中止。”</span><span class="sxs-lookup"><span data-stu-id="ceb85-182">The transaction was aborted."</span></span>

 <span data-ttu-id="ceb85-183">此错误会终止事务（即使 XACT_ABORT 为 OFF 也是如此），这意味着事务将在用户会话结束时回滚。</span><span class="sxs-lookup"><span data-stu-id="ceb85-183">This error dooms the transaction (even if XACT_ABORT is OFF), meaning that the transaction will be rolled back when the user session ends.</span></span> <span data-ttu-id="ceb85-184">失败的事务无法提交，仅支持不写入日志和不访问内存优化表的读取操作。</span><span class="sxs-lookup"><span data-stu-id="ceb85-184">Doomed transactions cannot be committed and only support read operations that do not write to the log and do not access memory-optimized tables.</span></span>

#####  <a name="commit-dependencies"></a><a name="cd"></a><span data-ttu-id="ceb85-185">提交依赖关系</span><span class="sxs-lookup"><span data-stu-id="ceb85-185">Commit Dependencies</span></span>
 <span data-ttu-id="ceb85-186">在常规处理过程中，事务可以读取由其他事务写入并处于验证或提交阶段、但尚未提交的行。</span><span class="sxs-lookup"><span data-stu-id="ceb85-186">During regular processing, a transaction can read rows written by other transactions that are in the validation or commit phase, but have not yet committed.</span></span> <span data-ttu-id="ceb85-187">这些行是可见的，因为在验证阶段开始时已分配事务的逻辑结束时间。</span><span class="sxs-lookup"><span data-stu-id="ceb85-187">The rows are visible because the logical end time of the transactions has been assigned at the start of the validation phase.</span></span>

 <span data-ttu-id="ceb85-188">如果事务读取这类未提交的行，则会对该事务形成提交依赖关系。</span><span class="sxs-lookup"><span data-stu-id="ceb85-188">If a transaction reads such uncommitted rows, it will take a commit dependency on that transaction.</span></span> <span data-ttu-id="ceb85-189">这具有两种主要含义：</span><span class="sxs-lookup"><span data-stu-id="ceb85-189">This has two main implications:</span></span>

-   <span data-ttu-id="ceb85-190">事务在所依赖的事务提交之前无法提交。</span><span class="sxs-lookup"><span data-stu-id="ceb85-190">A transaction cannot commit until the transactions it depends on have committed.</span></span> <span data-ttu-id="ceb85-191">换言之，在所有依赖关系都已清除之前，该事务无法进入提交阶段。</span><span class="sxs-lookup"><span data-stu-id="ceb85-191">In other words, it cannot enter the commit phase, until all dependencies have cleared.</span></span>

-   <span data-ttu-id="ceb85-192">此外，在所有依赖关系都已清除之前，结果集不会返回给客户端。</span><span class="sxs-lookup"><span data-stu-id="ceb85-192">In addition, result sets are not returned to the client until all dependencies have cleared.</span></span> <span data-ttu-id="ceb85-193">这会防止客户端观察未提交的数据。</span><span class="sxs-lookup"><span data-stu-id="ceb85-193">This prevents the client from observing uncommitted data.</span></span>

 <span data-ttu-id="ceb85-194">如果任何依赖的事务无法提交，则会发生提交依赖关系失败。</span><span class="sxs-lookup"><span data-stu-id="ceb85-194">If any of the dependent transactions fails to commit, there is a commit dependency failure.</span></span> <span data-ttu-id="ceb85-195">这意味着该事务无法提交，并显示错误 41301（“当前事务与其存在依赖关系的以前的事务已中止，并且当前事务不再提交。”）。</span><span class="sxs-lookup"><span data-stu-id="ceb85-195">This means the transaction will fail to commit with error 41301 ("A previous transaction that the current transaction took a dependency on has aborted, and the current transaction can no longer commit.").</span></span>

#### <a name="validation-phase"></a><span data-ttu-id="ceb85-196">验证阶段</span><span class="sxs-lookup"><span data-stu-id="ceb85-196">Validation Phase</span></span>
 <span data-ttu-id="ceb85-197">在验证阶段，系统会验证请求的事务隔离级别所需的假定在该事务的逻辑开始和逻辑结束时间之间是否为 true。</span><span class="sxs-lookup"><span data-stu-id="ceb85-197">During the validation phase, the system validates that the assumptions necessary for the requested transaction isolation level were true between the logical start and logical end of the transaction.</span></span>

 <span data-ttu-id="ceb85-198">在验证阶段开始时，将向事务分配逻辑结束时间。</span><span class="sxs-lookup"><span data-stu-id="ceb85-198">At the start of the validation phase, the transaction is assigned a logical end time.</span></span> <span data-ttu-id="ceb85-199">写入数据库的行版本会在此逻辑结束时对其他事务可见。</span><span class="sxs-lookup"><span data-stu-id="ceb85-199">The row versions written in the database become visible to other transactions at the logical end time.</span></span> <span data-ttu-id="ceb85-200">有关详细信息，请参阅[提交依赖关系](#cd)。</span><span class="sxs-lookup"><span data-stu-id="ceb85-200">For more information, see [Commit Dependencies](#cd).</span></span>

##### <a name="repeatable-read-validation"></a><span data-ttu-id="ceb85-201">可重复读验证</span><span class="sxs-lookup"><span data-stu-id="ceb85-201">Repeatable Read Validation</span></span>
 <span data-ttu-id="ceb85-202">如果事务的隔离级别是可重复读或可序列化的，或者如果在可重复读或可序列化隔离下访问表 (请参阅) 的[事务隔离级别](../../2014/database-engine/transaction-isolation-levels.md)中的单个操作的隔离部分，系统会验证读取是否可重复。</span><span class="sxs-lookup"><span data-stu-id="ceb85-202">If the isolation level of the transaction is REPEATABLE READ or SERIALIZABLE, or if tables are accessed under REPEATABLE READ or SERIALIZABLE isolation (for more information, see the section on Isolation of Individual Operations in [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md)), the system validates that the reads are repeatable.</span></span> <span data-ttu-id="ceb85-203">这意味着它会验证由事务读取的行的版本在事务逻辑结束时是否仍是有效行版本。</span><span class="sxs-lookup"><span data-stu-id="ceb85-203">This means it validates that the versions of the rows read by the transaction are still valid row versions at the logical end time of the transaction.</span></span>

 <span data-ttu-id="ceb85-204">如果任何行已更新或更改，则事务无法提交，并显示错误 41305（“由于可重复读验证失败，当前事务无法提交。”）。</span><span class="sxs-lookup"><span data-stu-id="ceb85-204">If any of the rows have been updated or changed, the transaction fails to commit with error 41305 ("The current transaction failed to commit due to a repeatable read validation failure.").</span></span>

 <span data-ttu-id="ceb85-205">如果表在插入、更新或删除之后以及事务提交之前被删除，则也可能会发生此错误。</span><span class="sxs-lookup"><span data-stu-id="ceb85-205">This error can also occur if a table is dropped after an insert, update, or delete operation and before the transaction commits.</span></span> <span data-ttu-id="ceb85-206">这仅适用于本机编译存储过程中的插入、更新或删除操作。</span><span class="sxs-lookup"><span data-stu-id="ceb85-206">This applies only to insert, update, or delete operations in natively compiled stored procedures.</span></span> <span data-ttu-id="ceb85-207">通过解释的 [!INCLUDE[tsql](../includes/tsql-md.md)] 执行的这类写操作会导致 DROP TABLE 语句阻塞并等待事务提交。</span><span class="sxs-lookup"><span data-stu-id="ceb85-207">Such write operations performed through interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] cause the DROP TABLE statement to block and wait until the transaction commits.</span></span>

##### <a name="serializable-validation"></a><span data-ttu-id="ceb85-208">可序列化验证</span><span class="sxs-lookup"><span data-stu-id="ceb85-208">Serializable Validation</span></span>
 <span data-ttu-id="ceb85-209">将在两种情况下执行可序列化验证：</span><span class="sxs-lookup"><span data-stu-id="ceb85-209">Serializable validation is performed in two cases:</span></span>

-   <span data-ttu-id="ceb85-210">如果事务的隔离级别为 SERIALIZABLE，或者在 SERIALIZABLE 隔离下对表进行访问。</span><span class="sxs-lookup"><span data-stu-id="ceb85-210">If the isolation level of the transaction is SERIALIZABLE or tables are accessed under SERIALIZABLE isolation.</span></span>

-   <span data-ttu-id="ceb85-211">如果使用唯一索引（例如，为 PRIMARY KEY 约束创建的索引）来插入行。</span><span class="sxs-lookup"><span data-stu-id="ceb85-211">If rows are inserted in a unique index, such as the index created for a PRIMARY KEY constraint.</span></span> <span data-ttu-id="ceb85-212">系统会验证没有并发插入具有相同键的行。</span><span class="sxs-lookup"><span data-stu-id="ceb85-212">The system validates that no rows with the same key have been concurrently inserted.</span></span>

 <span data-ttu-id="ceb85-213">系统会验证没有将虚拟行写入数据库。</span><span class="sxs-lookup"><span data-stu-id="ceb85-213">The system validates that no phantom rows have been written to the database.</span></span> <span data-ttu-id="ceb85-214">将对由事务执行的读操作进行评估，以确定没有在这些读操作的扫描范围内插入新行。</span><span class="sxs-lookup"><span data-stu-id="ceb85-214">The read operations performed by the transaction are evaluated to determine that no new rows were inserted in the scan ranges of these read operations.</span></span>

 <span data-ttu-id="ceb85-215">使用唯一索引插入键包括一个隐式读操作，用于确定没有与该键重复的键。</span><span class="sxs-lookup"><span data-stu-id="ceb85-215">Insertion of a key in a unique index includes an implicit read operation, to determine that the key is not a duplicate.</span></span> <span data-ttu-id="ceb85-216">唯一索引的可序列化验证可确保这些索引不能重复，以免两个事务并发插入相同的键。</span><span class="sxs-lookup"><span data-stu-id="ceb85-216">Serializable validation for unique indexes ensures these indexes cannot have duplicates in case two transactions concurrently insert the same key.</span></span>

 <span data-ttu-id="ceb85-217">如果检测到虚拟行，则事务无法提交，并显示错误 41325（“由于可序列化验证失败，当前事务无法提交。”）。</span><span class="sxs-lookup"><span data-stu-id="ceb85-217">If phantom rows are detected, the transaction fails to commit with error 41325 ("The current transaction failed to commit due to a serializable validation failure.").</span></span>

#### <a name="commit-processing"></a><span data-ttu-id="ceb85-218">提交处理</span><span class="sxs-lookup"><span data-stu-id="ceb85-218">Commit Processing</span></span>
 <span data-ttu-id="ceb85-219">如果验证成功且所有事务依赖关系都已清除，则该事务会进入提交处理阶段。</span><span class="sxs-lookup"><span data-stu-id="ceb85-219">If validation succeeds and all transaction dependencies clear, the transaction enters the commit processing phase.</span></span> <span data-ttu-id="ceb85-220">在此阶段中，对持久表的更改会写入日志，随后日志会写入磁盘以确保持续性。</span><span class="sxs-lookup"><span data-stu-id="ceb85-220">During this phase the changes to durable tables are written to the log, and the log is written to disk, to ensure durability.</span></span> <span data-ttu-id="ceb85-221">将事务的日志记录写入磁盘后，控件会返回到客户端。</span><span class="sxs-lookup"><span data-stu-id="ceb85-221">Once the log record for the transaction has been written to disk, control is returned to the client.</span></span>

 <span data-ttu-id="ceb85-222">将清除此事务的所有提交依赖关系，并且等待此事务提交的所有事务都可以继续。</span><span class="sxs-lookup"><span data-stu-id="ceb85-222">All commit dependencies on this transaction are cleared, and all transactions that had been waiting for this transaction to commit can proceed.</span></span>

## <a name="limitations"></a><span data-ttu-id="ceb85-223">限制</span><span class="sxs-lookup"><span data-stu-id="ceb85-223">Limitations</span></span>

-   <span data-ttu-id="ceb85-224">内存优化表不支持跨数据库事务。</span><span class="sxs-lookup"><span data-stu-id="ceb85-224">Cross-database transactions are not supported with memory-optimized tables.</span></span> <span data-ttu-id="ceb85-225">访问内存优化表的每个事务都无法访问多个数据库（对 tempdb 进行的读/写访问以及对系统主数据库进行的只读访问除外）。</span><span class="sxs-lookup"><span data-stu-id="ceb85-225">Every transaction that accesses memory-optimized tables cannot access more than one database, with the exception of read-write access to tempdb and read-only access to the system database master.</span></span>

-   <span data-ttu-id="ceb85-226">内存优化表不支持分布式事务。</span><span class="sxs-lookup"><span data-stu-id="ceb85-226">Distributed transactions are not supported with memory-optimized tables.</span></span> <span data-ttu-id="ceb85-227">以 BEGIN DISTRIBUTED TRANSACTION 开头的分布式事务无法访问内存优化表。</span><span class="sxs-lookup"><span data-stu-id="ceb85-227">Distributed transactions started with BEGIN DISTRIBUTED TRANSACTION cannot access memory-optimized tables.</span></span>

-   <span data-ttu-id="ceb85-228">内存优化表不支持锁定。</span><span class="sxs-lookup"><span data-stu-id="ceb85-228">Memory-optimized tables do not support locking.</span></span> <span data-ttu-id="ceb85-229">内存优化表不支持通过锁提示（如 TABLOCK、XLOCK、ROWLOCK）实现的显式锁。</span><span class="sxs-lookup"><span data-stu-id="ceb85-229">Explicit locks through locking hints (such as TABLOCK, XLOCK, ROWLOCK) are not supported with memory-optimized tables.</span></span>

## <a name="see-also"></a><span data-ttu-id="ceb85-230">另请参阅</span><span class="sxs-lookup"><span data-stu-id="ceb85-230">See Also</span></span>
 [<span data-ttu-id="ceb85-231">了解内存优化表的事务</span><span class="sxs-lookup"><span data-stu-id="ceb85-231">Understanding Transactions on Memory-Optimized Tables</span></span>](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md)


