---
title: 活动辅助副本：可读辅助副本 (Always On 可用性组) |Microsoft Docs
ms.custom: ''
ms.date: 10/27/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: high-availability
ms.topic: conceptual
helpviewer_keywords:
- connection access to availability replicas
- Availability Groups [SQL Server], availability replicas
- Availability Groups [SQL Server], readable secondary replicas
- active secondary replicas [SQL Server], read-only access to
- readable secondary replicas
- Availability Groups [SQL Server], active secondary replicas
ms.assetid: 78f3f81a-066a-4fff-b023-7725ff874fdf
author: MashaMSFT
ms.author: mathoma
ms.openlocfilehash: 8b85704b8110eb84ea6f4c33dfa79694112c2328
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/04/2020
ms.locfileid: "87591600"
---
# <a name="active-secondaries-readable-secondary-replicas-always-on-availability-groups"></a><span data-ttu-id="69855-102">活动次要副本：可读次要副本（AlwaysOn 可用性组）</span><span class="sxs-lookup"><span data-stu-id="69855-102">Active Secondaries: Readable Secondary Replicas (Always On Availability Groups)</span></span>
  <span data-ttu-id="69855-103">[!INCLUDE[ssHADR](../../../includes/sshadr-md.md)] 活动辅助功能包括支持对一个或多个次要副本的只读访问（可读次要副本）。</span><span class="sxs-lookup"><span data-stu-id="69855-103">The [!INCLUDE[ssHADR](../../../includes/sshadr-md.md)] active secondary capabilities include support for read-only access to one or more secondary replicas (*readable secondary replicas*).</span></span> <span data-ttu-id="69855-104">可读辅助副本允许对其所有辅助数据库的只读访问。</span><span class="sxs-lookup"><span data-stu-id="69855-104">A readable secondary replica allows read-only access to all its secondary databases.</span></span> <span data-ttu-id="69855-105">但是，可读辅助数据库并非设置为只读。</span><span class="sxs-lookup"><span data-stu-id="69855-105">However, readable secondary databases are not set to read-only.</span></span> <span data-ttu-id="69855-106">它们是动态的。</span><span class="sxs-lookup"><span data-stu-id="69855-106">They are dynamic.</span></span> <span data-ttu-id="69855-107">当对相应主数据库的更改应用到某一给定的辅助数据库时，该辅助数据库将更改。</span><span class="sxs-lookup"><span data-stu-id="69855-107">A given secondary database changes as changes on the corresponding primary database are applied to the secondary database.</span></span> <span data-ttu-id="69855-108">对于典型的辅助副本，包括持久内存优化表，辅助数据库中的数据接近实时。</span><span class="sxs-lookup"><span data-stu-id="69855-108">For a typical secondary replica, the data, including durable memory optimized tables, in the secondary databases is in near real time.</span></span> <span data-ttu-id="69855-109">此外，全文检索与辅助数据库同步。</span><span class="sxs-lookup"><span data-stu-id="69855-109">Furthermore, full-text indexes are synchronized with the secondary databases.</span></span> <span data-ttu-id="69855-110">在许多情况下，主数据库和相应的辅助数据库之间的数据滞后时间只有几秒钟。</span><span class="sxs-lookup"><span data-stu-id="69855-110">In many circumstances, data latency between a primary database and the corresponding secondary database is only a few seconds.</span></span>  
  
 <span data-ttu-id="69855-111">在主数据库中进行的安全设置会对辅助数据库永久保留。</span><span class="sxs-lookup"><span data-stu-id="69855-111">Security settings that occur in the primary databases are persisted to the secondary databases.</span></span> <span data-ttu-id="69855-112">这包括用户、数据库角色和应用程序角色及其各自的权限；如果对主数据库启用了透明数据加密 (TDE)，还将包括 TDE。</span><span class="sxs-lookup"><span data-stu-id="69855-112">This includes users, database roles, and applications roles together with their respective permissions and transparent data encryption (TDE), if enabled on the primary database.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="69855-113">尽管您无法将数据写入辅助数据库，但可以在承载辅助副本的服务器实例上写入读写数据库，包括用户数据库和 **tempdb**之类的系统数据库。</span><span class="sxs-lookup"><span data-stu-id="69855-113">Though you cannot write data to secondary databases, you can write to read-write databases on the server instance that hosts the secondary replica, including user databases and system databases such as **tempdb**.</span></span>  
  
 [!INCLUDE[ssHADR](../../../includes/sshadr-md.md)] <span data-ttu-id="69855-114">还支持对可读辅助副本（*只读路由*）的读意向连接请求的重新路由。</span><span class="sxs-lookup"><span data-stu-id="69855-114">also supports the re-routing of read-intent connection requests to a readable secondary replica (*read-only routing*).</span></span> <span data-ttu-id="69855-115">有关只读路由的详细信息，请参阅 [使用侦听程序连接到只读次要副本（只读路由）](../../listeners-client-connectivity-application-failover.md#ConnectToSecondary)。</span><span class="sxs-lookup"><span data-stu-id="69855-115">For information about read-only routing, see [Using a Listener to Connect to a Read-Only Secondary Replica (Read-Only Routing)](../../listeners-client-connectivity-application-failover.md#ConnectToSecondary).</span></span>  
  
 
  
##  <a name="benefits"></a><a name="bkmk_Benefits"></a> <span data-ttu-id="69855-116">优势</span><span class="sxs-lookup"><span data-stu-id="69855-116">Benefits</span></span>  
 <span data-ttu-id="69855-117">指定与可读辅助副本的只读连接具有以下优点：</span><span class="sxs-lookup"><span data-stu-id="69855-117">Directing read-only connections to readable secondary replicas provides the following benefits:</span></span>  
  
-   <span data-ttu-id="69855-118">从主副本卸下辅助副本只读工作负荷，以便将资源用于关键任务工作负荷。</span><span class="sxs-lookup"><span data-stu-id="69855-118">Offloads your secondary read-only workloads from your primary replica, which conserves its resources for your mission critical workloads.</span></span> <span data-ttu-id="69855-119">如果具有关键任务读工作负荷或不能滞后的工作负荷，应在主副本上运行它。</span><span class="sxs-lookup"><span data-stu-id="69855-119">If you have mission critical read-workload or the workload that cannot tolerate latency, you should run it on the primary.</span></span>  
  
-   <span data-ttu-id="69855-120">提高承载可读辅助副本的系统的投资回报率。</span><span class="sxs-lookup"><span data-stu-id="69855-120">Improves your return on investment for the systems that host readable secondary replicas.</span></span>  
  
 <span data-ttu-id="69855-121">此外，可读辅助副本对只读操作提供稳定的支持，如下所示：</span><span class="sxs-lookup"><span data-stu-id="69855-121">In addition, readable secondaries provide robust support for read-only operations, as follows:</span></span>  
  
-   <span data-ttu-id="69855-122">有关可读辅助数据库的自动临时统计信息可优化对基于磁盘的表的只读查询。</span><span class="sxs-lookup"><span data-stu-id="69855-122">Automatic temporary statistics on readable secondary database optimize read-only queries on disk-based tables.</span></span> <span data-ttu-id="69855-123">对于内存优化表，将自动创建缺少的统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-123">For memory-optimized tables, the missing statistics are created automatically.</span></span> <span data-ttu-id="69855-124">但不会自动更新旧统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-124">However, there is no auto-update of stale statistics.</span></span> <span data-ttu-id="69855-125">您需要手动更新主副本的统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-125">You will need to manually update the statistics on the primary replica.</span></span> <span data-ttu-id="69855-126">有关详细信息，请参阅本主题后面的 [只读访问数据库的统计信息](#Read-OnlyStats)。</span><span class="sxs-lookup"><span data-stu-id="69855-126">For more information, see [Statistics for Read-Only Access Databases](#Read-OnlyStats), later in this topic.</span></span>  
  
-   <span data-ttu-id="69855-127">基于磁盘的表的只读工作负荷使用行版本控制来消除辅助数据库上的阻塞争用。</span><span class="sxs-lookup"><span data-stu-id="69855-127">Read-only workloads for disk-based tables use row versioning to remove blocking contention on the secondary databases.</span></span> <span data-ttu-id="69855-128">对辅助数据库运行的所有查询都自动映射到快照隔离事务级别，即使在显式设置了其他事务隔离级别时也是如此。</span><span class="sxs-lookup"><span data-stu-id="69855-128">All queries that run against the secondary databases are automatically mapped to snapshot isolation transaction level, even when other transaction isolation levels are explicitly set.</span></span> <span data-ttu-id="69855-129">此外，所有锁定提示都将被忽略。</span><span class="sxs-lookup"><span data-stu-id="69855-129">Also, all locking hints are ignored.</span></span> <span data-ttu-id="69855-130">这消除了读取器/编写器的争用。</span><span class="sxs-lookup"><span data-stu-id="69855-130">This eliminates reader/writer contention.</span></span>  
  
-   <span data-ttu-id="69855-131">基于持久的内存优化表的只读工作负荷访问数据的方式与主数据库中的访问方式相同，使用具有相同事务隔离级别限制的本机存储过程或 SQL 互操作性。</span><span class="sxs-lookup"><span data-stu-id="69855-131">Read-only workloads for memory-optimized durable tables access the data in exactly the same way it is accessed on the primary database, using native stored procedures or SQL Interoperability with the same transaction isolation level limitations.</span></span> <span data-ttu-id="69855-132">对主副本运行的报表工作负荷或只读查询可以直接用于辅助副本，无需任何更改。</span><span class="sxs-lookup"><span data-stu-id="69855-132">Reporting workload or read-only queries running on the primary replica can be run on the secondary replica without requiring any changes.</span></span> <span data-ttu-id="69855-133">同样，对辅助副本运行的报表工作负荷或只读查询也可以直接用于主副本，无需任何更改。</span><span class="sxs-lookup"><span data-stu-id="69855-133">Similarly, a reporting workload or read-only queries running on a secondary replica can be run on the primary replica without requiring any changes.</span></span>  <span data-ttu-id="69855-134">与基于磁盘的表相似，对辅助数据库运行的所有查询都自动映射到快照隔离事务级别，即使在显式设置了其他事务隔离级别时也是如此。</span><span class="sxs-lookup"><span data-stu-id="69855-134">Similar to disk-based tables, all queries that run against the secondary databases are automatically mapped to snapshot isolation transaction level, even when other transaction isolation levels are explicitly set.</span></span>  
  
-   <span data-ttu-id="69855-135">对于辅助副本上的基于磁盘的表和内存优化表类型，都可以对表变量执行 DML 操作。</span><span class="sxs-lookup"><span data-stu-id="69855-135">DML operations are allowed on table variables both for disk-based and memory-optimized table types on the secondary replica.</span></span>  
  
##  <a name="prerequisites-for-the-availability-group"></a><a name="bkmk_Prerequisites"></a> <span data-ttu-id="69855-136">可用性组先决条件</span><span class="sxs-lookup"><span data-stu-id="69855-136">Prerequisites for the Availability Group</span></span>  
  
-   <span data-ttu-id="69855-137">**可读辅助副本（必需）**</span><span class="sxs-lookup"><span data-stu-id="69855-137">**Readable secondary replicas (required)**</span></span>  
  
     <span data-ttu-id="69855-138">数据库管理员需要配置一个或多个副本，这样，在辅助角色下运行时，可允许所有连接（仅针对只读访问）或只允许读意向连接。</span><span class="sxs-lookup"><span data-stu-id="69855-138">The database administrator needs to configure one or more replicas so that, when running under the secondary role, they allow either all connections (just for read-only access) or only read-intent connections.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="69855-139">或者，数据库管理员可以配置任何可用性副本，以便在主角色下运行时排除只读连接。</span><span class="sxs-lookup"><span data-stu-id="69855-139">Optionally, the database administrator can configure any of the availability replicas to exclude read-only connections when running under the primary role.</span></span>  
  
     <span data-ttu-id="69855-140">有关详细信息，请参阅本主题后面的 [关于对可用性副本的客户端连接访问 (SQL Server)](about-client-connection-access-to-availability-replicas-sql-server.md)之类的系统数据库。</span><span class="sxs-lookup"><span data-stu-id="69855-140">For more information, see [About Client Connection Access to Availability Replicas &#40;SQL Server&#41;](about-client-connection-access-to-availability-replicas-sql-server.md).</span></span>  
  
-   <span data-ttu-id="69855-141">**可用性组侦听器**</span><span class="sxs-lookup"><span data-stu-id="69855-141">**Availability group listener**</span></span>  
  
     <span data-ttu-id="69855-142">为支持只读路由，可用性组必须具备 [可用性组侦听程序](../../listeners-client-connectivity-application-failover.md)。</span><span class="sxs-lookup"><span data-stu-id="69855-142">To support read-only routing, an availability group must possess an [availability group listener](../../listeners-client-connectivity-application-failover.md).</span></span> <span data-ttu-id="69855-143">只读客户端必须将其连接请求定向到此侦听器，并且客户端的连接字符串必须将应用程序意向指定为“只读”。</span><span class="sxs-lookup"><span data-stu-id="69855-143">The read-only client must direct its connection requests to this listener, and the client's connection string must specify the application intent as "read-only."</span></span> <span data-ttu-id="69855-144">也就是说，它们必须是 *读意向连接请求*。</span><span class="sxs-lookup"><span data-stu-id="69855-144">That is, they must be *read-intent connection requests*.</span></span>  
  
-   <span data-ttu-id="69855-145">**只读路由**</span><span class="sxs-lookup"><span data-stu-id="69855-145">**Read only routing**</span></span>  
  
     <span data-ttu-id="69855-146">“只读路由” 指的是 SQL Server 将定向到可用性组侦听器的传入的读意向连接请求路由到可用的可读辅助副本的能力。</span><span class="sxs-lookup"><span data-stu-id="69855-146">*Read-only routing* refers to the ability of SQL Server to route incoming read-intent connection requests, that are directed to an availability group listener, to an available readable secondary replica.</span></span> <span data-ttu-id="69855-147">只读路由的先决条件如下：</span><span class="sxs-lookup"><span data-stu-id="69855-147">The prerequisites for read-only routing are as follows:</span></span>  
  
    -   <span data-ttu-id="69855-148">为支持只读路由，可读辅助副本需要一个只读路由 URL。</span><span class="sxs-lookup"><span data-stu-id="69855-148">To support read-only routing, a readable secondary replica requires a read-only routing URL.</span></span> <span data-ttu-id="69855-149">此 URL 仅在本地副本在辅助角色下运行时起作用。</span><span class="sxs-lookup"><span data-stu-id="69855-149">This URL takes effect only when the local replica is running under the secondary role.</span></span> <span data-ttu-id="69855-150">必须根据需要在逐个副本的基础上指定只读路由 URL。</span><span class="sxs-lookup"><span data-stu-id="69855-150">The read-only routing URL must be specified on a replica-by-replica basis, as needed.</span></span> <span data-ttu-id="69855-151">每个只读路由 URL 都用于将读意向请求路由到一个特定的可读辅助副本。</span><span class="sxs-lookup"><span data-stu-id="69855-151">Each read-only routing URL is used for routing read-intent connection requests to a specific readable secondary replica.</span></span> <span data-ttu-id="69855-152">通常，向每个可读辅助副本分配一个只读路由 URL。</span><span class="sxs-lookup"><span data-stu-id="69855-152">Typically, every readable secondary replica is assigned a read-only routing URL.</span></span>  
  
    -   <span data-ttu-id="69855-153">要在其作为主副本时支持只读路由的每个可用性副本都要求一个只读路由列表。</span><span class="sxs-lookup"><span data-stu-id="69855-153">Each availability replica that is to support read-only routing when it is the primary replica requires a read-only routing list.</span></span> <span data-ttu-id="69855-154">一个给定的只读路由列表仅在本地副本在主角色下运行时才起作用。</span><span class="sxs-lookup"><span data-stu-id="69855-154">A given read-only routing list takes effect only when the local replica is running under the primary role.</span></span> <span data-ttu-id="69855-155">必须根据需要在逐个副本的基础上指定此列表。</span><span class="sxs-lookup"><span data-stu-id="69855-155">This list must be specified on a replica-by-replica basis, as needed.</span></span> <span data-ttu-id="69855-156">通常，每个只读路由列表中将包含各只读路由 URL，并且在列表的末尾具有本地副本的 URL。</span><span class="sxs-lookup"><span data-stu-id="69855-156">Typically, each read-only routing list would contain every read-only routing URL, with the URL of the local replica at the end of the list.</span></span>  
  
        > [!NOTE]  
        >  <span data-ttu-id="69855-157">读意向连接请求将被路由到当前主副本的只读路由列表上的第一个可用可读辅助副本。</span><span class="sxs-lookup"><span data-stu-id="69855-157">Read-intent connection requests are routed to the first available readable secondary on the read-only routing list of the current primary replica.</span></span> <span data-ttu-id="69855-158">没有负载平衡。</span><span class="sxs-lookup"><span data-stu-id="69855-158">There is no load balancing.</span></span>  
  
     <span data-ttu-id="69855-159">有关详细信息，请参阅 [为可用性组配置只读路由 (SQL Server)](configure-read-only-routing-for-an-availability-group-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="69855-159">For more information, see [Configure Read-Only Routing for an Availability Group &#40;SQL Server&#41;](configure-read-only-routing-for-an-availability-group-sql-server.md).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="69855-160">有关可用性组侦听程序的信息，以及只读路由的详细信息，请参阅 [可用性组侦听程序、客户端连接和应用程序故障转移 (SQL Server)](../../listeners-client-connectivity-application-failover.md)。</span><span class="sxs-lookup"><span data-stu-id="69855-160">For information about availability group listeners and more information about read-only routing, see [Availability Group Listeners, Client Connectivity, and Application Failover &#40;SQL Server&#41;](../../listeners-client-connectivity-application-failover.md).</span></span>  
  
##  <a name="limitations-and-restrictions"></a><a name="bkmk_LimitationsRestrictions"></a> <span data-ttu-id="69855-161">限制和局限</span><span class="sxs-lookup"><span data-stu-id="69855-161">Limitations and Restrictions</span></span>  
 <span data-ttu-id="69855-162">不完全支持某些操作，如下所示：</span><span class="sxs-lookup"><span data-stu-id="69855-162">Some operations are not fully supported, as follows:</span></span>  
  
-   <span data-ttu-id="69855-163">当启用可读副本以便读取时，它便开始接收与其辅助数据库的连接。</span><span class="sxs-lookup"><span data-stu-id="69855-163">As soon as a readable replica is enabled for read, it can start accepting connections to its secondary databases.</span></span> <span data-ttu-id="69855-164">但是，如果在主数据库上有活动事务，行版本将不会在相应的辅助数据库上完全可用。</span><span class="sxs-lookup"><span data-stu-id="69855-164">However, if any active transactions exist on a primary database, the row versions will not be fully available on the corresponding secondary database.</span></span> <span data-ttu-id="69855-165">必须提交或回滚在配置辅助副本时主副本上存在的所有活动事务。</span><span class="sxs-lookup"><span data-stu-id="69855-165">Any active transactions that existed on the primary replica when the secondary replica was configured must commit or roll back.</span></span> <span data-ttu-id="69855-166">在此过程完成前，对辅助数据库的事务隔离级别映射将不完整，并且查询被暂时阻塞。</span><span class="sxs-lookup"><span data-stu-id="69855-166">Until this process completes, the transaction isolation level mapping on the secondary database is incomplete and queries are temporarily blocked.</span></span>  
  
    > [!WARNING]  
    >  <span data-ttu-id="69855-167">运行长时间运行的事务将影响保存的版本控制行数，对于基于磁盘的表和内存优化表都是如此。</span><span class="sxs-lookup"><span data-stu-id="69855-167">Running long transactions impacts the number of versioned rows kept, both for disk-based and memory-optimized tables.</span></span>  
  
-   <span data-ttu-id="69855-168">在具有内存优化表的辅助数据库上，即使始终对内存优化表生成行版本，也会阻塞查询，除非在启用辅助副本以便读取时主副本上的所有活动事务都已完成。</span><span class="sxs-lookup"><span data-stu-id="69855-168">On a secondary database with memory-optimized tables, even though row versions are always generated for memory-optimzied tables, queries are blocked until all active transactions that existed in the primary replica when the secondary replica was enabled for read complete.</span></span> <span data-ttu-id="69855-169">这将确保基于磁盘的表和内存优化表可同时用于报告工作负荷和只读查询。</span><span class="sxs-lookup"><span data-stu-id="69855-169">This ensures that both disk-based and memory-optimized tables are available to the reporting workload and read-only queries at the same time.</span></span>  
  
-   <span data-ttu-id="69855-170">属于可读辅助副本的辅助数据库不支持更改跟踪和变更数据捕获：</span><span class="sxs-lookup"><span data-stu-id="69855-170">Change tracking and change data capture are not supported on secondary databases that belong to a readable secondary replica:</span></span>  
  
    -   <span data-ttu-id="69855-171">在辅助数据库上显式禁用更改跟踪。</span><span class="sxs-lookup"><span data-stu-id="69855-171">Change tracking is explicitly disabled on secondary databases.</span></span>  
  
    -   <span data-ttu-id="69855-172">可以在辅助数据库上启用变更数据捕获，但不支持这样做。</span><span class="sxs-lookup"><span data-stu-id="69855-172">Change data capture can be enabled on a secondary database, but this is not supported.</span></span>  
  
-   <span data-ttu-id="69855-173">由于读操作会映射到快照隔离事务级别，因此，一个或多个辅助副本上的事务会阻止在主副本上清除虚影记录。</span><span class="sxs-lookup"><span data-stu-id="69855-173">Because read operations are mapped to snapshot isolation transaction level, the cleanup of ghost records on the primary replica can be blocked by transactions on one or more secondary replicas.</span></span> <span data-ttu-id="69855-174">当所有辅助副本都不再需要虚影记录时，虚影记录清除任务将自动清除主副本上基于磁盘的表的虚影记录。</span><span class="sxs-lookup"><span data-stu-id="69855-174">The ghost record cleanup task will automatically clean up the ghost records for disk-based tables on the primary replica when they are no longer needed by any secondary replica.</span></span>  <span data-ttu-id="69855-175">这类似于您在主副本上运行事务时执行的操作。</span><span class="sxs-lookup"><span data-stu-id="69855-175">This is similar to what is done when you run transaction(s) on the primary replica.</span></span> <span data-ttu-id="69855-176">在辅助数据库上的极端情况下，需要终止正在阻塞虚影清除的长时间运行的读查询。</span><span class="sxs-lookup"><span data-stu-id="69855-176">In the extreme case on the secondary database, you will need to kill a long running read-query that is blocking the ghost cleanup.</span></span> <span data-ttu-id="69855-177">请注意，如果辅助副本断开连接或数据移动在辅助数据库上挂起，可能阻塞虚影清除。</span><span class="sxs-lookup"><span data-stu-id="69855-177">Note, the ghost clean can be blocked if the secondary replica gets disconnected or when data movement is suspended on the secondary database.</span></span> <span data-ttu-id="69855-178">此状态还会阻止日志截断，因此，如果此状态持续，则我们建议您从可用性组中删除此辅助数据库。</span><span class="sxs-lookup"><span data-stu-id="69855-178">This state also prevents log truncation, so if this state persists, we recommend that you remove this secondary database from the availability group.</span></span> <span data-ttu-id="69855-179">内存优化表没有虚影记录清除问题，因为行版本保存在内存中，独立于主副本上的行版本。</span><span class="sxs-lookup"><span data-stu-id="69855-179">There is no ghost record cleanup issue with memory-optimized tables because the row versions are kept in memory and are independent of the row versions on the primary replica.</span></span>  
  
-   <span data-ttu-id="69855-180">如果文件包含辅助副本上仍需要的虚影记录，则主副本上对包含基于磁盘的表的文件的 DBCC SHRINKFILE 操作可能失败。</span><span class="sxs-lookup"><span data-stu-id="69855-180">The DBCC SHRINKFILE operation on files containing disk-based tables might fail on the primary replica if the file contains ghost records that are still needed on a secondary replica.</span></span>  
  
-   <span data-ttu-id="69855-181">从 [!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)]中开始，甚至在主副本由于用户操作或失败而脱机时可读辅助副本仍可保持联机状态。</span><span class="sxs-lookup"><span data-stu-id="69855-181">Beginning in [!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)], readable secondary replicas can remain online even when the primary replica is offline due to user action or a failure.</span></span> <span data-ttu-id="69855-182">但是，只读路由并不在此情况下工作，因为可用性组侦听器也处于脱机状态。</span><span class="sxs-lookup"><span data-stu-id="69855-182">However, read-only routing does not work in this situation because the availability group listener is offline as well.</span></span> <span data-ttu-id="69855-183">对于只读工作负荷，客户端必须直接连接到只读辅助副本。</span><span class="sxs-lookup"><span data-stu-id="69855-183">Clients must connect directly to the read-only secondary replicas for read-only workloads.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="69855-184">如果你在托管可读次要副本的服务器实例上查询 [sys.dm_db_index_physical_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql) 动态管理视图，则可能会遇到 REDO 阻塞问题。</span><span class="sxs-lookup"><span data-stu-id="69855-184">If you query the [sys.dm_db_index_physical_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql) dynamic management view on a server instance that is hosting a readable secondary replica, you might encounter a REDO blocking issue.</span></span> <span data-ttu-id="69855-185">这是因为此动态管理视图获取指定用户表或视图的 IS 锁，而该锁可能阻止 REDO 线程对该用户表或视图的 X 锁请求。</span><span class="sxs-lookup"><span data-stu-id="69855-185">This is because this dynamic management view acquires an IS lock on the specified user table or view that can block requests by a REDO thread for an X lock on that user table or view.</span></span>  
  
##  <a name="performance-considerations"></a><a name="bkmk_Performance"></a> <span data-ttu-id="69855-186">性能注意事项</span><span class="sxs-lookup"><span data-stu-id="69855-186">Performance Considerations</span></span>  
 <span data-ttu-id="69855-187">此节讨论可读辅助数据库的几个性能注意事项</span><span class="sxs-lookup"><span data-stu-id="69855-187">This section discusses several performance considerations for readable secondary databases</span></span>  
  
 
  
###  <a name="data-latency"></a><a name="DataLatency"></a> <span data-ttu-id="69855-188">数据滞后时间</span><span class="sxs-lookup"><span data-stu-id="69855-188">Data Latency</span></span>  
 <span data-ttu-id="69855-189">如果您的只读工作负荷可以容忍一定程度的数据滞后，则实现对辅助副本的只读访问很有用。</span><span class="sxs-lookup"><span data-stu-id="69855-189">Implementing read-only access to secondary replicas is useful if your read-only workloads can tolerate some data latency.</span></span> <span data-ttu-id="69855-190">在数据滞后不可接受的情况下，请考虑对主副本运行只读工作负荷。</span><span class="sxs-lookup"><span data-stu-id="69855-190">In situations where data latency is unacceptable, consider running read-only workloads against the primary replica.</span></span>  
  
 <span data-ttu-id="69855-191">主副本将主数据库上的更改日志记录发送到辅助副本。</span><span class="sxs-lookup"><span data-stu-id="69855-191">The primary replica sends log records of changes on primary database to the secondary replicas.</span></span> <span data-ttu-id="69855-192">在每个辅助数据库上，专用重做线程应用这些日志记录。</span><span class="sxs-lookup"><span data-stu-id="69855-192">On each secondary database, a dedicated redo thread applies the log records.</span></span> <span data-ttu-id="69855-193">在读访问权限的辅助数据库上，给定的数据更改不显示在查询结果中，直到包含更改的日志记录已应用到辅助数据库并且已在主数据库上提交事务。</span><span class="sxs-lookup"><span data-stu-id="69855-193">On a read-access secondary database, a given data change does not appear in query results until the log record that contains the change has been applied to the secondary database and the transaction has been committed on primary database.</span></span>  
  
 <span data-ttu-id="69855-194">这意味着在主副本和辅助副本之间将会存在一定程度的滞后时间，通常只需几秒钟。</span><span class="sxs-lookup"><span data-stu-id="69855-194">This means that there is some latency, usually only a matter of seconds, between the primary and secondary replicas.</span></span> <span data-ttu-id="69855-195">但是，在极少数情况下，例如在网络问题降低了网络吞吐量的情况下，滞后时间可能会较长。</span><span class="sxs-lookup"><span data-stu-id="69855-195">In unusual cases, however, for example if network issues reduce throughput, latency can become significant.</span></span> <span data-ttu-id="69855-196">在存在 I/O 瓶颈和数据移动操作处于挂起状态时，将增加滞后时间。</span><span class="sxs-lookup"><span data-stu-id="69855-196">Latency increases when I/O bottlenecks occur and when data movement is suspended.</span></span> <span data-ttu-id="69855-197">为了监视挂起的数据移动，可以使用 [AlwaysOn 面板](use-the-always-on-dashboard-sql-server-management-studio.md) 或 [sys.dm_hadr_database_replica_states](/sql/relational-databases/system-dynamic-management-views/sys-dm-hadr-database-replica-states-transact-sql) 动态管理视图。</span><span class="sxs-lookup"><span data-stu-id="69855-197">To monitor suspended data movement, you can use the [AlwaysOn Dashboard](use-the-always-on-dashboard-sql-server-management-studio.md) or the [sys.dm_hadr_database_replica_states](/sql/relational-databases/system-dynamic-management-views/sys-dm-hadr-database-replica-states-transact-sql) dynamic management view.</span></span>  
  
####  <a name="data-latency-on-databases-with-memory-optimized-tables"></a><a name="bkmk_LatencyWithInMemOLTP"></a> <span data-ttu-id="69855-198">具有内存优化表的数据库上的数据延迟</span><span class="sxs-lookup"><span data-stu-id="69855-198">Data Latency on databases with memory-optimized tables</span></span>  
 <span data-ttu-id="69855-199">为读取工作负荷访问辅助副本上的内存优化表时， *安全时间戳* 将用于从已于 *安全时间戳*之前提交的事务中返回行。</span><span class="sxs-lookup"><span data-stu-id="69855-199">When accessing memory-optimized tables on secondary replica for read workload, a *safe-timestamp* is used to return rows from transactions that have committed earlier than *safe-timestamp*.</span></span> <span data-ttu-id="69855-200">安全时间戳是垃圾收集线程用于对主副本上的行进行垃圾收集所使用的最早时间戳提示。</span><span class="sxs-lookup"><span data-stu-id="69855-200">The safe-timestamp is the oldest timestamp hint used by the garbage collection thread to garbage collect the rows on the primary replica.</span></span> <span data-ttu-id="69855-201">此时间戳将在自上次更新起内存优化表上的 DML 事务数超过内部阈值时更新。</span><span class="sxs-lookup"><span data-stu-id="69855-201">This timestamp is updated when the number of DML transactions on memory-optimized tables exceed an internal threshold since the last update.</span></span> <span data-ttu-id="69855-202">每当主副本上最早的事务时间戳更新时，持久的内存优化表上的下一 DML 事务会将此时间戳作为特定日志记录的一部分发送到辅助副本。</span><span class="sxs-lookup"><span data-stu-id="69855-202">Whenever the oldest transaction timestamp is updated on the primary replica, the next DML transaction on a durable memory-optimized table will send this timestamp to be sent to secondary replica as part of a special log record.</span></span> <span data-ttu-id="69855-203">辅助副本上的重做线程会在处理此日志记录时更新安全时间戳。</span><span class="sxs-lookup"><span data-stu-id="69855-203">REDO thread on the secondary replica, updates the safe-timestamp as part of processing this log record.</span></span>  
  
#### <a name="the-impact-of-safe-timestamp-on-latency"></a><span data-ttu-id="69855-204">安全时间戳对延迟的影响</span><span class="sxs-lookup"><span data-stu-id="69855-204">The impact of safe-timestamp on Latency</span></span>  
  
-   <span data-ttu-id="69855-205">对于事务吞吐量很高的 OLTP 工作负荷，延迟应与基于磁盘的表不相上下。</span><span class="sxs-lookup"><span data-stu-id="69855-205">For OLTP workloads with high transaction throughput, the latency should be comparable to disk-based tables.</span></span> <span data-ttu-id="69855-206">我们预计这是常见现象。</span><span class="sxs-lookup"><span data-stu-id="69855-206">We expect this to be the common case.</span></span>  
  
-   <span data-ttu-id="69855-207">长时间运行事务可能导致安全时间戳随机延迟。</span><span class="sxs-lookup"><span data-stu-id="69855-207">A long running transaction can cause the safe-timestamp to be delayed arbitrarily.</span></span>  <span data-ttu-id="69855-208">这与访问基于磁盘的表没有什么不同，因为快照隔离的时间戳取决于最早事务的提交时间。</span><span class="sxs-lookup"><span data-stu-id="69855-208">This is no different when accessing disk-based tables as the timestamp of snapshot isolation is determined by the commit of oldest transaction.</span></span>  
  
-   <span data-ttu-id="69855-209">自上次更新安全时间戳起，主副本上对事务的更改在下次传输和更新安全时间戳前在辅助副本上不可见。</span><span class="sxs-lookup"><span data-stu-id="69855-209">Changes made by transactions on the primary replica since the last safe-timestamp update are not visible on the secondary replica till the next transmission and update of the safe-timestamp.</span></span> <span data-ttu-id="69855-210">如果主副本上的事务活动在跨越安全时间戳更新的内部阈值之前停止，则自上次更新安全时间戳起所做的更改在辅助副本上将不可见。</span><span class="sxs-lookup"><span data-stu-id="69855-210">If transactional activity on the primary replica stops before the internal threshold for safe-timestamp update is crossed, the changes made since the last update to safe-timestamp will not be visible on the secondary replica.</span></span> <span data-ttu-id="69855-211">若要缓解此问题，您可能需要在主副本的虚拟持久的内存优化表上运行几个 DML 事务。</span><span class="sxs-lookup"><span data-stu-id="69855-211">To alleviate this issue, you may need to run a few DML transactions on a dummy durable memory-optimized table on the primary replica.</span></span> <span data-ttu-id="69855-212">您也可以通过运行手动检查点强制传送安全时间戳，但不建议这么做。</span><span class="sxs-lookup"><span data-stu-id="69855-212">Alternatively, though not recommended, you can force shipping of safe-timestamp by running a manual checkpoint.</span></span>  
  
#### <a name="monitoring-and-troubleshooting-data-latency-in-memory-optimized-tables"></a><span data-ttu-id="69855-213">监视内存优化表中的数据延迟并进行故障排除</span><span class="sxs-lookup"><span data-stu-id="69855-213">Monitoring and Troubleshooting data latency in memory-optimized tables</span></span>  
 <span data-ttu-id="69855-214">您可以通过在主副本上运行以下查询来查看安全时间戳</span><span class="sxs-lookup"><span data-stu-id="69855-214">You can find out the safe-timestamp by running the following query on the primary replica</span></span>  
  
```  
  
SELECT MAX(base_generation)   
   AS max_base_generation  
   FROM sys.dm_db_xtp_gc_cycle_stats  
GO  
  
```  
  
 <span data-ttu-id="69855-215">您还可以通过并发运行以下查询和活动的读取工作负荷，查明辅助副本上使用的安全时间戳。</span><span class="sxs-lookup"><span data-stu-id="69855-215">You can also identify the safe-timestamp used on the secondary replica by running the following query concurrently with the active read-workload.</span></span>  
  
```  
  
SELECT begin_tsn   
   FROM sys.dm_db_xtp_transactions  
GO  
  
```  
  
###  <a name="read-only-workload-impact"></a><a name="ReadOnlyWorkloadImpact"></a> <span data-ttu-id="69855-216">只读工作负荷的影响</span><span class="sxs-lookup"><span data-stu-id="69855-216">Read-Only Workload Impact</span></span>  
 <span data-ttu-id="69855-217">为辅助副本配置只读访问时，辅助数据库上的只读工作负荷占用来自重做线程的系统资源，如 CPU 和 I/O（对于基于磁盘的表），特别是在基于磁盘的表的只读工作负荷大量占用 I/O 的情况下。</span><span class="sxs-lookup"><span data-stu-id="69855-217">When you configure a secondary replica for read-only access, your read-only workloads on the secondary databases consume system resources, such as CPU and I/O (for disk-based tables) from redo threads, especially if the read-only workloads on disk-based tables are highly I/O-intensive.</span></span> <span data-ttu-id="69855-218">访问内存优化表时没有 IO 影响，因为所有行都驻留在内存中。</span><span class="sxs-lookup"><span data-stu-id="69855-218">There is no IO impact when accessing memory-optimized tables because all the rows reside in memory.</span></span>  
  
 <span data-ttu-id="69855-219">此外，辅助副本上的只读工作负荷还会阻止通过日志记录应用的数据定义语言 (DDL) 发生更改。</span><span class="sxs-lookup"><span data-stu-id="69855-219">Also, read-only workloads on the secondary replicas can block data definition language (DDL) changes that are applied through log records.</span></span>  
  
-   <span data-ttu-id="69855-220">虽然读取操作由于行版本控制而不会占用共享锁，但这些操作会占用架构稳定性 (Sch-S) 锁，这些锁可能会阻塞正在应用 DDL 更改的重做操作。</span><span class="sxs-lookup"><span data-stu-id="69855-220">Even though the read operations do not take shared locks because of row versioning, these operations take schema stability (Sch-S) locks, which can block redo operations that are applying DDL changes.</span></span> <span data-ttu-id="69855-221">DDL 操作包括 ALTER/DROP 表和视图，但不包括存储过程的 DROP 或 ALTER。</span><span class="sxs-lookup"><span data-stu-id="69855-221">DDL operations include ALTER/DROP tables and Views but not DROP or ALTER of stored procedures.</span></span> <span data-ttu-id="69855-222">因此，如果删除基于磁盘的表或内存优化表，请对主副本执行。</span><span class="sxs-lookup"><span data-stu-id="69855-222">So for example, if you drop a table disk-based or memory-optimized, on primary.</span></span> <span data-ttu-id="69855-223">当 REDO 线程处理日志记录以删除表时，必须获取表的 SCH_M 锁，并且必须可通过运行查询访问表阻塞。</span><span class="sxs-lookup"><span data-stu-id="69855-223">When REDO thread processes the log record to drop the table, it must acquire a SCH_M lock on the table and can get blocked by a running query accessing table.</span></span>  <span data-ttu-id="69855-224">对于主副本也是如此，只是删除表是用户会话的一部分，而不是 REDO 线程的一部份。</span><span class="sxs-lookup"><span data-stu-id="69855-224">This is the same behavior on primary replica except that the drop of the table is done as part of a user session and not REDO thread.</span></span>  
  
-   <span data-ttu-id="69855-225">还有其他阻塞内存优化表。</span><span class="sxs-lookup"><span data-stu-id="69855-225">There is additional blocking Memory-Optimized Tables.</span></span> <span data-ttu-id="69855-226">如果辅助副本上存在本机存储过程的并发执行，删除本机存储过程可以导致 REDO 线程阻塞。</span><span class="sxs-lookup"><span data-stu-id="69855-226">A drop of native stored procedure can cause REDO thread to block if there is a concurrent execution of the native stored procedure on the secondary replica.</span></span> <span data-ttu-id="69855-227">对于主副本也是如此，只是删除存储过程是用户会话的一部分，而不是 REDO 线程的一部份。</span><span class="sxs-lookup"><span data-stu-id="69855-227">This is the same behavior on the primary replica except that the drop of the stored procedure is done as part of a user session and not REDO thread.</span></span>  
  
 <span data-ttu-id="69855-228">应了解与生成查询有关的最佳实践，并且在辅助数据库中应用这些最佳实践。</span><span class="sxs-lookup"><span data-stu-id="69855-228">Be aware of best practices around building queries, and exercise those best practices in the secondary databases.</span></span> <span data-ttu-id="69855-229">例如，将需要长时间运行的查询（如数据聚合）安排在低活动期间进行。</span><span class="sxs-lookup"><span data-stu-id="69855-229">For example, schedule long-running queries such as aggregations of data during times of low activity.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="69855-230">如果 REDO 线程被次要副本上的查询阻塞，将引发 **sqlserver.lock_redo_blocked** XEvent。</span><span class="sxs-lookup"><span data-stu-id="69855-230">If a redo thread is blocked by queries on a secondary replica, the **sqlserver.lock_redo_blocked** XEvent is raised.</span></span>  
  
###  <a name="indexing"></a><a name="bkmk_Indexing"></a> <span data-ttu-id="69855-231">索引</span><span class="sxs-lookup"><span data-stu-id="69855-231">Indexing</span></span>  
 <span data-ttu-id="69855-232">若要优化可读辅助副本上的只读工作负荷，您可能需要对辅助数据库中的表创建索引。</span><span class="sxs-lookup"><span data-stu-id="69855-232">To optimize read-only workloads on the readable secondary replicas, you may want to create indexes on the tables in the secondary databases.</span></span> <span data-ttu-id="69855-233">因为您无法在辅助数据库上进行架构或数据更改，所以应在主数据库中创建索引，并且允许更改通过重做进程传输到辅助数据库。</span><span class="sxs-lookup"><span data-stu-id="69855-233">Because you cannot make schema or data changes on the secondary databases, create indexes in the primary databases and allow the changes to transfer to the secondary database through the redo process.</span></span>  
  
 <span data-ttu-id="69855-234">若要监视辅助副本上的索引使用活动，请查询 **sys.dm_db_index_usage_stats**动态管理视图的 **user_seeks**、 **user_scans** 和 [user_lookups](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-usage-stats-transact-sql) 列。</span><span class="sxs-lookup"><span data-stu-id="69855-234">To monitor index usage activity on a secondary replica, query the **user_seeks**, **user_scans**, and **user_lookups** columns of the [sys.dm_db_index_usage_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-usage-stats-transact-sql) dynamic management view.</span></span>  
  
###  <a name="statistics-for-read-only-access-databases"></a><a name="Read-OnlyStats"></a> <span data-ttu-id="69855-235">只读访问数据库的统计信息</span><span class="sxs-lookup"><span data-stu-id="69855-235">Statistics for Read-Only Access Databases</span></span>  
 <span data-ttu-id="69855-236">表和索引视图的列的统计信息用于优化查询计划。</span><span class="sxs-lookup"><span data-stu-id="69855-236">Statistics on columns of tables and indexed views are used to optimize query plans.</span></span> <span data-ttu-id="69855-237">对于可用性组，作为应用事务日志记录操作的一部分，在主数据库上创建和维护的统计信息将自动保留在辅助数据库中。</span><span class="sxs-lookup"><span data-stu-id="69855-237">For availability groups, statistics that are created and maintained on the primary databases are automatically persisted on the secondary databases as part of applying the transaction log records.</span></span> <span data-ttu-id="69855-238">但是，辅助数据库上的只读工作负荷需要的统计信息可能与在主数据库上创建的统计信息不同。</span><span class="sxs-lookup"><span data-stu-id="69855-238">However, the read-only workload on the secondary databases may need different statistics than those that are created on the primary databases.</span></span> <span data-ttu-id="69855-239">但是，因为辅助数据库被限制为只读访问，所以无法在辅助数据库上创建统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-239">However, because secondary databases are restricted to read-only access, statistics cannot be created on the secondary databases.</span></span>  
  
 <span data-ttu-id="69855-240">为了解决此问题，辅助副本在 **tempdb**中创建和维护辅助数据库的临时统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-240">To address this problem, the secondary replica creates and maintains temporary statistics for secondary databases in **tempdb**.</span></span> <span data-ttu-id="69855-241">将在临时统计信息名称后追加后缀 The suffix _readonly_database_statistic，以便将临时统计信息与主数据库永久保存的永久统计信息加以区分。</span><span class="sxs-lookup"><span data-stu-id="69855-241">The suffix _readonly_database_statistic is appended to the name of temporary statistics to differentiate them from the permanent statistics that are persisted from the primary database.</span></span>  
  
 <span data-ttu-id="69855-242">只有 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 可以创建和更新临时统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-242">Only [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can create and update temporary statistics.</span></span> <span data-ttu-id="69855-243">但是，您可以借助用于永久统计信息的相同工具来删除临时统计信息和监视其属性：</span><span class="sxs-lookup"><span data-stu-id="69855-243">However, you can delete temporary statistics and monitor their properties using the same tools that you use for permanent statistics:</span></span>  
  
-   <span data-ttu-id="69855-244">使用 [DROP STATISTICS](/sql/t-sql/statements/drop-statistics-transact-sql)[!INCLUDE[tsql](../../../includes/tsql-md.md)] 语句删除临时统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-244">Delete temporary statistics using the [DROP STATISTICS](/sql/t-sql/statements/drop-statistics-transact-sql)[!INCLUDE[tsql](../../../includes/tsql-md.md)] statement.</span></span>  
  
-   <span data-ttu-id="69855-245">使用 **sys.stats** 和 **sys.stats_columns** 目录视图监视统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-245">Monitor statistics using the **sys.stats** and **sys.stats_columns** catalog views.</span></span> <span data-ttu-id="69855-246">**sys_stats** 包含一个 **is_temporary**列，用于指示哪些统计信息是永久的，哪些统计信息是临时的。</span><span class="sxs-lookup"><span data-stu-id="69855-246">**sys_stats** includes a column, **is_temporary**, to indicate which statistics are permanent and which are temporary.</span></span>  
  
 <span data-ttu-id="69855-247">不支持自动更新主副本或辅助副本上内存优化表的统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-247">There is no support for auto-statistics update for memory-optimized tables on the primary or secondary replica.</span></span> <span data-ttu-id="69855-248">必须监视辅助副本上的查询性能和计划，在需要时手动更新主副本上的统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-248">You must monitor query performance and plans on the secondary replica and manually update the statistics on the primary replica when needed.</span></span> <span data-ttu-id="69855-249">不过，会在主副本和辅助副本上自动创建缺少的统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-249">However, the missing statistics are automatically created both on primary and secondary replica.</span></span>  
  
 <span data-ttu-id="69855-250">有关 SQL Server 统计信息的详细信息，请参阅 [统计信息](../../../relational-databases/statistics/statistics.md)。</span><span class="sxs-lookup"><span data-stu-id="69855-250">For more information about SQL Server statistics, see [Statistics](../../../relational-databases/statistics/statistics.md).</span></span>  
  

  
####  <a name="stale-permanent-statistics-on-secondary-databases"></a><a name="StalePermStats"></a> <span data-ttu-id="69855-251">辅助数据库上陈旧的永久统计信息</span><span class="sxs-lookup"><span data-stu-id="69855-251">Stale Permanent Statistics on Secondary Databases</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="69855-252">可检测辅助数据库上的永久统计信息的过时时间。</span><span class="sxs-lookup"><span data-stu-id="69855-252">detects when permanent statistics on a secondary database are stale.</span></span> <span data-ttu-id="69855-253">但是，除了通过主数据库进行更改外，不能对永久统计信息进行更改。</span><span class="sxs-lookup"><span data-stu-id="69855-253">But changes cannot be made to the permanent statistics except through changes on the primary database.</span></span> <span data-ttu-id="69855-254">为了进行查询优化， [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 在辅助数据库上为基于磁盘的表创建临时统计信息并使用它们来替代过时的永久统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-254">For query optimization, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] creates temporary statistics for disk-based tables on the secondary database and uses these statistics instead of the stale permanent statistics.</span></span>  
  
 <span data-ttu-id="69855-255">永久统计信息在主数据库上进行更新后，自动将它们永久保存到辅助数据库。</span><span class="sxs-lookup"><span data-stu-id="69855-255">When the permanent statistics are updated on the primary database, they are automatically persisted to the secondary database.</span></span> <span data-ttu-id="69855-256">然后， [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 使用更新的永久统计信息，该信息比临时统计信息要新。</span><span class="sxs-lookup"><span data-stu-id="69855-256">Then [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] uses the updated permanent statistics, which are more current than the temporary statistics.</span></span>  
  
 <span data-ttu-id="69855-257">如果可用性组进行故障转移，则在所有辅助副本上删除临时统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-257">If the availability group fails over, temporary statistics are deleted on all of the secondary replicas.</span></span>  
  
####  <a name="limitations-and-restrictions"></a><a name="StatsLimitationsRestrictions"></a> <span data-ttu-id="69855-258">限制和局限</span><span class="sxs-lookup"><span data-stu-id="69855-258">Limitations and Restrictions</span></span>  
  
-   <span data-ttu-id="69855-259">因为临时统计信息存储于 **tempdb**中，所以重新启动 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 服务将导致所有临时统计信息消失。</span><span class="sxs-lookup"><span data-stu-id="69855-259">Because temporary statistics are stored in **tempdb**, a restart of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] service causes all temporary statistics to disappear.</span></span>  
  
-   <span data-ttu-id="69855-260">后缀 suffix _readonly_database_statistic 是为 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]生成的统计信息预留的。</span><span class="sxs-lookup"><span data-stu-id="69855-260">The suffix _readonly_database_statistic is reserved for statistics generated by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="69855-261">在主数据库上创建统计信息时不能使用此后缀。</span><span class="sxs-lookup"><span data-stu-id="69855-261">You cannot use this suffix when creating statistics on a primary database.</span></span> <span data-ttu-id="69855-262">有关详细信息，请参阅[统计信息](../../../relational-databases/statistics/statistics.md)。</span><span class="sxs-lookup"><span data-stu-id="69855-262">For more information, see [Statistics](../../../relational-databases/statistics/statistics.md).</span></span>  
  
##  <a name="accessing-memory-optimized-tables-on-a-secondary-replica"></a><a name="bkmk_AccessInMemTables"></a> <span data-ttu-id="69855-263">访问辅助副本上的内存优化表</span><span class="sxs-lookup"><span data-stu-id="69855-263">Accessing memory-optimized tables on a Secondary Replica</span></span>  
 <span data-ttu-id="69855-264">辅助副本上的读取工作负荷隔离级别只是主副本上允许的隔离级别。</span><span class="sxs-lookup"><span data-stu-id="69855-264">The read workload isolation levels on secondary replica are only those allowed on the primary replica.</span></span> <span data-ttu-id="69855-265">辅助副本上没有隔离级别映射。</span><span class="sxs-lookup"><span data-stu-id="69855-265">There is no mapping of isolations levels done on the secondary replica.</span></span> <span data-ttu-id="69855-266">这确保可在主副本上运行的所有报表工作负荷都无需任何更改就可以在辅助副本上运行。</span><span class="sxs-lookup"><span data-stu-id="69855-266">This ensure that any reporting workload that can be run on primary replica is able to run on the secondary replica without requiring any changes.</span></span> <span data-ttu-id="69855-267">这样，您可以轻松地将报表工作负荷从主副本迁移到辅助副本，或者从辅助副本迁移到主副本（当辅助副本不可用时）。</span><span class="sxs-lookup"><span data-stu-id="69855-267">This makes it easy for you to migrate a reporting workload from the primary replica to a secondary or vice versa when the secondary replica is not available.</span></span>  
  
 <span data-ttu-id="69855-268">以下查询在辅助副本上运行失败的方式与它们在主副本上失败的方式相同。</span><span class="sxs-lookup"><span data-stu-id="69855-268">The following queries fail to run on the secondary replica similarly to the way they fail on the primary replica.</span></span>  
  
-   <span data-ttu-id="69855-269">对于仅对内存优化表运行的查询，只支持快照、可重复读和可序列化隔离级别。</span><span class="sxs-lookup"><span data-stu-id="69855-269">For queries running only on memory-optimized tables, the only supported isolation levels are snapshot, repeatable read, and serializable.</span></span> <span data-ttu-id="69855-270">除非在数据库级别启用了 MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT 选项，否则所有具有未提交读或读提交隔离级别的查询都会返回错误。</span><span class="sxs-lookup"><span data-stu-id="69855-270">Any queries with read-uncommitted or read committed isolation level returns an error unless you have enabled the option MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT at the database level.</span></span>  
  
    ```sql  
    SET TRANSACTION ISOLATION LEVEL READ_COMMITTED  
    -- This is not allowed  
    BEGIN TRAN  
    SELECT * FROM t_hk  
    COMMIT  
  
    ```  
  
     <span data-ttu-id="69855-271">错误消息：</span><span class="sxs-lookup"><span data-stu-id="69855-271">Error message:</span></span>  
  
    ```  
    Msg 41368, Level 16, State 0, Line 2  
    Accessing memory optimized tables using the CREAD_COMMITTED isolation level is supported only for autocommit transactions. It is not supported for explicit or implicit transactions. Provide a supported isolation level for the memory optimized table using a table hing, such as WITH (SNAPSHOT).  
    ```  
  
-   <span data-ttu-id="69855-272">内存优化表不支持锁定提示。</span><span class="sxs-lookup"><span data-stu-id="69855-272">No locking hints are supported on memory-optimized tables.</span></span> <span data-ttu-id="69855-273">例如，以下所有查询都会因错误失败。</span><span class="sxs-lookup"><span data-stu-id="69855-273">For example, all of the following queries fail with an error.</span></span> <span data-ttu-id="69855-274">只允许 NOLOCK 提示，用于内存优化表时为 NOOP。</span><span class="sxs-lookup"><span data-stu-id="69855-274">Only NOLOCK hint is allowed and it is NOOP when used with memory-optimized tables.</span></span>  
  
    ```sql  
    SELECT * FROM t_hk WITH (PAGLOCK)  
    SELECT * FROM t_hk WITH (READPAST)  
    SELECT * FROM t_hk WITH (ROWLOCK)  
    SELECT * FROM t_hk WITH (READPAST)  
    SELECT * FROM t_hk WITH (TABLOCK)  
    SELECT * FROM t_hk WITH (XLOCK)  
    SELECT * FROM t_hk WITH (UPDLOCK)  
    ```  
  
-   <span data-ttu-id="69855-275">对于跨容器事务，不支持会话隔离级别为 "快照" 的事务访问内存优化表。</span><span class="sxs-lookup"><span data-stu-id="69855-275">For cross-container transactions, transactions with session isolation level "snapshot" that access memory-optimized tables is not supported.</span></span> <span data-ttu-id="69855-276">例如，应用于对象的</span><span class="sxs-lookup"><span data-stu-id="69855-276">For example,</span></span>  
  
    ```sql  
    SET TRANSACTION ISOLATION LEVEL SNAPSHOT  
    -- This is not allowed  
    BEGIN TRAN  
       SELECT * FROM t_hk  
    COMMIT  
    ```  
  
     <span data-ttu-id="69855-277">错误消息：</span><span class="sxs-lookup"><span data-stu-id="69855-277">Error message:</span></span>  
  
    ```  
    Msg 41332, Level 16, State 0, Line 5  
    Memory optimized tables and natively compiled stored procedures cannot be accessed or created when the session TRANSACTION ISOLATION LEVEL is set to SNAPSHOT.  
    ```  
  
##  <a name="capacity-planning-considerations"></a><a name="bkmk_CapacityPlanning"></a> <span data-ttu-id="69855-278">容量规划注意事项</span><span class="sxs-lookup"><span data-stu-id="69855-278">Capacity Planning Considerations</span></span>  
  
-   <span data-ttu-id="69855-279">对于基于磁盘的表，可读次要副本出于以下两个原因需要占用 **tempdb** 中的空间：</span><span class="sxs-lookup"><span data-stu-id="69855-279">In the case of disk-based tables, readable secondary replicas can require space in **tempdb** for two reasons:</span></span>  
  
    -   <span data-ttu-id="69855-280">快照隔离级别会将行版本复制到 **tempdb**中。</span><span class="sxs-lookup"><span data-stu-id="69855-280">Snapshot isolation level copies row versions into **tempdb**.</span></span>  
  
    -   <span data-ttu-id="69855-281">在 **tempdb**中创建和维护辅助数据库的临时统计信息。</span><span class="sxs-lookup"><span data-stu-id="69855-281">Temporary statistics for secondary databases are created and maintained in **tempdb**.</span></span> <span data-ttu-id="69855-282">临时统计信息会促使略微增大 **tempdb**的大小。</span><span class="sxs-lookup"><span data-stu-id="69855-282">The temporary statistics can cause a slight increase in the size of **tempdb**.</span></span> <span data-ttu-id="69855-283">有关详细信息，请参阅本节后面的 [只读访问数据库的统计信息](#Read-OnlyStats)。</span><span class="sxs-lookup"><span data-stu-id="69855-283">For more information, see [Statistics for Read-Only Access Databases](#Read-OnlyStats), later in this section.</span></span>  
  
-   <span data-ttu-id="69855-284">在配置对一个或多个辅助副本的读访问时，主数据库将对已删除、修改或插入的数据行添加 14 个字节的系统开销，以便为基于磁盘的表存储指向辅助数据库上的行版本的指针。</span><span class="sxs-lookup"><span data-stu-id="69855-284">When you configure read-access for one or more secondary replicas, the primary databases add 14 bytes of overhead on deleted, modified, or inserted data rows to store pointers to row versions on the secondary databases for disk-based tables.</span></span> <span data-ttu-id="69855-285">这 14 个字节开销将转入辅助数据库。</span><span class="sxs-lookup"><span data-stu-id="69855-285">This 14-byte overhead is carried over to the secondary databases.</span></span> <span data-ttu-id="69855-286">在向数据行添加 14 个字节的系统开销时，可能会发生页拆分。</span><span class="sxs-lookup"><span data-stu-id="69855-286">As the 14-byte overhead is added to data rows, page splits might occur.</span></span>  
  
     <span data-ttu-id="69855-287">行版本数据不由主数据库生成。</span><span class="sxs-lookup"><span data-stu-id="69855-287">The row version data is not generated by the primary databases.</span></span> <span data-ttu-id="69855-288">而是辅助数据库生成行版本。</span><span class="sxs-lookup"><span data-stu-id="69855-288">Instead, the secondary databases generate the row versions.</span></span> <span data-ttu-id="69855-289">但是，行版本控制在主数据库和辅助数据库中都会增加数据存储。</span><span class="sxs-lookup"><span data-stu-id="69855-289">However, row versioning increases data storage in both the primary and secondary databases.</span></span>  
  
     <span data-ttu-id="69855-290">行版本数据的增加依赖于主数据库上的快照隔离或读提交快照隔离 (RCSI) 级别设置。</span><span class="sxs-lookup"><span data-stu-id="69855-290">The addition of the row version data depends on the snapshot isolation or read-committed snapshot isolation (RCSI) level setting on the primary database.</span></span> <span data-ttu-id="69855-291">下表介绍可读辅助数据库上基于磁盘的表的不同设置下的版本控制行为。</span><span class="sxs-lookup"><span data-stu-id="69855-291">The table below describes the behavior of versioning on a readable secondary database under different settings for disk based tables.</span></span>  
  
    |<span data-ttu-id="69855-292">可读辅助副本？</span><span class="sxs-lookup"><span data-stu-id="69855-292">Readable secondary replica?</span></span>|<span data-ttu-id="69855-293">启用了快照隔离或 RCSI 级别隔离？</span><span class="sxs-lookup"><span data-stu-id="69855-293">Snapshot isolation or RCSI level enabled?</span></span>|<span data-ttu-id="69855-294">主数据库</span><span class="sxs-lookup"><span data-stu-id="69855-294">Primary Database</span></span>|<span data-ttu-id="69855-295">辅助数据库</span><span class="sxs-lookup"><span data-stu-id="69855-295">Secondary Database</span></span>|  
    |---------------------------------|-----------------------------------------------|----------------------|------------------------|  
    |<span data-ttu-id="69855-296">否</span><span class="sxs-lookup"><span data-stu-id="69855-296">No</span></span>|<span data-ttu-id="69855-297">否</span><span class="sxs-lookup"><span data-stu-id="69855-297">No</span></span>|<span data-ttu-id="69855-298">无行版本或 14 个字节的系统开销</span><span class="sxs-lookup"><span data-stu-id="69855-298">No row versions or 14-byte overhead</span></span>|<span data-ttu-id="69855-299">无行版本或 14 个字节的系统开销</span><span class="sxs-lookup"><span data-stu-id="69855-299">No row versions or 14-byte overhead</span></span>|  
    |<span data-ttu-id="69855-300">否</span><span class="sxs-lookup"><span data-stu-id="69855-300">No</span></span>|<span data-ttu-id="69855-301">是</span><span class="sxs-lookup"><span data-stu-id="69855-301">Yes</span></span>|<span data-ttu-id="69855-302">行版本和 14 个字节的系统开销</span><span class="sxs-lookup"><span data-stu-id="69855-302">Row versions and 14-byte overhead</span></span>|<span data-ttu-id="69855-303">无行版本但有 14 个字节的系统开销</span><span class="sxs-lookup"><span data-stu-id="69855-303">No row versions, but 14-byte overhead</span></span>|  
    |<span data-ttu-id="69855-304">是</span><span class="sxs-lookup"><span data-stu-id="69855-304">Yes</span></span>|<span data-ttu-id="69855-305">否</span><span class="sxs-lookup"><span data-stu-id="69855-305">No</span></span>|<span data-ttu-id="69855-306">无行版本但有 14 个字节的系统开销</span><span class="sxs-lookup"><span data-stu-id="69855-306">No row versions, but 14-byte overhead</span></span>|<span data-ttu-id="69855-307">行版本和 14 个字节的系统开销</span><span class="sxs-lookup"><span data-stu-id="69855-307">Row versions and 14-byte overhead</span></span>|  
    |<span data-ttu-id="69855-308">是</span><span class="sxs-lookup"><span data-stu-id="69855-308">Yes</span></span>|<span data-ttu-id="69855-309">是</span><span class="sxs-lookup"><span data-stu-id="69855-309">Yes</span></span>|<span data-ttu-id="69855-310">行版本和 14 个字节的系统开销</span><span class="sxs-lookup"><span data-stu-id="69855-310">Row versions and 14-byte overhead</span></span>|<span data-ttu-id="69855-311">行版本和 14 个字节的系统开销</span><span class="sxs-lookup"><span data-stu-id="69855-311">Row versions and 14-byte overhead</span></span>|  
  
##  <a name="related-tasks"></a><a name="bkmk_RelatedTasks"></a> <span data-ttu-id="69855-312">相关任务</span><span class="sxs-lookup"><span data-stu-id="69855-312">Related Tasks</span></span>  
  
-   [<span data-ttu-id="69855-313">配置对可用性副本的只读访问 (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="69855-313">Configure Read-Only Access on an Availability Replica &#40;SQL Server&#41;</span></span>](configure-read-only-access-on-an-availability-replica-sql-server.md)  
  
-   [<span data-ttu-id="69855-314">为可用性组配置只读路由 (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="69855-314">Configure Read-Only Routing for an Availability Group &#40;SQL Server&#41;</span></span>](configure-read-only-routing-for-an-availability-group-sql-server.md)  
  
-   [<span data-ttu-id="69855-315">创建或配置可用性组侦听程序 (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="69855-315">Create or Configure an Availability Group Listener &#40;SQL Server&#41;</span></span>](create-or-configure-an-availability-group-listener-sql-server.md)  
  
-   [<span data-ttu-id="69855-316">监视可用性组 (Transact-SQL)</span><span class="sxs-lookup"><span data-stu-id="69855-316">Monitor Availability Groups &#40;Transact-SQL&#41;</span></span>](monitor-availability-groups-transact-sql.md)  
  
-   [<span data-ttu-id="69855-317">查看可用性副本属性 (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="69855-317">View Availability Replica Properties &#40;SQL Server&#41;</span></span>](view-availability-replica-properties-sql-server.md)  
  
-   [<span data-ttu-id="69855-318">使用“新建可用性组”对话框 (SQL Server Management Studio)</span><span class="sxs-lookup"><span data-stu-id="69855-318">Use the New Availability Group Dialog Box &#40;SQL Server Management Studio&#41;</span></span>](use-the-new-availability-group-dialog-box-sql-server-management-studio.md)  
  
##  <a name="related-content"></a><a name="RelatedContent"></a> <span data-ttu-id="69855-319">相关内容</span><span class="sxs-lookup"><span data-stu-id="69855-319">Related Content</span></span>  
  
-   [<span data-ttu-id="69855-320">SQL Server AlwaysOn 团队博客：SQL Server AlwaysOn 官方团队博客</span><span class="sxs-lookup"><span data-stu-id="69855-320">SQL Server AlwaysOn Team Blog: The official SQL Server AlwaysOn Team Blog</span></span>](https://blogs.msdn.com/b/sqlalwayson/)  
  
## <a name="see-also"></a><span data-ttu-id="69855-321">另请参阅</span><span class="sxs-lookup"><span data-stu-id="69855-321">See Also</span></span>  
 <span data-ttu-id="69855-322">[AlwaysOn 可用性组 &#40;SQL Server 概述&#41;](overview-of-always-on-availability-groups-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="69855-322">[Overview of AlwaysOn Availability Groups &#40;SQL Server&#41;](overview-of-always-on-availability-groups-sql-server.md) </span></span>  
 <span data-ttu-id="69855-323">[关于对可用性副本的客户端连接访问 &#40;SQL Server&#41;](about-client-connection-access-to-availability-replicas-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="69855-323">[About Client Connection Access to Availability Replicas &#40;SQL Server&#41;](about-client-connection-access-to-availability-replicas-sql-server.md) </span></span>  
 <span data-ttu-id="69855-324">[可用性组侦听程序、客户端连接和应用程序故障转移 &#40;SQL Server&#41;](../../listeners-client-connectivity-application-failover.md) </span><span class="sxs-lookup"><span data-stu-id="69855-324">[Availability Group Listeners, Client Connectivity, and Application Failover &#40;SQL Server&#41;](../../listeners-client-connectivity-application-failover.md) </span></span>  
 [<span data-ttu-id="69855-325">统计信息</span><span class="sxs-lookup"><span data-stu-id="69855-325">Statistics</span></span>](../../../relational-databases/statistics/statistics.md)  
  
  
